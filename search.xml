<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/25/hello-world/"/>
      <url>/2019/12/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
            <tag> 表格 </tag>
            
            <tag> 表单验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript2015</title>
      <link href="/2019/12/24/ECMAScript2015/"/>
      <url>/2019/12/24/ECMAScript2015/</url>
      
        <content type="html"><![CDATA[<h1 id="ECMAScript2015"><a href="#ECMAScript2015" class="headerlink" title="ECMAScript2015"></a>ECMAScript2015</h1><h2 id="1-let和const命令"><a href="#1-let和const命令" class="headerlink" title="1-let和const命令"></a>1-let和const命令</h2><p>在ES6中，我们通常实用 <code>let</code>表示变量，<code>const</code>表示常量，并且 <code>let</code> 和 <code>const</code> 都是块级作用域，且在当前作用域有效不能重复声明</p><h3 id="1-1-let-命令"><a href="#1-1-let-命令" class="headerlink" title="1.1 let 命令"></a>1.1 let 命令</h3><p><code>let</code> 命令的用法和 <code>var</code> 相似，但是 let 只在所在代码块内有效</p><p><strong>基础用法</strong></p><pre><code class="js">{  let a = 1;  let b = 2;}</code></pre><p>并且 <code>let</code> 有以下特点：</p><ul><li>不存在变量提升：<br>在ES6之前，我们 var 声明一个<strong>变量一个函数</strong>，都会伴随着变量提升的问题，导致实际开发过程经常出现一些逻辑上的疑惑，按照一般思维习惯，变量都是需要先声明后使用。<pre><code class="javaScript">// var console.log(v1); // undefinedvar v1 = 2;// 由于变量提升 代码实际如下var v1;console.log(v1)v1 = 2;// let console.log(v2); // ReferenceErrorlet v2 = 2;</code></pre></li><li>不允许重复声明：<br><code>let</code> 和 <code>const</code> 在<strong>相同作用域下</strong>，都<strong>不能重复声明同一变量</strong>，并且<strong>不能在函数内重新声明参数。</strong></li></ul><pre><code class="javaScript">// 1. 不能重复声明同一变量// 报错function f1 (){    let a = 1;    var a = 2;}// 报错function f2 (){    let a = 1;    let a = 2;}// 2. 不能在函数内重新声明参数// 报错function f3 (a1){    let a1; }// 不报错function f4 (a2){    {        let a2    }}</code></pre><h3 id="1-2-const-命令"><a href="#1-2-const-命令" class="headerlink" title="1.2 const 命令"></a>1.2 const 命令</h3><p><code>const</code> 声明一个只读的常量。</p><p><strong>基础用法：</strong></p><pre><code class="js">const PI = 3.1415926;console.log(PI);  // 3.1415926</code></pre><p><strong>注意点：</strong></p><ul><li><code>const</code> 声明后，无法修改值；<pre><code class="javaScript">const PI = 3.1415926;PI = 3; // TypeError: Assignment to constant variable.</code></pre></li><li><code>const</code> 声明时，必须赋值；<pre><code class="js">const a ; // SyntaxError: Missing initializer in const declaration.</code></pre></li><li><code>const</code> 声明的常量，<code>let</code> 不能重复声明；<pre><code class="js">const PI = 3.1415926;let PI = 0;  // Uncaught SyntaxError: Identifier &#39;PI&#39; has already been declared</code></pre></li></ul><h2 id="2-变量的解构赋值"><a href="#2-变量的解构赋值" class="headerlink" title="2-变量的解构赋值"></a>2-变量的解构赋值</h2><p><code>解构赋值概念：</code>在ES6中，直接从数组和对象中取值，按照对应位置，赋值给变量的操作。</p><h3 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h3><p><strong>基础用法：</strong></p><pre><code class="js">// ES6 之前let a = 1;let b = 2;// ES6 之后let [a, b] = [1, 2];</code></pre><p>本质上，只要等号两边模式一致，左边变量即可获取右边对应位置的值，更多用法：</p><pre><code class="js">let [a, [[b], c]] = [1, [[2], 3]];console.log(a, b, c); // 1, 2, 3let [ , , c] = [1, 2, 3];console.log(c);       // 3let [a, , c] = [1, 2, 3];console.log(a,c);     // 1, 3let [a, ...b] = [1, 2, 3];console.log(a,b);     // 1, [2,3]let [a, b, ..c.] = [1];console.log(a, b, c); // 1, undefined, []</code></pre><p><strong>注意点：</strong></p><ul><li>如果解构不成功，变量的值就等于undefined。<pre><code class="js">let [a] = [];     // a =&gt; undefinedlet [a, b] = [1]; // a =&gt; 1 , b =&gt; undefined</code></pre></li><li>当左边模式多于右边，也可以解构成功。<pre><code class="js">let [a, b] = [1, 2, 3];console.log(a, b); // 1, 2</code></pre></li><li>两边模式不同，报错。<pre><code class="js">let [a] = 1;let [a] = false;let [a] = NaN;let [a] = undefined;let [a] = null;let [a] = {};</code></pre></li><li><em>指定解构的默认值：*</em></li><li><em>基础用法：*</em><pre><code class="js">let [a = 1] = [];      // a =&gt; 1let [a, b = 2] = [a];  // a =&gt; 1 , b =&gt; 2</code></pre></li><li><em>特殊情况：*</em><pre><code class="js">let [a = 1] = [undefined]; // a =&gt; 1let [a = 1] = [null];      // a =&gt; null</code></pre><h3 id="2-2-对象的解构赋值"><a href="#2-2-对象的解构赋值" class="headerlink" title="2.2 对象的解构赋值"></a>2.2 对象的解构赋值</h3>右边模式对应的值，必须严格等于<code>undefined</code>，默认值才能生效，而<code>null</code>不严格等于<code>undefined</code>。</li><li><em>基础用法：*</em><pre><code class="js">let {a, b} = {a:1, b:2};  // a =&gt; 1 , b =&gt; 2let {a, b} = {a:2, b:1};  // a =&gt; 2 , b =&gt; 1let {a} = {a:3, b:2, c:1};// a =&gt; 3let {a} = {b:2, c:1};     // a =&gt; undefined</code></pre></li><li><em>注意点：*</em></li><li>若变量名和属性名不一致，则需要修改名称。<pre><code class="js">let {a:b} = {a:1, c:2}; // error: a is not defined// b =&gt; 1</code></pre>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。<br>上面代码中，<code>a</code>是匹配的模式，<code>b</code>才是变量。真正被赋值的是变量<code>b</code>，而不是模式<code>a</code>。</li><li>对象解构也支持嵌套解构。<pre><code class="js">let obj = {  a:[ 1, { b: 2}]};let {a, a: [c, {b}]} = obj;// a=&gt;[1, {b: 2}], b =&gt; 2, c =&gt; 1</code></pre></li><li><em>指定解构的默认值：*</em><pre><code class="javaScript">let {a=1} = {};        // a =&gt; 1let {a, b=1} = {a:2};  // a =&gt; 2, b =&gt; 1let {a:b=3} = {};      // b =&gt; 3let {a:b=3} = {a:4};   // b = &gt;4// a是模式，b是变量 牢记let {a=1} = {a:undefined};  // a =&gt; 1let {a=1} = {a:null};   // a =&gt; null// 因为null与undefined不严格相等，所以赋值有效// 导致默认值1不会生效。</code></pre></li></ul><h3 id="2-3-字符串的解构赋值"><a href="#2-3-字符串的解构赋值" class="headerlink" title="2.3 字符串的解构赋值"></a>2.3 字符串的解构赋值</h3><p>字符串的解构赋值中，字符串被转换成了一个<strong>类似数组的对象</strong>。 <strong>基础用法：</strong></p><pre><code class="js">const [a, b, c, d, e] = &#39;hello&#39;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot;let {length:len} = &#39;hello&#39;;// len =&gt; 5</code></pre><h3 id="2-4-数值和布尔值的解构赋值"><a href="#2-4-数值和布尔值的解构赋值" class="headerlink" title="2.4 数值和布尔值的解构赋值"></a>2.4 数值和布尔值的解构赋值</h3><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p><pre><code class="js">// 数值和布尔值的包装对象都有toString属性let {toString: s} = 123;s === Number.prototype.toString // truelet {toString: s} = true;s === Boolean.prototype.toString // truelet { prop: x } = undefined; // TypeErrorlet { prop: y } = null;      // TypeError</code></pre><h3 id="2-5-函数参数的解构赋值"><a href="#2-5-函数参数的解构赋值" class="headerlink" title="2.5 函数参数的解构赋值"></a>2.5 函数参数的解构赋值</h3><p><strong>基础使用：</strong></p><pre><code class="javaScript">function fun ([a, b]){    return a + b;}fun ([1, 2]); // 3</code></pre><p><strong>指定默认值的解构:</strong></p><pre><code class="javaScript">function fun ({a=0, b=0} = {}){    return [a, b];}fun ({a:1, b:2}); // [1, 2]fun ({a:1});      // [1, 0]fun ({});         // [0, 0]fun ();           // [0, 0]function fun ({a, b} = {a:0, b:0}){    return [a, b];}fun ({a:1, b:2}); // [1, 2]fun ({a:1});      // [1, undefined]fun ({});         // [undefined, undefined]fun ();           // [0, 0]</code></pre><h3 id="2-6-应用"><a href="#2-6-应用" class="headerlink" title="2.6 应用"></a>2.6 应用</h3><ul><li>交换变量的值:<pre><code class="javaScript">let a = 1,b = 2;[a, b] = [b, a]; // a =&gt;2 , b =&gt; 1 </code></pre></li><li>函数返回多个值:<pre><code class="javaScript">// 返回一个数组function f (){  return [1, 2, 3];}let [a, b, c] = f(); // a=&gt;1, b=&gt;2, c=&gt;3// 返回一个对象function f (){  return {a:1, b:2};}let {a, b} = f();    // a=&gt;1, b=&gt;2</code></pre></li><li>快速对应参数: 快速的将一组参数与变量名对应。<pre><code class="javaScript">function f([a, b, c]) {...}f([1, 2, 3]);function f({a, b, c}) {...}f({b:2, c:3, a:1});</code></pre></li><li>提取JSON数据：<pre><code class="javaScript">let json = {  name : &#39;leo&#39;,  age: 18}let {name, age} = json;console.log(name,age); // leo, 18</code></pre></li><li>提取JSON数据：<pre><code class="javaScript">let json = {  name : &#39;leo&#39;,  age: 18}let {name, age} = json;console.log(name,age); // leo, 18</code></pre></li><li>遍历Map结构:<pre><code class="javaScript">const m = new Map();m.set(&#39;a&#39;, 1);m.set(&#39;b&#39;, 2);for (let [k, v] of m){  console.log(k + &#39; : &#39; + v);}// 获取键名for (let [k] of m){...}// 获取键值for (let [,k] of m){...}</code></pre></li><li>输入模块的指定方法: 用于按需加载模块中需要用到的方法。<pre><code class="javaScript">const {log, sin, cos} = require(&#39;math&#39;);</code></pre></li></ul><h2 id="3-字符串的拓展"><a href="#3-字符串的拓展" class="headerlink" title="3 字符串的拓展"></a>3 字符串的拓展</h2><h3 id="3-1-includes-startsWith-endsWith"><a href="#3-1-includes-startsWith-endsWith" class="headerlink" title="3.1 includes(),startsWith(),endsWith()"></a>3.1 includes(),startsWith(),endsWith()</h3><p>在我们判断字符串是否包含另一个字符串时，ES6之前，我们只有typeof方法，ES6之后我们又多了三种方法：</p><ul><li><strong>includes()</strong>:返回布尔值，表示<strong>是否找到参数字符串。</strong></li><li><strong>startsWith():</strong>返回布尔值，表示参数字符串是否在原字符串的<strong>头部</strong>。</li><li><strong>endsWith():</strong>返回布尔值，表示参数字符串是否在原字符串的<strong>尾部。</strong><pre><code class="javaScript">let a = &#39;hello leo&#39;;a.startsWith(&#39;leo&#39;);   // falsea.endsWith(&#39;o&#39;);       // truea.includes(&#39;lo&#39;);      // true</code></pre>并且这三个方法都支持第二个参数，表示起始搜索的位置。<pre><code class="javaScript">let a = &#39;hello leo&#39;;a.startsWith(&#39;leo&#39;,1);   // falsea.endsWith(&#39;o&#39;,5);       // truea.includes(&#39;lo&#39;,6);      // false</code></pre>endsWith 是针对前 n 个字符，而其他两个是针对从第n个位置直到结束。</li></ul><h3 id="3-2-repeat"><a href="#3-2-repeat" class="headerlink" title="3.2 repeat()"></a>3.2 repeat()</h3><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。<br><strong>基础用法：</strong></p><pre><code class="javaScript">&#39;ab&#39;.repeat(3);        // &#39;ababab&#39;&#39;ab&#39;.repeat(0);        // &#39;&#39;</code></pre><p><strong>特殊用法:</strong></p><ul><li>参数为<code>小数</code>，则取整<pre><code class="javaScript">&#39;ab&#39;.repeat(2.3);      // &#39;abab&#39;</code></pre></li><li>参数为<code>负数</code>或<code>Infinity</code>，则报错<pre><code class="javaScript">&#39;ab&#39;.repeat(-1);       // RangeError&#39;ab&#39;.repeat(Infinity); // RangeError</code></pre></li><li>参数为<code>0到-1的小数</code>或<code>NaN</code>，则取0<pre><code class="javaScript">&#39;ab&#39;.repeat(-0.5);     // &#39;&#39;&#39;ab&#39;.repeat(NaN);      // &#39;&#39;</code></pre></li><li>参数为<code>字符串</code>，则转成<code>数字</code><pre><code class="javaScript">&#39;ab&#39;.repeat(&#39;ab&#39;);     // &#39;&#39;&#39;ab&#39;.repeat(&#39;3&#39;);      // &#39;ababab&#39;</code></pre><h3 id="3-3-padStart-padEnd"><a href="#3-3-padStart-padEnd" class="headerlink" title="3.3 padStart(),padEnd()"></a>3.3 padStart(),padEnd()</h3>用于将字符串<code>头部</code>或<code>尾部</code>补全长度，<code>padStart()</code>为<code>头部补全</code>，<code>padEnd()</code>为<code>尾部补全</code>。<br>这两个方法接收2个参数，第一个指定<code>字符串最小长度</code>，第二个<code>用于补全的字符串</code>。</li><li><em>基础用法 ：*</em><pre><code class="javaScript">&#39;x&#39;.padStart(5, &#39;ab&#39;);   // &#39;ababx&#39;&#39;x&#39;.padEnd(5, &#39;ab&#39;);     // &#39;xabab&#39;</code></pre></li><li><em>特殊用法:*</em></li><li>原字符串长度，大于或等于指定最小长度，则返回原字符串。<pre><code class="javaScript">&#39;xyzabc&#39;.padStart(5, &#39;ab&#39;); // &#39;xyzabc&#39;</code></pre></li><li>用来补全的字符串长度和原字符串长度之和，超过指定最小长度，则截去超出部分的补全字符串。<pre><code class="javaScript">&#39;ab&#39;.padStart(5,&#39;012345&#39;); // &quot;012ab&quot;</code></pre></li><li>省略第二个参数，则用<code>空格</code>补全。<pre><code class="javaScript">&#39;x&#39;.padStart(4);           // &#39;    x&#39;&#39;x&#39;.padEnd(4);             // &#39;x    &#39;</code></pre><h3 id="3-4-模版字符串"><a href="#3-4-模版字符串" class="headerlink" title="3.4 模版字符串"></a>3.4 模版字符串</h3>用于拼接字符串，ES6之前：<pre><code class="javaScript">let a = &#39;abc&#39; +   &#39;def&#39; +   &#39;ghi&#39;;</code></pre></li></ul><pre><code>ES6之后：````javaScriptlet a = `    abc    def    ghi`</code></pre><p>拼接变量: 在<strong>反引号(`)</strong>中使用${}包裹变量或方法。</p><pre><code class="javaScript">// ES6之前let a = &#39;abc&#39; + v1 + &#39;def&#39;;// ES6之后let a = `abc${v1}def`</code></pre><h2 id="4-正则的拓展"><a href="#4-正则的拓展" class="headerlink" title="4 正则的拓展"></a>4 正则的拓展</h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><p>在ES5中有两种情况。</p><ul><li>参数是<code>字符串</code>，则第二个参数为正则表达式的修饰符。<pre><code class="javaScript">let a = new RegExp(&#39;abc&#39;, &#39;i&#39;);// 等价于let a = /abx/i;</code></pre></li><li>参数是<code>正则表达式</code>，返回一个原表达式的拷贝，且不能有第二个参数，否则报错。<pre><code class="javaScript">let a = new RegExp(/abc/i);//等价于let a = /abx/i;</code></pre></li></ul><p>let a = new RegExp(/abc/, ‘i’);<br>//  Uncaught TypeError</p><pre><code>ES6中使用：第一个参数是正则对象，第二个是指定修饰符，如果第一个参数已经有修饰符，则会被第二个参数覆盖。````javaScriptnew RegExp(/abc/ig, &#39;i&#39;);</code></pre><h3 id="4-2-字符串的正则方法"><a href="#4-2-字符串的正则方法" class="headerlink" title="4.2 字符串的正则方法"></a>4.2 字符串的正则方法</h3><p>常用的四种方法：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p><h3 id="4-3-u修饰符"><a href="#4-3-u修饰符" class="headerlink" title="4.3 u修饰符"></a>4.3 u修饰符</h3><p>添加<code>u</code>修饰符，是为了处理大于<code>uFFFF</code>的Unicode字符，即正确处理四个字节的UTF-16编码。</p><pre><code class="javaScript">/^\uD83D/u.test(&#39;\uD83D\uDC2A&#39;); // false/^\uD83D/.test(&#39;\uD83D\uDC2A&#39;);  // true</code></pre><p>由于ES5之前不支持四个字节UTF-16编码，会识别为两个字符，导致第二行输出<code>true</code>，加入u修饰符后ES6就会识别为一个字符，所以输出<code>false</code>。<br><strong>注意：</strong></p><ul><li><p>(1)点字符 点字符(.)在正则中表示除了换行符以外的任意单个字符。对于码点大于0xFFFF的Unicode字符，点字符不能识别，必须加上u修饰符。</p><pre><code class="javaScript">var a = &quot;𠮷&quot;;/^.$/.test(a);  // false/^.$/u.test(a); // true</code></pre></li><li><p>(2)Unicode字符表示法 使用ES6新增的大括号表示Unicode字符时，必须在表达式添加<code>u</code>修饰符，才能识别大括号。</p><pre><code class="javaScript">/\u{61}/.test(&#39;a&#39;);      // false/\u{61}/u.test(&#39;a&#39;);     // true/\u{20BB7}/u.test(&#39;𠮷&#39;); // true</code></pre></li><li><p>(3)量词 使用u修饰符后，所有量词都会正确识别码点大于<code>0xFFFF</code>的 Unicode 字符。</p><pre><code class="javaScript">/a{2}/.test(&#39;aa&#39;);    // true/a{2}/u.test(&#39;aa&#39;);   // true/𠮷{2}/.test(&#39;𠮷𠮷&#39;);  // false/𠮷{2}/u.test(&#39;𠮷𠮷&#39;); // true</code></pre></li><li><p>(4)i修饰符 不加<code>u</code>修饰符，就无法识别非规范的<code>K</code>字符。</p><pre><code class="javaScript">/[a-z]/i.test(&#39;\u212A&#39;) // false/[a-z]/iu.test(&#39;\u212A&#39;) // true</code></pre></li><li><p><em>检查是否设置u修饰符： 使用<code>unicode</code>属性。*</em></p><pre><code class="javaScript">const a = /hello/;const b = /hello/u;a.unicode // falseb.unicode // true</code></pre><h3 id="4-4-y修饰符"><a href="#4-4-y修饰符" class="headerlink" title="4.4 y修饰符"></a>4.4 y修饰符</h3></li></ul><p><code>y</code>修饰符与g修饰符类似，也是全局匹配，后一次匹配都是从上一次匹配成功的下一个位置开始。区别在于，<code>g</code>修饰符只要剩余位置中存在匹配即可，而<code>y</code>修饰符是必须从<strong>剩余第一个开始</strong>。</p><pre><code class="javaScript">var s = &#39;aaa_aa_a&#39;;var r1 = /a+/g;var r2 = /a+/y;r1.exec(s) // [&quot;aaa&quot;]r2.exec(s) // [&quot;aaa&quot;]r1.exec(s) // [&quot;aa&quot;]  剩余 &#39;_aa_a&#39;r2.exec(s) // null</code></pre><p><code>lastIndex</code>属性: 指定匹配的开始位置：</p><pre><code class="javaScript">const a = /a/y;a.lastIndex = 2;  // 从2号位置开始匹配a.exec(&#39;wahaha&#39;); // nulla.lastIndex = 3;  // 从3号位置开始匹配let c = a.exec(&#39;wahaha&#39;);c.index;          // 3a.lastIndex;      // 4</code></pre><p><strong>返回多个匹配：</strong><br>一个<code>y</code>修饰符对<code>match</code>方法只能返回第一个匹配，与<code>g</code>修饰符搭配能返回所有匹配。</p><pre><code class="javaScript">&#39;a1a2a3&#39;.match(/a\d/y);  // [&quot;a1&quot;]&#39;a1a2a3&#39;.match(/a\d/gy); // [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;]</code></pre><p><strong>检查是否使用y修饰符：</strong><br>使用<code>sticky</code>属性检查。</p><pre><code class="javaScript">const a = /hello\d/y;a.sticky;     // true</code></pre><h3 id="4-5-flags属性"><a href="#4-5-flags属性" class="headerlink" title="4.5 flags属性"></a>4.5 flags属性</h3><p><code>flags</code>属性返回所有正则表达式的修饰符。</p><pre><code class="javaScript">/abc/ig.flags;  // &#39;gi&#39;</code></pre><h2 id="5-数值的拓展"><a href="#5-数值的拓展" class="headerlink" title="5 数值的拓展"></a>5 数值的拓展</h2><h3 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h3><p><code>Number.isFinite()</code>用于检查一个数值是否是有限的，即不是<code>Infinity</code>，若参数不是Number类型，则一律返回<code>false</code>。</p><pre><code class="javaScript">Number.isFinite(10);            // trueNumber.isFinite(0.5);           // trueNumber.isFinite(NaN);           // falseNumber.isFinite(Infinity);      // falseNumber.isFinite(-Infinity);     // falseNumber.isFinite(&#39;leo&#39;);         // falseNumber.isFinite(&#39;15&#39;);          // falseNumber.isFinite(true);          // falseNumber.isFinite(Math.random()); // true</code></pre><p><code>Number.isNaN()</code>用于检查是否是NaN，若参数不是<code>NaN</code>，则一律返回<code>false</code>。</p><pre><code class="javaScript">Number.isNaN(NaN);      // trueNumber.isNaN(10);       // falseNumber.isNaN(&#39;10&#39;);     // falseNumber.isNaN(true);     // falseNumber.isNaN(5/NaN);    // trueNumber.isNaN(&#39;true&#39; / 0);      // trueNumber.isNaN(&#39;true&#39; / &#39;true&#39;); // true</code></pre><p><strong>区别：</strong><br>与传统全局的<code>isFinite()</code>和<code>isNaN()</code>方法的区别，传统的这两个方法，是先将参数转换成数值，再判断。<br>而ES6新增的这两个方法则只对数值有效， <code>Number.isFinite()</code>对于非数值一律返回<code>false</code>,<code>Number.isNaN()</code>只有对于NaN才返回<code>true</code>，其他一律返回<code>false</code>。</p><pre><code class="javaScript">isFinite(25);          // trueisFinite(&quot;25&quot;);        // trueNumber.isFinite(25);   // trueNumber.isFinite(&quot;25&quot;); // falseisNaN(NaN);            // trueisNaN(&quot;NaN&quot;);          // trueNumber.isNaN(NaN);     // trueNumber.isNaN(&quot;NaN&quot;);   // false</code></pre><h3 id="5-2-Number-parseInt-Number-parseFloat"><a href="#5-2-Number-parseInt-Number-parseFloat" class="headerlink" title="5.2 Number.parseInt(), Number.parseFloat()"></a>5.2 Number.parseInt(), Number.parseFloat()</h3><p>这两个方法与全局方法<code>parseInt()</code>和<code>parseFloat()</code>一致，目的是逐步<strong>减少全局性的方法</strong>，让<strong>语言更模块化</strong>。</p><pre><code class="javaScript">parseInt(&#39;12.34&#39;);     // 12parseFloat(&#39;123.45#&#39;); // 123.45Number.parseInt(&#39;12.34&#39;);     // 12Number.parseFloat(&#39;123.45#&#39;); // 123.45Number.parseInt === parseInt;     // trueNumber.parseFloat === parseFloat; // true</code></pre><h3 id="5-3-Number-isInteger"><a href="#5-3-Number-isInteger" class="headerlink" title="5.3 Number.isInteger()"></a>5.3 Number.isInteger()</h3><p>用来判断一个数值是否是整数，若参数不是数值，则返回<code>false</code>。</p><pre><code class="javaScript">Number.isInteger(10);   // trueNumber.isInteger(10.0); // trueNumber.isInteger(10.1); // false</code></pre><h3 id="5-4-Math对象的拓展"><a href="#5-4-Math对象的拓展" class="headerlink" title="5.4 Math对象的拓展"></a>5.4 Math对象的拓展</h3><p>ES6新增17个数学相关的<code>静态方法</code>，只能在<code>Math对象</code>上调用。</p><ul><li>Math.trunc:<br>用来去除小数的小数部分，返回<code>整数部分。</code><br>若参数为<code>非数值</code>，则先转为<code>数值</code>。<br>若参数为<code>空值</code>或无法<code>截取整数的值</code>，则返回<code>NaN</code>。<pre><code class="javaScript">// 正常使用Math.trunc(1.1);     // 1Math.trunc(1.9);     // 1Math.trunc(-1.1);    // -1Math.trunc(-1.9);    // -1Math.trunc(-0.1234); // -0// 参数为非数值Math.trunc(&#39;11.22&#39;); // 11Math.trunc(true);    // 1Math.trunc(false);   // 0Math.trunc(null);    // 0// 参数为空和无法取整Math.trunc(NaN);       // NaNMath.trunc(&#39;leo&#39;);     // NaNMath.trunc();          // NaNMath.trunc(undefined); // NaN</code></pre></li><li><em>ES5实现：*</em><pre><code class="javaScript">Math.trunc = Math.trunc || function(x){   return x &lt; 0 ? Math.ceil(x) : Math.floor(x);}</code></pre></li><li>Math.sign():<br>判断一个数是正数、负数还是零，对于非数值，会先转成数值。<br>返回值：</li><li>参数为正数， 返回 +1</li><li>参数为负数， 返回 -1</li><li>参数为0， 返回 0</li><li>参数为-0， 返回 -0</li><li>参数为其他值， 返回 NaN<pre><code class="javaScript">Math.sign(-1);   // -1Math.sign(1);    // +1Math.sign(0);    // 0Math.sign(-0);   // -0Math.sign(NaN);  // NaNMath.sign(&#39;&#39;);   // 0Math.sign(true); // +1Math.sign(false);// 0Math.sign(null); // 0Math.sign(&#39;9&#39;);  // +1Math.sign(&#39;leo&#39;);// NaNMath.sign();     // NaNMath.sign(undefined); // NaN</code></pre>ES5实现<pre><code class="javaScript">Math.sign = Math.sign || function (x){  x = +x;  if (x === 0 || isNaN(x)){      return x;  }  return x &gt; 0 ? 1: -1;}</code></pre></li><li>Math.cbrt():<br>用来计算一个数的立方根，若参数为非数值则先转成数值。<pre><code class="javaScript">Math.cbrt(-1); // -1Math.cbrt(0);  // 0Math.cbrt(1);  // 1Math.cbrt(2);  // 1.2599210498</code></pre></li></ul><p>Math.cbrt(‘1’);   // 1<br>Math.cbrt(‘leo’); // NaN</p><pre><code>ES5实现````javaScriptMath.cbrt = Math.cbrt || function (x){    var a = Math.pow(Math.abs(x), 1/3);    return x &lt; 0 ? -y : y;}</code></pre><ul><li>Math.clz32():<br>用于返回一个数的 32 位无符号整数形式有多少个前导 0。<pre><code class="javaScript">Math.clz32(0) // 32Math.clz32(1) // 31Math.clz32(1000) // 22Math.clz32(0b01000000000000000000000000000000) // 1Math.clz32(0b00100000000000000000000000000000) // 2</code></pre></li></ul><pre><code>* Math.imul():用于返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。````javaScriptMath.imul(2, 4)   // 8Math.imul(-1, 8)  // -8Math.imul(-2, -2) // 4</code></pre><ul><li>Math.fround():<br>用来返回一个数的<code>2位单精度浮点数</code>形式。<pre><code class="javaScript">Math.fround(0)   // 0Math.fround(1)   // 1Math.fround(2 ** 24 - 1)   // 16777215</code></pre></li><li>Math.hypot():<br>用来返回所有参数的平方和的<code>平方根</code>。<pre><code class="javaScript">Math.hypot(3, 4);        // 5Math.hypot(3, 4, 5);     // 7.0710678118654755Math.hypot();            // 0Math.hypot(NaN);         // NaNMath.hypot(3, 4, &#39;foo&#39;); // NaNMath.hypot(3, 4, &#39;5&#39;);   // 7.0710678118654755Math.hypot(-3);          // 3</code></pre></li><li>Math.expm1():<br>用来返回<code>ex - 1</code>，即<code>Math.exp(x) - 1</code>。<pre><code class="javaScript">Math.expm1(-1) // -0.6321205588285577Math.expm1(0)  // 0Math.expm1(1)  // 1.718281828459045</code></pre>ES5实现<pre><code class="javaScript">Math.expm1 = Math.expm1 || function(x) {return Math.exp(x) - 1;};</code></pre></li><li>Math.log1p():<br>用来返回<code>1 + x</code>的自然对数，即<code>Math.log(1 + x)</code>。如果x小于<code>-1</code>，返回<code>NaN</code>。<pre><code class="javaScript">Math.log1p(1)  // 0.6931471805599453Math.log1p(0)  // 0Math.log1p(-1) // -InfinityMath.log1p(-2) // NaN</code></pre>ES5实现<pre><code class="javaScript">Math.log1p = Math.log1p || function(x) {return Math.log(1 + x);};</code></pre></li><li>Math.log10():<br>用来返回以 10为底的<code>x的对数</code>。如果<code>x</code>小于<code>0</code>，则返回<code>NaN</code>。<pre><code class="javaScript">Math.log10(2)      // 0.3010299956639812Math.log10(1)      // 0Math.log10(0)      // -InfinityMath.log10(-2)     // NaNMath.log10(100000) // 5</code></pre>ES5实现<pre><code class="javaScript">Math.log10 = Math.log10 || function(x) {return Math.log(x) / Math.LN10;};</code></pre></li></ul><pre><code>* Math.log2():用来返回以` 2 `为底的x的对数。如果`x`小于`0`，则返回` NaN`。````javaScriptMath.log2(3)       // 1.584962500721156Math.log2(2)       // 1Math.log2(1)       // 0Math.log2(0)       // -InfinityMath.log2(-2)      // NaNMath.log2(1024)    // 10Math.log2(1 &lt;&lt; 29) // 29</code></pre><p>ES5实现</p><pre><code class="javaScript">Math.log2 = Math.log2 || function(x) {  return Math.log(x) / Math.LN2;};</code></pre><ul><li>双曲函数方法:</li><li><em>Math.sinh(x)*</em> 返回x的双曲正弦<code>（hyperbolic sine）</code></li><li><em>Math.cosh(x)*</em>返回x的双曲余弦<code>（hyperbolic cosine）</code></li><li><em>Math.tanh(x)*</em>返回x的双曲正切<code>（hyperbolic tangent）</code></li><li><em>Math.asinh(x)*</em> 返回x的反双曲正弦<code>（inverse hyperbolic sine）</code></li><li><em>Math.acosh(x)*</em> 返回x的反双曲余弦<code>（inverse hyperbolic cosine）</code></li><li><em>Math.atanh(x)*</em> 返回x的反双曲正切<code>（inverse hyperbolic tangent）</code></li></ul><h3 id="5-5-指数运算符"><a href="#5-5-指数运算符" class="headerlink" title="5.5 指数运算符"></a>5.5 指数运算符</h3><p>新增的指数运算符(<code>**</code>):</p><pre><code>2 ** 2; // 42 ** 3; // 8 2 ** 3 ** 2; // 相当于 2 ** (3 ** 2); 返回 512</code></pre><p>指数运算符(<code>**</code>)与<code>Math.pow</code>的实现不相同，对于特别大的运算结果，两者会有细微的差异。</p><pre><code>Math.pow(99, 99)// 3.697296376497263e+19799 ** 99// 3.697296376497268e+197</code></pre><h2 id="6-函数的拓展"><a href="#6-函数的拓展" class="headerlink" title="6 函数的拓展"></a>6 函数的拓展</h2><h3 id="6-1-参数默认值"><a href="#6-1-参数默认值" class="headerlink" title="6.1 参数默认值"></a>6.1 参数默认值</h3><pre><code class="javaScript">// ES6 之前function f(a, b){    b = b || &#39;leo&#39;;    console.log(a, b);}// ES6 之后function f(a, b=&#39;leo&#39;){    console.log(a, b);}f(&#39;hi&#39;);          // hi leof(&#39;hi&#39;, &#39;jack&#39;);  // hi jackf(&#39;hi&#39;, &#39;&#39;);      // hi leo</code></pre><p><strong>注意:</strong></p><ul><li>参数变量是默认声明的，不能用<code>let</code>和<code>const</code>再次声明：<pre><code>function f (a = 1){  let a = 2; // error}</code></pre></li><li>使用参数默认值时，参数名不能相同：<pre><code class="javaScript">function f (a, a, b){ ... };     // 不报错function f (a, a, b = 1){ ... }; // 报错</code></pre></li><li>与解构赋值默认值结合使用：<pre><code class="javaScript">function f ({a, b=1}){  console.log(a,b)};f({});         // undefined 1f({a:2});      // 2 1f({a:2, b:3}); // 2 3f();           // 报错function f ({a, b = 1} = {}){  console.log(a, b)}f();  // undefined 1</code></pre></li><li>尾参数定义默认值:<br>通常在尾参数定义默认值，便于观察参数，并且非尾参数无法省略。<pre><code class="javaScript">function f (a=1,b){  return [a, b];}f();    // [1, undefined]f(2);   // [2, undefined]f(,2);  // 报错f(undefined, 2);  // [1, 2]function f (a, b=1, c){  return [a, b, c];}f();        // [undefined, 1, undefined]f(1);       // [1,1,undefined]f(1, ,2);   // 报错f(1,undefined,2); // [1,1,2]</code></pre></li></ul><p>在给参数传递默认值时，传入<code>undefined</code>会触发默认值，传入<code>null</code>不会触发。</p><pre><code class="javaScript">function f (a = 1, b = 2){    console.log(a, b);}f(undefined, null); // 1 null</code></pre><p><strong>函数的length属性:</strong></p><p><code>length</code>属性将返回，没有指定默认值的参数数量，并且rest参数不计入<code>length</code>属性。</p><pre><code class="javaScript">function f1 (a){...};function f2 (a=1){...};function f3 (a, b=2){...};function f4 (...a){...};function f5 (a,b,...c){...};f1.length; // 1f2.length; // 0f3.length; // 1f4.length; // 0f5.length; // 2</code></pre><h3 id="6-2-rest-参数"><a href="#6-2-rest-参数" class="headerlink" title="6.2 rest 参数"></a>6.2 rest 参数</h3><p><code>rest</code>参数形式为（<code>...变量名</code>），其值为一个数组，用于获取函数多余参数。</p><pre><code class="javaScript">function f (a, ...b){    console.log(a, b);}f(1,2,3,4); // 1 [2, 3, 4]</code></pre><p><strong>注意：</strong></p><ul><li><code>rest</code>参数只能放在最后一个，否则报错：<pre><code class="javascript">function f(a, ...b, c){...}; // 报错 </code></pre></li><li>函数的<code>length</code>属性不包含<code>rest</code>参数。<pre><code class="javaScript">function f1 (a){...};function f2 (a,...b){...};f1(1);   // 1f2(1,2); // 1</code></pre></li></ul><h3 id="6-3-name-属性"><a href="#6-3-name-属性" class="headerlink" title="6.3 name 属性"></a>6.3 name 属性</h3><p>用于返回该函数的函数名</p><pre><code class="javaScript">function f (){...};f.name;    // fconst f = function g(){...};f.name;    // g</code></pre><h3 id="6-4-箭头函数"><a href="#6-4-箭头函数" class="headerlink" title="6.4 箭头函数"></a>6.4 箭头函数</h3><p>使用“箭头”(<code>=&gt;</code>)定义函数。<br><strong>基础使用</strong></p><pre><code class="javaScript">// 有1个参数let f = v =&gt; v;// 等同于let f = function (v){return v};// 有多个参数let f = (v, i) =&gt; {return v + i};// 等同于let f = function (v, i){return v + i};// 没参数let f = () =&gt; 1;// 等同于let f = function (){return 1};</code></pre><p><strong>箭头函数与变量结构结合使用：</strong></p><pre><code class="javaScript">// 正常函数写法function f (p) {    return p.a + &#39;:&#39; + p.b;}// 箭头函数写法let f = ({a, b}) =&gt; a + &#39;:&#39; + b;</code></pre><p><strong>简化回调函数：</strong></p><pre><code class="javascript">// 正常函数写法[1, 2, 3].map(function (x){    return x * x;})// 箭头函数写法[1, 2, 3].map(x =&gt; x * x);</code></pre><p><strong>箭头函数与rest参数结合：</strong></p><pre><code class="javaScript">let f = (...n) =&gt; n;f(1, 2, 3); // [1, 2, 3]</code></pre><p><strong>注意点：</strong></p><ul><li>1.箭头函数内的<code>this</code>总是指向<code>定义时所在的对象</code>，而不是调用时。</li><li>2.箭头函数不能当做构造函数，即不能用<code>new</code>命令，否则报错。</li><li>3.箭头函数不存在<code>arguments</code>对象，即不能使用，可以使用<code>rest</code>参数代替。</li><li>4.箭头函数不能使用<code>yield</code>命令，即不能用作<code>Generator</code>函数。</li></ul><p><strong>不适用场景：</strong></p><ul><li>1.在定义函数方法，且该方法内部包含<code>this。</code><pre><code class="javaScript">const obj = {  a:9,  b: () =&gt; {      this.a --;  }}</code></pre>上述<code>b</code>如果是<code>普通函数</code>，函数内部的<code>this</code>指向<code>obj</code>，但是如果是箭头函数，则this会指向<code>全局</code>，不是预期结果。</li><li>2.需要动态<code>this</code>时。<pre><code class="javaScript">let b = document.getElementById(&#39;myID&#39;);b.addEventListener(&#39;click&#39;, ()=&gt;{  this.classList.toggle(&#39;on&#39;);})</code></pre>上诉按钮点击会报错，因为<code>b</code>监听的箭头函数中，<code>this</code>是全局对象，若改成<code>普通函数</code>，<code>this</code>就会指向被点击的按钮对象。</li></ul><h3 id="6-5-双冒号运算符"><a href="#6-5-双冒号运算符" class="headerlink" title="6.5 双冒号运算符"></a>6.5 双冒号运算符</h3><p>双冒号暂时是一个提案，用于解决一些不适用的场合，取代<code>call、apply、bind</code>调用。<br>双冒号运算符(<code>::</code>)的左边是一个<strong>对象</strong>，右边是一个<strong>函数</strong>。该运算符会自动将左边的对象，作为上下文环境(即<code>this</code>对象)，绑定到右边函数上。</p><pre><code class="javaScript">f::b;// 等同于b.bind(f);f::b(...arguments);// 等同于b.apply(f, arguments);</code></pre><p>若双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定到该对象上。</p><pre><code class="javaScript">let f = a::a.b;// 等同于let f = ::a.b;</code></pre><h2 id="7-数组的拓展"><a href="#7-数组的拓展" class="headerlink" title="7 数组的拓展"></a>7 数组的拓展</h2><h3 id="7-1-拓展运算符"><a href="#7-1-拓展运算符" class="headerlink" title="7.1 拓展运算符"></a>7.1 拓展运算符</h3><p>拓展运算符使用(<code>...</code>)，类似<code>rest</code>参数的逆运算，将数组转为用(<code>,</code>)分隔的参数序列。</p><pre><code class="javaScript">console.log(...[1, 2, 3]);   // 1 2 3 console.log(1, ...[2,3], 4); // 1 2 3 4</code></pre><p>拓展运算符主要使用在函数调用。</p><pre><code class="javaScript">function f (a, b){    console.log(a, b);}f(...[1, 2]); // 1 2function g (a, b, c, d, e){    console.log(a, b, c, d, e);}g(0, ...[1, 2], 3, ...[4]); // 0 1 2 3 4</code></pre><p>若拓展运算符后面是个空数组，则不产生效果</p><pre><code class="javaScript">[...[], 1]; // [1]</code></pre><p>替代apply方法</p><pre><code class="javaScript">// ES6之前function f(a, b, c){...};var a = [1, 2, 3];f.apply(null, a);// ES6之后function f(a, b, c){...};let a = [1, 2, 3];f(...a);// ES6之前Math.max.apply(null, [3,2,6]);// ES6之后Math.max(...[3,2,6]);</code></pre><p>拓展运算符的运用</p><ul><li>(1)复制数组：通常我们直接复制数组时，只是浅拷贝，如果要实现深拷贝，可以使用拓展运算符。<pre><code class="javaScript">// 通常情况 浅拷贝let a1 = [1, 2];let a2 = a1; a2[0] = 3;console.log(a1,a2); // [3,2] [3,2]// 拓展运算符 深拷贝let a1 = [1, 2];let a2 = [...a1];// let [...a2] = a1; // 作用相同a2[0] = 3;console.log(a1,a2); // [1,2] [3,2]</code></pre></li><li>(2)合并数组：注意，这里合并数组，只是浅拷贝。<pre><code class="javaScript">let a1 = [1,2];let a2 = [3];let a3 = [4,5];// ES5 let a4 = a1.concat(a2, a3);// ES6let a5 = [...a1, ...a2, ...a3];a4[0] === a1[0]; // truea5[0] === a1[0]; // true</code></pre></li><li>(3)与解构赋值结合：与解构赋值结合生成数组，但是使用拓展运算符需要放到参数最后一个，否则报错。<pre><code class="javaScript">let [a, ...b] = [1, 2, 3, 4]; // a =&gt; 1  b =&gt; [2,3,4]let [a, ...b] = [];// a =&gt; undefined b =&gt; []let [a, ...b] = [&quot;abc&quot;];// a =&gt; &quot;abc&quot;  b =&gt; []</code></pre><h3 id="7-2-Array-from"><a href="#7-2-Array-from" class="headerlink" title="7.2 Array.from()"></a>7.2 Array.from()</h3>将 <code>类数组对象</code> 和<code>可遍历的对象</code>，转换成真正的数组。<pre><code class="javaScript">// 类数组对象let a = {  &#39;0&#39;:&#39;a&#39;,  &#39;1&#39;:&#39;b&#39;,  length:2}let arr = Array.from(a);// 可遍历的对象let a = Array.from([1,2,3]);let b = Array.from({length: 3});let c = Array.from([1,2,3]).map(x =&gt; x * x);let d = Array.from([1,2,3].map(x =&gt; x * x));</code></pre><h3 id="7-3-Array-of"><a href="#7-3-Array-of" class="headerlink" title="7.3 Array.of()"></a>7.3 Array.of()</h3><pre><code class="javaScript">Array.of(1,2,3);    // [1,2,3]Array.of(1).length; // 1Array();       // []Array(2);      // [,] 1个参数时，为指定数组长度Array(1,2,3);  // [1,2,3] 多于2个参数，组成新数组</code></pre><h3 id="7-4-find-和findIndex"><a href="#7-4-find-和findIndex" class="headerlink" title="7.4 find()和findIndex()"></a>7.4 find()和findIndex()</h3><code>find()</code>方法用于找出第一个符合条件的数组成员，参数为一个回调函数，所有成员依次执行该回调函数，返回第一个返回值为<code>true</code>的成员，如果没有一个符合则返回<code>undefined</code>。<pre><code class="javaScript">[1,2,3,4,5].find( a =&gt; a &lt; 3 ); // 1</code></pre>回调函数接收三个参数，当前值、当前位置和原数组。<pre><code class="javaScript">[1,2,3,4,5].find((value, index, arr) =&gt; {  // ...});</code></pre><code>findIndex()</code>方法与<code>find()</code>类似，返回第一个符合条件的数组成员的位置，如果都不符合则返回<code>-1</code>。<pre><code class="javaScript">[1,2,3,4].findIndex((v,i,a)=&gt;{  return v&gt;2;}); // 2</code></pre><h3 id="7-5-fill"><a href="#7-5-fill" class="headerlink" title="7.5 fill()"></a>7.5 fill()</h3>用于用指定值<strong>填充</strong>一个数组，通常用来<strong>初始化空数组</strong>，并抹去数组中已有的元素。<pre><code class="javaScript">new Array(3).fill(&#39;a&#39;);   // [&#39;a&#39;,&#39;a&#39;,&#39;a&#39;][1,2,3].fill(&#39;a&#39;);        // [&#39;a&#39;,&#39;a&#39;,&#39;a&#39;]</code></pre>并且<code>fill()</code>的第二个和第三个参数指定填充的<code>起始位置和结束位置</code>。<pre><code class="javaScript">[1,2,3].fill(&#39;a&#39;,1,2);</code></pre></li></ul><h3 id="7-6-entries-keys-values"><a href="#7-6-entries-keys-values" class="headerlink" title="7.6 entries(),keys(),values()"></a>7.6 entries(),keys(),values()</h3><p>主要用于遍历数组，entries()对键值对遍历，keys()对键名遍历，values()对键值遍历。</p><pre><code class="javaScript">for (let i of [&#39;a&#39;, &#39;b&#39;].keys()){    console.log(i)}// 0// 1for (let e of [&#39;a&#39;, &#39;b&#39;].values()){    console.log(e)}// &#39;a&#39;// &#39;b&#39;for (let e of [&#39;a&#39;, &#39;b&#39;].entries()){    console.log(e)}// 0 &#39;a&#39;// 1 &#39;b&#39;</code></pre><h3 id="7-7-includes"><a href="#7-7-includes" class="headerlink" title="7.7 includes()"></a>7.7 includes()</h3><p>用于表示数组是否包含给定的值，与字符串的<code>includes</code>方法类似。</p><pre><code class="javaScript">[1,2,3].includes(2);     // true[1,2,3].includes(4);     // false[1,2,NaN].includes(NaN); // true</code></pre><p>第二个参数为<code>起始位置</code>，默认为<code>0</code>，如果<code>负数</code>，则表示<code>倒数的位置</code>，如果大于数组长度，则重置为0开始。</p><pre><code class="javaScript">[1,2,3].includes(3,3);    // false[1,2,3].includes(3,4);    // false[1,2,3].includes(3,-1);   // true[1,2,3].includes(3,-4);   // true</code></pre><h3 id="7-8-flat-flatMap"><a href="#7-8-flat-flatMap" class="headerlink" title="7.8 flat(),flatMap()"></a>7.8 flat(),flatMap()</h3><p><code>flat()</code>用于将数组一维化，返回一个新数组，不影响原数组。<br>默认一次只一维化一层数组，若需多层，则传入一个整数参数指定层数。<br>若要一维化所有层的数组，则传入<code>Infinity</code>作为参数。</p><pre><code class="javaScript">[1, 2, [2,3]].flat();        // [1,2,2,3][1,2,[3,[4,[5,6]]]].flat(3); // [1,2,3,4,5,6][1,2,[3,[4,[5,6]]]].flat(&#39;Infinity&#39;); // [1,2,3,4,5,6]</code></pre><p><code>flatMap()</code>是将原数组每个对象先执行一个函数，在对返回值组成的数组执行<code>flat()</code>方法，返回一个新数组，不改变原数组。<br><code>flatMap()</code>只能展开一层。</p><pre><code class="javaScript">[2, 3, 4].flatMap((x) =&gt; [x, x * 2]); // [2, 4, 3, 6, 4, 8] </code></pre><h2 id="8-对象的拓展"><a href="#8-对象的拓展" class="headerlink" title="8 对象的拓展"></a>8 对象的拓展</h2><h3 id="8-1-属性的简洁表示"><a href="#8-1-属性的简洁表示" class="headerlink" title="8.1 属性的简洁表示"></a>8.1 属性的简洁表示</h3><pre><code class="javaScript">let a = &#39;a1&#39;;let b = { a };  // b =&gt; { a : &#39;a1&#39; }// 等同于let b = { a : a };function f(a, b){    return {a, b}; }// 等同于function f (a, b){    return {a:a ,b:b};}let a = {    fun () {        return &#39;leo&#39;;    }}// 等同于let a = {    fun : function(){        return &#39;leo&#39;;    }}</code></pre><h3 id="8-2-属性名表达式"><a href="#8-2-属性名表达式" class="headerlink" title="8.2 属性名表达式"></a>8.2 属性名表达式</h3><p><code>JavaScript</code>提供2种方法定义对象的属性。</p><pre><code class="javaScript">// 方法1 标识符作为属性名a.f = true;// 方法2 字符串作为属性名a[&#39;f&#39; + &#39;un&#39;] = true;</code></pre><p>延伸出来的还有：</p><pre><code class="javaScript">let a = &#39;hi leo&#39;;let b = {    [a]: true,    [&#39;a&#39;+&#39;bc&#39;]: 123,    [&#39;my&#39; + &#39;fun&#39;] (){        return &#39;hi&#39;;    }};// b.a =&gt; undefined ; b.abc =&gt; 123 ; b.myfun() =&gt; &#39;hi&#39;// b[a] =&gt; true ; b[&#39;abc&#39;] =&gt; 123 ; b[&#39;myfun&#39;] =&gt; ƒ [&#39;my&#39; + &#39;fun&#39;] (){ return &#39;hi&#39;; }</code></pre><p><strong>注意：</strong><br>属性名表达式不能与简洁表示法同时使用，否则报错。</p><pre><code class="javaScript">// 报错let a1 = &#39;aa&#39;;let a2 = &#39;bb&#39;;let b1 = {[a1]};// 正确let a1 = &#39;aa&#39;;let b1 = { [a1] : &#39;bb&#39;};</code></pre><h3 id="8-3-Object-is"><a href="#8-3-Object-is" class="headerlink" title="8.3 Object.is()"></a>8.3 Object.is()</h3><p><code>Object.is()</code> 用于比较两个值是否严格相等，在ES5时候只要使用<code>相等运算符</code>(<code>==</code>)和严格相等运算符(<code>===</code>)就可以做比较，但是它们都有缺点，前者会<code>自动转换数据类型</code>，后者的NaN不等于自身，以及+0等于-0。</p><pre><code class="javaScript">Object.is(&#39;a&#39;,&#39;a&#39;);   // trueObject.is({}, {});    // false// ES5+0 === -0 ;           // trueNaN === NaN;          // false// ES6Object.is(+0,-0);     // falseObject.is(NaN,NaN);   // true</code></pre><h3 id="8-4-Object-assign"><a href="#8-4-Object-assign" class="headerlink" title="8.4 Object.assign()"></a>8.4 Object.assign()</h3><p><code>Object.assign()</code>方法用于对象的合并，将原对象的所有可枚举属性复制到目标对象。<br>基础用法：<br>第一个参数是目标对象，后面参数都是源对象。</p><pre><code class="javaScript">let a = {a:1};let b = {b:2};Object.assign(a,b);  // a=&gt; {a:1,b:2}</code></pre><p><strong>注意：</strong></p><ul><li>若目标对象与源对象有同名属性，则后面属性会覆盖前面属性。<pre><code class="javaScript">let a = {a:1, b:2};let b = {b:3, c:4};Object.assign(a, b); // a =&gt; {a:1, b:3, c:4}</code></pre></li><li>若只有一个参数，则返回该参数。<pre><code class="javaScript">let a = {a:1};Object.assign(a) === a;  // true</code></pre></li><li>若参数<strong>不是对象</strong>，则先转成对象后返回。<pre><code class="javaScript">typeof Object.assign(2); // &#39;object&#39;</code></pre></li><li>由于<code>undefined</code>或<code>NaN</code>无法转成对象，所以做为参数会报错。<pre><code class="javaScript">Object.assign(undefined) // 报错Object.assign(NaN);      // 报错</code></pre></li><li><code>Object.assign()</code>实现的是浅拷贝。<br><code>Object.assign()</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。<pre><code class="javaScript">let a = {a: {b:1}};let b = Object.assign({},a);a.a.b = 2;console.log(b.a.b);  // 2</code></pre></li><li>将数组当做对象处理，键名为数组下标，键值为数组下标对应的值。<pre><code class="javaScript">Object.assign([1, 2, 3], [4, 5]); // [4, 5, 3]</code></pre></li></ul><h2 id="9-Symbol"><a href="#9-Symbol" class="headerlink" title="9 Symbol"></a>9 Symbol</h2><h3 id="9-1-介绍"><a href="#9-1-介绍" class="headerlink" title="9.1 介绍"></a>9.1 介绍</h3><p>ES6引入<code>Symbol</code>作为一种新的<code>原始数据类型</code>，表示独一无二的值，主要是为了<code>防止属性名冲突。</code><br>ES6之后，JavaScript一共有其中数据类型：<code>Symbol</code>、<code>undefined</code>、<code>null</code>、<code>Boolean</code>、<code>String</code>、<code>Number</code>、<code>Object</code>。<br>简单实用：</p><pre><code class="javaScript">let a = Symbol();typeof a; // &quot;symbol&quot;</code></pre><p><strong>注意：</strong></p><ul><li>Symbol函数不能用<code>new</code>，会报错。由于Symbol是一个原始类型，不是对象，所以不能添加属性，它是类似于字符串的数据类型。</li><li><code>Symbol</code>都是不相等的，即使参数相同。<pre><code class="javaScript">// 没有参数let a1 = Symbol();let a2 = Symbol();a1 === a2; // false // 有参数let a1 = Symbol(&#39;abc&#39;);let a2 = Symbol(&#39;abc&#39;);a1 === a2; // false </code></pre></li><li>Symbol不能与其他类型的值计算，会报错。<pre><code class="javaScript">let a = Symbol(&#39;hello&#39;);a + &quot; world!&quot;;  // 报错`${a} world!`;  // 报错</code></pre>Symbol可以转换为布尔值，但不能转为数值：<pre><code class="javaScript">let a1 = Symbol();Boolean(a1);!a1;        // falseNumber(a1); // TypeErrora1 + 1 ;    // TypeError</code></pre></li></ul><h3 id="9-2-Symbol作为属性名"><a href="#9-2-Symbol作为属性名" class="headerlink" title="9.2 Symbol作为属性名"></a>9.2 Symbol作为属性名</h3><p>好处：防止同名属性，还有防止键被改写或覆盖。</p><pre><code class="javaScript">let a1 = Symbol();// 写法1let b = {};b[a1] = &#39;hello&#39;;// 写法2let b = {    [a1] : &#39;hello&#39;} // 写法3let b = {};Object.defineProperty(b, a1, {value : &#39;hello&#39; });// 3种写法 结果相同b[a1]; // &#39;hello&#39;</code></pre><p><code>需要注意：</code>Symbol作为对象属性名时，不能用点运算符，并且必须放在方括号内。</p><pre><code class="javaScript">let a = Symbol();let b = {};// 不能用点运算b.a = &#39;hello&#39;;b[a] ; // undefinedb[&#39;a&#39;] ; // &#39;hello&#39;// 必须放在方括号内let c = {    [a] : function (text){        console.log(text);    }}c[a](&#39;leo&#39;); // &#39;leo&#39;// 上面等价于 更简洁let c = {    [a](text){        console.log(text);    }}</code></pre><p>常常还用于创建一组常量，保证所有值不相等：</p><pre><code class="javaScript">let a = {};a.a1 = {    AAA: Symbol(&#39;aaa&#39;),    BBB: Symbol(&#39;bbb&#39;),    CCC: Symbol(&#39;ccc&#39;)}</code></pre><h3 id="9-3-应用：消除魔术字符串"><a href="#9-3-应用：消除魔术字符串" class="headerlink" title="9.3 应用：消除魔术字符串"></a>9.3 应用：消除魔术字符串</h3><p>魔术字符串：指代码中多次出现，强耦合的字符串或数值，应该避免，而使用含义清晰的变量代替。</p><pre><code class="javaScript">function f(a){    if(a == &#39;leo&#39;) {        console.log(&#39;hello&#39;);    }}f(&#39;leo&#39;);   // &#39;leo&#39; 为魔术字符串</code></pre><p>常使用变量，消除魔术字符串：</p><pre><code class="javaScript">let obj = {    name: &#39;leo&#39;};function f (a){    if(a == obj.name){        console.log(&#39;hello&#39;);    }}f(obj.name); // &#39;leo&#39;</code></pre><p>使用Symbol消除强耦合，使得不需关系具体的值:</p><pre><code class="javaScript">let obj = {    name: Symbol()};function f (a){    if(a == obj.name){        console.log(&#39;hello&#39;);    }}f(obj.name);</code></pre><h3 id="9-4-属性名遍历"><a href="#9-4-属性名遍历" class="headerlink" title="9.4 属性名遍历"></a>9.4 属性名遍历</h3><p><code>Symbol</code>作为属性名遍历，不出现在<code>for...in</code>、<code>for...of</code>循环，也不被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify(</code>)返回。</p><pre><code class="javaScript">let a = Symbol(&#39;aa&#39;),b= Symbol(&#39;bb&#39;);let obj = {    [a]:&#39;11&#39;, [b]:&#39;22&#39;}for(let k of Object.values(obj)){console.log(k)}// 无输出let obj = {};let aa = Symbol(&#39;leo&#39;);Object.defineProperty(obj, aa, {value: &#39;hi&#39;});for(let k in obj){    console.log(k); // 无输出}Object.getOwnPropertyNames(obj);   // []Object.getOwnPropertySymbols(obj); // [Symbol(leo)]</code></pre><p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，包含当前对象所有用做属性名的Symbol值。</p><pre><code class="javaScript">let a = {};let a1 = Symbol(&#39;a&#39;);let a2 = Symbol(&#39;b&#39;);a[a1] = &#39;hi&#39;;a[a2] = &#39;oi&#39;;let obj = Object.getOwnPropertySymbols(a);obj; //  [Symbol(a), Symbol(b)]</code></pre><p>另外可以使用<code>Reflect.ownKeys</code>方法可以返回所有类型的键名，包括常规键名和<code>Symbol</code>键名。</p><pre><code class="javaScript">let a = {    [Symbol(&#39;leo&#39;)]: 1,    aa : 2,     bb : 3,}Reflect.ownKeys(a); // [&#39;aa&#39;, &#39;bb&#39;,Symbol(&#39;leo&#39;)]</code></pre><p>由于Symbol值作为名称的属性不被常规方法遍历获取，因此常用于定义对象的一些非私有，且内部使用的方法。</p><h3 id="9-5-Symbol-for-、Symbol-keyFor"><a href="#9-5-Symbol-for-、Symbol-keyFor" class="headerlink" title="9.5 Symbol.for()、Symbol.keyFor()"></a>9.5 Symbol.for()、Symbol.keyFor()</h3><ul><li>Symbol.for()<br><code>用于重复使用一个Symbol值</code>，接收一个<code>字符串</code>作为参数，若存在用此参数作为名称的Symbol值，返回这个Symbol，否则新建并返回以这个参数为名称的Symbol值<pre><code class="javaScript">let a = Symbol.for(&#39;aaa&#39;);let b = Symbol.for(&#39;aaa&#39;);a === b;  // true</code></pre><code>Symbol()</code>和<code>Symbol.for()</code>区别：<pre><code class="javaScript">Symbol.for(&#39;aa&#39;) === Symbol.for(&#39;aa&#39;); // trueSymbol(&#39;aa&#39;) === Symbol(&#39;aa&#39;);         // false</code></pre></li><li><code>Symbol.keyFor()</code></li><li><em>用于返回一个已使用的Symbol类型的key*</em>:<pre><code class="javaScript">let a = Symbol.for(&#39;aa&#39;);Symbol.keyFor(a);   //  &#39;aa&#39;let b = Symbol(&#39;aa&#39;);Symbol.keyFor(b);   //  undefined</code></pre><h3 id="9-6-内置的Symbol值"><a href="#9-6-内置的Symbol值" class="headerlink" title="9.6 内置的Symbol值"></a>9.6 内置的Symbol值</h3>ES6提供11个内置的Symbol值，指向语言内部使用的方法：</li><li>1.Symbol.hasInstance<br>当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，<code>foo ``instanceof</code> <code>Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)。</code><pre><code class="javaScript">class P {  [Symbol.hasInstance](a){      return a instanceof Array;  }}[1, 2, 3] instanceof new P(); // true</code></pre>P是一个类，<code>new P()</code>会返回一个实例，该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</li><li>2.Symbol.isConcatSpreadable<br>值为布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。<pre><code class="javaScript">let a = [&#39;aa&#39;,&#39;bb&#39;];[&#39;cc&#39;,&#39;dd&#39;].concat(a, &#39;ee&#39;); // [&#39;cc&#39;, &#39;dd&#39;, &#39;aa&#39;, &#39;bb&#39;, &#39;ee&#39;]a[Symbol.isConcatSpreadable]; // undefinedlet b = [&#39;aa&#39;,&#39;bb&#39;]; b[Symbol.isConcatSpreadable] = false; [&#39;cc&#39;,&#39;dd&#39;].concat(b, &#39;ee&#39;); // [&#39;cc&#39;, &#39;dd&#39;,[ &#39;aa&#39;, &#39;bb&#39;], &#39;ee&#39;]</code></pre></li><li>3.Symbol.species<br>指向一个构造函数，在创建衍生对象时会使用，使用时需要用<code>get</code>取值器。<pre><code class="javaScript">class P extends Array {  static get [Symbol.species](){      return this;  }}</code></pre>解决下面问题：<pre><code class="javaScript">// 问题：  b应该是 Array 的实例，实际上是 P 的实例class P extends Array{}let a = new P(1,2,3);let b = a.map(x =&gt; x);b instanceof Array; // trueb instanceof P; // true// 解决：  通过使用 Symbol.speciesclass P extends Array {static get [Symbol.species]() { return Array; }}let a = new P();let b = a.map(x =&gt; x);b instanceof P;     // falseb instanceof Array; // true</code></pre></li><li>4.Symbol.match<br>当执行<code>str.match(myObject)</code>，传入的属性存在时会调用，并返回该方法的返回值。<pre><code class="javaScript">class P {  [Symbol.match](string){      return &#39;hello world&#39;.indexOf(string);  }}&#39;h&#39;.match(new P());   // 0</code></pre></li><li><strong>5.Symbol.replace</strong> 当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。<pre><code class="javaScript">let a = {};a[Symbol.replace] = (...s) =&gt; console.log(s);&#39;Hello&#39;.replace(a , &#39;World&#39;) // [&quot;Hello&quot;, &quot;World&quot;]</code></pre></li><li><strong>6.Symbol.hasInstance</strong><br>当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。<pre><code class="javaScript">class P {  constructor(val) {      this.val = val;  }  [Symbol.search](s){      return s.indexOf(this.val);  }}&#39;hileo&#39;.search(new P(&#39;leo&#39;)); // 2</code></pre></li><li>7.Symbol.split<br>当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。<pre><code class="javaScript">// 重新定义了字符串对象的split方法的行为class P {  constructor(val) {      this.val = val;  }  [Symbol.split](s) {      let i = s.indexOf(this.val);      if(i == -1) return s;      return [          s.substr(0, i),          s.substr(i + this.val.length)      ]  }}&#39;helloworld&#39;.split(new P(&#39;hello&#39;)); // [&quot;hello&quot;, &quot;&quot;]&#39;helloworld&#39;.split(new P(&#39;world&#39;)); // [&quot;&quot;, &quot;world&quot;] &#39;helloworld&#39;.split(new P(&#39;leo&#39;));   // &quot;helloworld&quot;</code></pre></li><li>8.Symbol.iterator<br>对象进行<code>for...of</code>循环时，会调用<code>Symbol.iterator</code>方法，返回该对象的默认遍历器。<pre><code class="javaScript">class P {  *[Symbol.interator]() {      let i = 0;      while(this[i] !== undefined ) {          yield this[i];          ++i;      }  }}let a = new P();a[0] = 1;a[1] = 2;for (let k of a){  console.log(k);}</code></pre></li><li>9.Symbol.toPrimitive<br>该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。调用时，需要接收一个字符串参数，表示当前运算模式，运算模式有：<blockquote><p>Number : 此时需要转换成数值<br>String : 此时需要转换成字符串<br>Default : 此时可以转换成数值或字符串</p></blockquote><pre><code class="javaScript">let obj = {[Symbol.toPrimitive](hint) {  switch (hint) {    case &#39;number&#39;:      return 123;    case &#39;string&#39;:      return &#39;str&#39;;    case &#39;default&#39;:      return &#39;default&#39;;    default:      throw new Error();   } }};2 * obj // 2463 + obj // &#39;3default&#39;obj == &#39;default&#39; // trueString(obj) // &#39;str&#39;</code></pre></li><li>10.Symbol.toStringTag<br>在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串。<pre><code class="javaScript">// 例一({[Symbol.toStringTag]: &#39;Foo&#39;}.toString())// &quot;[object Foo]&quot;// 例二class Collection {get [Symbol.toStringTag]() {  return &#39;xxx&#39;;}}let x = new Collection();Object.prototype.toString.call(x) // &quot;[object xxx]&quot;</code></pre></li><li>11.Symbol.unscopables<br>该对象指定了使用with关键字时，哪些属性会被with环境排除。<pre><code class="javaScript">// 没有 unscopables 时class MyClass {foo() { return 1; }}var foo = function () { return 2; };with (MyClass.prototype) {foo(); // 1}// 有 unscopables 时class MyClass {foo() { return 1; }get [Symbol.unscopables]() {  return { foo: true };}}var foo = function () { return 2; };with (MyClass.prototype) {foo(); // 2}</code></pre>上面代码通过指定<code>Symbol.unscopables</code>属性，使得<code>with</code>语法块不会在当前作用域寻找<code>foo</code>属性，即<code>foo</code>将指向外层作用域的变量。</li></ul><h2 id="10-Set和Map数据结构"><a href="#10-Set和Map数据结构" class="headerlink" title="10 Set和Map数据结构"></a>10 Set和Map数据结构</h2><h3 id="10-1-Set"><a href="#10-1-Set" class="headerlink" title="10.1 Set"></a>10.1 Set</h3><p>介绍:<br><code>Set</code>数据结构类似数组，但所有成员的值唯一。<br><code>Set</code>本身为一个构造函数，用来生成<code>Set</code>数据结构，使用<code>add</code>方法来添加新成员。</p><pre><code class="javaScript">let a = new Set();[1,2,2,1,3,4,5,4,5].forEach(x=&gt;a.add(x));for(let k of a){    console.log(k)};// 1 2 3 4 5</code></pre><p><strong>基础使用：</strong></p><pre><code class="javaScript">let a = new Set([1,2,3,3,4]);[...a]; // [1,2,3,4]a.size; // 4// 数组去重[...new Set([1,2,3,4,4,4])];// [1,2,3,4]</code></pre><p><strong>注意：</strong></p><ul><li><p>向Set中添加值的时候，不会类型转换，即5和’5’是不同的。</p><pre><code class="javaScript">[...new Set([5,&#39;5&#39;])]; // [5, &quot;5&quot;]</code></pre></li><li><p><strong>属性和方法：</strong></p></li><li><p>属性：</p><blockquote><p>Set.prototype.constructor：构造函数，默认就是Set函数。<br>Set.prototype.size：返回Set实例的成员总数。</p></blockquote></li><li><p>操作方法：</p><blockquote><p>add(value)：添加某个值，返回 Set 结构本身。<br>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。<br>has(value)：返回一个布尔值，表示该值是否为Set的成员。<br>clear()：清除所有成员，没有返回值。</p></blockquote><pre><code class="javaScript">let a = new Set();a.add(1).add(2); // a =&gt; Set(2) {1, 2}a.has(2);        // truea.has(3);        // falsea.delete(2);     // true  a =&gt; Set(1) {1}a.clear();       // a =&gt; Set(0) {}</code></pre><h3 id="10-2-Set的应用"><a href="#10-2-Set的应用" class="headerlink" title="10.2 Set的应用"></a>10.2 Set的应用</h3></li></ul><p><strong>数组去重：</strong></p><pre><code class="javaScript">// 方法1[...new Set([1,2,3,4,4,4])]; // [1,2,3,4]// 方法2Array.from(new Set([1,2,3,4,4,4]));   // [1,2,3,4]</code></pre><p><strong>遍历和过滤：</strong></p><pre><code class="javaScript">let a = new Set([1,2,3,4]);// map 遍历操作let b = new Set([...a].map(x =&gt;x*2));// b =&gt; Set(4) {2,4,6,8}// filter 过滤操作let c = new Set([...a].filter(x =&gt;(x%2) == 0)); // b =&gt; Set(2) {2,4}</code></pre><p><strong>获取并集、交集和差集：</strong></p><pre><code class="javaScript">let a = new Set([1,2,3]);let b = new Set([4,3,2]);// 并集let c1 = new Set([...a, ...b]);  // Set {1,2,3,4}// 交集let c2 = new Set([...a].filter(x =&gt; b.has(x))); // set {2,3}// 差集let c3 = new Set([...a].filter(x =&gt; !b.has(x))); // set {1}</code></pre><ul><li>遍历方法<blockquote><p>keys()：返回键名的遍历器。<br>values()：返回键值的遍历器。<br>entries()：返回键值对的遍历器。<br>forEach()：使用回调函数遍历每个成员<br><code>Set</code>遍历顺序是插入顺序，当保存多个回调函数，只需按照顺序调用。但由于Set结构<code>没有键名只有键值</code>，所以<code>keys()</code>和<code>values()</code>是返回结果相同。</p></blockquote><pre><code class="javaScript">let a = new Set([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]);for(let i of a.keys()){console.log(i)};   // &#39;a&#39; &#39;b&#39; &#39;c&#39;for(let i of a.values()){console.log(i)}; // &#39;a&#39; &#39;b&#39; &#39;c&#39;for(let i of a.entries()){console.log(i)}; // [&#39;a&#39;,&#39;a&#39;] [&#39;b&#39;,&#39;b&#39;] [&#39;c&#39;,&#39;c&#39;]</code></pre>并且 还可以使用<code>for...of</code>直接遍历<code>Set</code>。<pre><code class="javaScript">let a = new Set([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]);for(let k of a){console.log(k)};   // &#39;a&#39; &#39;b&#39; &#39;c&#39;</code></pre><code>forEach</code>与数组相同，对每个成员执行操作，且无返回值。<pre><code class="javaScript">let a = new Set([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]);a.forEach((v,k) =&gt; console.log(k + &#39; : &#39; + v));</code></pre><h3 id="10-3-Map"><a href="#10-3-Map" class="headerlink" title="10.3 Map"></a>10.3 Map</h3>由于传统的JavaScript对象只能用字符串当做键，给开发带来很大限制，ES6增加Map数据结构，使得<strong>各种类型的值</strong>(包括对象)都可以作为键。<br>Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。 <strong>基础使用：</strong><pre><code class="javaScript">let a = new Map();let b = {name: &#39;leo&#39; };a.set(b,&#39;my name&#39;); // 添加值a.get(b);           // 获取值a.size;      // 获取总数a.has(b);    // 查询是否存在a.delete(b); // 删除一个值a.clear();   // 清空所有成员 无返回</code></pre></li><li><em>注意：*</em></li><li>传入数组作为参数，指定键值对的数组。<pre><code class="javaScript">let a = new Map([  [&#39;name&#39;,&#39;leo&#39;],  [&#39;age&#39;,18]])</code></pre></li><li>如果对同一个键<strong>多次赋值</strong>，后面的值将<strong>覆盖前面的值</strong>。<pre><code class="javaScript">let a = new Map();a.set(1,&#39;aaa&#39;).set(1,&#39;bbb&#39;);a.get(1); // &#39;bbb&#39;</code></pre></li><li>如果读取一个未知的键，则返回undefined。<pre><code class="javaScript">new Map().get(&#39;abcdef&#39;); // undefined</code></pre></li><li><strong>同样的值</strong>的两个实例，在 Map 结构中被视为两个键。<pre><code class="javaScript">let a = new Map();let a1 = [&#39;aaa&#39;];let a2 = [&#39;aaa&#39;];a.set(a1,111).set(a2,222);a.get(a1); // 111a.get(a2); // 222</code></pre></li><li><em>遍历方法：*</em> Map 的遍历顺序就是插入顺序。<blockquote><p><code>keys()：</code>返回键名的遍历器。<br><code>values()：</code>返回键值的遍历器。<br><code>entries()：</code>返回所有成员的遍历器。<br><code>forEach()：</code>遍历 Map 的所有成员。</p></blockquote><pre><code class="javaScript">let a = new Map([   [&#39;name&#39;,&#39;leo&#39;],   [&#39;age&#39;,18]])for (let i of a.keys()){...};for (let i of a.values()){...};for (let i of a.entries()){...};a.forEach((v,k,m)=&gt;{   console.log(`key:${k},value:${v},map:${m}`)})</code></pre></li><li><em>将Map结构转成数组结构：*</em><pre><code class="javaScript">let a = new Map([   [&#39;name&#39;,&#39;leo&#39;],   [&#39;age&#39;,18]])let a1 = [...a.keys()];   // a1 =&gt; [&quot;name&quot;, &quot;age&quot;]let a2 = [...a.values()]; // a2 =&gt;  [&quot;leo&quot;, 18]let a3 = [...a.entries()];// a3 =&gt; [[&#39;name&#39;,&#39;leo&#39;], [&#39;age&#39;,18]]</code></pre><h3 id="10-4-Map与其他数据结构互相转换"><a href="#10-4-Map与其他数据结构互相转换" class="headerlink" title="10.4 Map与其他数据结构互相转换"></a>10.4 Map与其他数据结构互相转换</h3></li><li>Map 转 数组<pre><code class="javaScript">let a = new Map().set(true,1).set({f:2},[&#39;abc&#39;]);[...a]; // [[true:1], [ {f:2},[&#39;abc&#39;] ]]</code></pre></li><li>数组 转 Map<pre><code class="javaScript">let a = [ [&#39;name&#39;,&#39;leo&#39;], [1, &#39;hi&#39; ]]let b = new Map(a);</code></pre></li><li>Map 转 对象 如果所有 Map 的键都是字符串，它可以无损地转为对象。<br>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</li></ul><pre><code class="javaScript">function fun(s) {  let obj = Object.create(null);  for (let [k,v] of s) {    obj[k] = v;  }  return obj;}const a = new Map().set(&#39;yes&#39;, true).set(&#39;no&#39;, false);fun(a)// { yes: true, no: false }</code></pre><ul><li>对象 转 Map<pre><code class="javaScript">function fun(obj) {let a = new Map();for (let k of Object.keys(obj)) {  a.set(k, obj[k]);}return a;}fun({yes: true, no: false})// Map {&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false}</code></pre></li><li>Map 转 JSON</li><li><em>(1)Map键名都是字符串，转为对象JSON：*</em><pre><code class="javaScript">function fun (s) {   let obj = Object.create(null);   for (let [k,v] of s) {       obj[k] = v;   }   return JSON.stringify(obj)}let a = new Map().set(&#39;yes&#39;, true).set(&#39;no&#39;, false);fun(a);// &#39;{&quot;yes&quot;:true,&quot;no&quot;:false}&#39;</code></pre></li><li><em>(2)Map键名有非字符串，转为数组JSON：*</em><pre><code class="javaScript">function fun (map) { return JSON.stringify([...map]);}let a = new Map().set(true, 7).set({foo: 3}, [&#39;abc&#39;]);fun(a)// &#39;[[true,7],[{&quot;foo&quot;:3},[&quot;abc&quot;]]]&#39;</code></pre></li><li>JSON 转 Map</li><li><em>(1)所有键名都是字符串：*</em><pre><code class="javaScript">function fun (s) { let strMap = new Map(); for (let k of Object.keys(s)) {   strMap.set(k, s[k]); } return strMap; return JSON.parse(strMap);}fun(&#39;{&quot;yes&quot;: true, &quot;no&quot;: false}&#39;)// Map {&#39;yes&#39; =&gt; true, &#39;no&#39; =&gt; false}</code></pre></li><li><em>(2)整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组:*</em><pre><code class="javaScript">function fun2(s) { return new Map(JSON.parse(s));}fun2(&#39;[[true,7],[{&quot;foo&quot;:3},[&quot;abc&quot;]]]&#39;)// Map {true =&gt; 7, Object {foo: 3} =&gt; [&#39;abc&#39;]}</code></pre></li></ul><h2 id="11-Proxy"><a href="#11-Proxy" class="headerlink" title="11 Proxy"></a>11 Proxy</h2><p><code>proxy</code> 用于修改某些操作的<strong>默认行为</strong>，可以理解为一种拦截外界对目标对象访问的一种机制，从而对外界的访问进行过滤和修改，即代理某些操作，也称“<strong>代理器</strong>”。</p><p>#11.1 基础使用<br><code>proxy</code>实例化需要传入两个参数，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p><pre><code class="javaScript">let p = new Proxy(target, handler);let a = new Proxy({}, {    get: function (target, handler){        return &#39;leo&#39;;    }})a.name; // leoa.age;  // leoa.abcd; // leo</code></pre><p>上述<code>a</code>实例中，在第二个参数中定义了<code>get</code>方法，来拦截外界访问，并且get方法接收两个参数，分别是<strong>目标对象</strong>和<strong>所要访问的属性</strong>，所以不管外部访问对象中任何属性都会执行<code>get</code>方法返回<code>leo</code>。<br><strong>注意：</strong></p><ul><li><p>只能使用Proxy实例的对象才能使用这些操作。</p></li><li><p>如果handler没有设置拦截，则直接返回原对象。</p><pre><code class="javaScript">let target = {};let handler = {};let p = new Proxy(target, handler);p.a = &#39;leo&#39;; target.a;  // &#39;leo&#39;</code></pre></li><li><p><em>同个拦截器函数，设置多个拦截操作：*</em></p><pre><code class="javaScript">let p = new Proxy(function(a, b){   return a + b;},{   get:function(){       return &#39;get方法&#39;;   },   apply:function(){       return &#39;apply方法&#39;;   }})</code></pre><p><code>Proxy</code>支持的13种拦截操作：<br>13种拦截操作的详细介绍：<a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">打开阮一峰老师的链接</a>。</p></li><li><p><code>get(target, propKey, receiver)</code>： 拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</p></li><li><p><code>set(target, propKey, value, receiver)</code>： 拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</p></li><li><p><code>has(target, propKey)</code>： 拦截propKey in proxy的操作，返回一个布尔值。</p></li><li><p><code>deleteProperty(target, propKey)</code>： 拦截delete proxy[propKey]的操作，返回一个布尔值。</p></li><li><p><code>ownKeys(target)</code>： 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</p></li><li><p><code>getOwnPropertyDescriptor(target, propKey)</code>： 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</p></li><li><p><code>defineProperty(target, propKey, propDesc)</code>： 拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</p></li><li><p><code>preventExtensions(target)</code>： 拦截Object.preventExtensions(proxy)，返回一个布尔值。</p></li><li><p><code>getPrototypeOf(target)：</code> 拦截Object.getPrototypeOf(proxy)，返回一个对象。</p></li><li><p><code>isExtensible(target)</code>： 拦截Object.isExtensible(proxy)，返回一个布尔值。</p></li><li><p><code>setPrototypeOf(target, proto)</code>： 拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</p></li><li><p><code>apply(target, object, args)</code>： 拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</p></li><li><p><code>construct(target, args)</code>： 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</p></li></ul><h3 id="11-2-取消Proxy实例"><a href="#11-2-取消Proxy实例" class="headerlink" title="11.2 取消Proxy实例"></a>11.2 取消Proxy实例</h3><p>使用<code>Proxy.revocale</code>方法取消<code>Proxy</code>实例。</p><pre><code class="javaScript">let a = {};let b = {};let {proxy, revoke} = Proxy.revocale(a, b);proxy.name = &#39;leo&#39;;  // &#39;leo&#39;revoeke();proxy.name;  // TypeError: Revoked</code></pre><h3 id="11-3-实现-Web服务的客户端"><a href="#11-3-实现-Web服务的客户端" class="headerlink" title="11.3 实现 Web服务的客户端"></a>11.3 实现 Web服务的客户端</h3><pre><code class="javaScript">const service = createWebService(&#39;http://le.com/data&#39;);service.employees().than(json =&gt;{    const employees = JSON.parse(json);})function createWebService(url){    return new Proxy({}, {        get(target, propKey, receiver{            return () =&gt; httpGet(url+&#39;/&#39;+propKey);        })    })</code></pre><h2 id="12-Promise对象"><a href="#12-Promise对象" class="headerlink" title="12 Promise对象"></a>12 Promise对象</h2><h3 id="12-1-概念"><a href="#12-1-概念" class="headerlink" title="12.1 概念"></a>12.1 概念</h3><p>主要用途：<strong>解决异步编程带来的回调地狱问题。</strong><br>把<code>Promise</code>简单理解一个容器，存放着某个未来才会结束的事件（通常是一个异步操作）的结果。通过<code>Promise</code>对象来获取异步操作消息，处理各种异步操作。<br><code>Promise</code><strong>对象2特点：</strong></p><ul><li>对象的状态不受外界影响。<blockquote><p><code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending（进行中）</code>、<code>fulfilled（已成功）</code>和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p></blockquote></li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<blockquote><p><code>Promise</code>对象的状态改变，只有两种可能：从pending变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 <code>resolved</code>（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。<br>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p></blockquote></li></ul><p><strong><code>Promise</code>缺点</strong></p><ul><li>无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。</li><li>当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul><h3 id="12-2-基本使用"><a href="#12-2-基本使用" class="headerlink" title="12.2 基本使用"></a>12.2 基本使用</h3>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECMAScript2015 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react导出表格</title>
      <link href="/2019/12/24/react%E5%AF%BC%E5%87%BA%E8%A1%A8%E6%A0%BC/"/>
      <url>/2019/12/24/react%E5%AF%BC%E5%87%BA%E8%A1%A8%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="React-ant-design表格导出数据为EXCEL表格数据"><a href="#React-ant-design表格导出数据为EXCEL表格数据" class="headerlink" title="React ant design表格导出数据为EXCEL表格数据"></a><a href="https://segmentfault.com/a/1190000017261691" target="_blank" rel="noopener">React ant design表格导出数据为EXCEL表格数据</a></h1><pre><code>yarn安装-记得以管理员身份执行yarn add js-export-excelnpm安装npm install js-export-excel</code></pre><pre><code class="js">import ExportJsonExcel from &#39;js-export-excel&#39;;</code></pre><pre><code class="html">按钮： return (    &lt;div&gt;       &lt;Button onClick={this.downloadExcel}&gt;导出Excel表格&lt;/Button&gt;    &lt;/div&gt;)</code></pre><pre><code class="js">downloadExcel = () =&gt; {const data = this.state.data ? this.state.data : &#39;&#39;;//表格数据  var option={};  let dataTable = [];  if (data) {    for (let i in data) {      if(data){        let obj = {          &#39;组织ID&#39;: data[i].id,          &#39;组织代码&#39;: data[i].organization_code,          &#39;组织名称&#39;: data[i].organization_name,        }        dataTable.push(obj);      }    }  }  option.fileName = &#39;组织信息&#39;  option.datas=[    {      sheetData:dataTable,      sheetName:&#39;sheet&#39;,      sheetFilter:[&#39;组织ID&#39;,&#39;组织代码&#39;,&#39;组织名称&#39;],      sheetHeader:[&#39;组织ID&#39;,&#39;组织代码&#39;,&#39;组织名称&#39;],    }  ];  var toExcel = new ExportJsonExcel(option);   toExcel.saveExcel();        }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css案例</title>
      <link href="/2019/12/23/css%E6%A1%88%E4%BE%8B/"/>
      <url>/2019/12/23/css%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="灵活运用CSS开发技巧"><a href="#灵活运用CSS开发技巧" class="headerlink" title="灵活运用CSS开发技巧"></a>灵活运用CSS开发技巧</h1><h2 id="Layout-Skill"><a href="#Layout-Skill" class="headerlink" title="Layout Skill"></a>Layout Skill</h2><h3 id="使用vw定制rem自适应布局"><a href="#使用vw定制rem自适应布局" class="headerlink" title="使用vw定制rem自适应布局"></a>使用vw定制rem自适应布局</h3><ul><li>要点：移动端使用rem布局需要通过JS设置不同屏幕宽高比的font-size，结合vw单位和calc()可脱离JS的控制</li><li>场景：rem页面布局(不兼容低版本移动端系统)</li><li>兼容：<a href="https://caniuse.com/#search=vw" target="_blank" rel="noopener">vw</a>、<a href="https://caniuse.com/#search=calc()" target="_blank" rel="noopener">calc()</a><pre><code class="css">/* 基于UI width=750px DPR=2的页面 */html {  font-size: calc(100vw / 7.5);}</code></pre><h3 id="使用-nth-child-选择指定元素"><a href="#使用-nth-child-选择指定元素" class="headerlink" title="使用:nth-child()选择指定元素"></a>使用:nth-child()选择指定元素</h3></li><li>要点：通过:nth-child()筛选指定的元素设置样式</li><li>场景：表格着色、边界元素排版(首元素、尾元素、左右两边元素)</li><li>兼容：:<a href="https://caniuse.com/#search=%3Anth-child()" target="_blank" rel="noopener">nth-child()</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/voRzNP" target="_blank" rel="noopener">在线演示</a><pre><code class="css">z.specified-scope {  width: 300px;  li {      padding: 0 20px;      height: 40px;      line-height: 40px;      color: #fff;      &amp;:nth-child(odd) {          background-color: #f66;      }      &amp;:nth-child(even) {          background-color: #66f;      }      &amp;:nth-child(n+6):nth-child(-n+10) {          background-color: #3c9;      }  }}</code></pre><img src="/images/1.png" alt="tp"></li></ul><h3 id="使用writing-mode排版竖文"><a href="#使用writing-mode排版竖文" class="headerlink" title="使用writing-mode排版竖文"></a>使用writing-mode排版竖文</h3><ul><li>要点：通过writing-mode调整文本排版方向</li><li>场景：竖行文字、文言文、诗词</li><li>兼容：<a href="https://caniuse.com/#search=writing-mode" target="_blank" rel="noopener">writing-mode</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/XvExJO" target="_blank" rel="noopener">在线演示</a></li></ul><h3 id="使用text-align-last对齐两端文本"><a href="#使用text-align-last对齐两端文本" class="headerlink" title="使用text-align-last对齐两端文本"></a>使用text-align-last对齐两端文本</h3><ul><li>要点：通过text-align-last:justify设置文本两端对齐</li><li>场景：未知字数中文对齐</li><li>兼容：<a href="https://caniuse.com/#search=text-align-last" target="_blank" rel="noopener">text-align-last</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/ZgxZJa" target="_blank" rel="noopener">在线演示</a><h3 id="使用-not-去除无用属性"><a href="#使用-not-去除无用属性" class="headerlink" title="使用:not()去除无用属性"></a>使用:not()去除无用属性</h3></li><li>要点：通过:not()排除指定元素不使用设置样式</li><li>场景：符号分割文字、边界元素排版(首元素、尾元素、左右两边元素)</li><li>兼容：:<a href="https://caniuse.com/#search=%3Anot()" target="_blank" rel="noopener">not</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/gVeyqr" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/2.png" alt="tu2"></p><h3 id="使用object-fit规定图像尺寸"><a href="#使用object-fit规定图像尺寸" class="headerlink" title="使用object-fit规定图像尺寸"></a>使用object-fit规定图像尺寸</h3><ul><li>要点：通过object-fit使图像脱离background-size的约束，使用<img>来标记图像背景尺寸</li><li>场景：图片尺寸自适应</li><li>兼容：<a href="https://caniuse.com/#search=object-fit" target="_blank" rel="noopener">object-fit</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/LwBKLV" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/3.png" alt="tp3"></p><h3 id="使用overflow-x排版横向列表"><a href="#使用overflow-x排版横向列表" class="headerlink" title="使用overflow-x排版横向列表"></a>使用overflow-x排版横向列表</h3><ul><li>要点：通过flexbox或inline-block的形式横向排列元素，对父元素设置overflow-x:auto横向滚动查看</li><li>场景：横向滚动列表、元素过多但位置有限的导航栏</li><li>兼容：<a href="https://caniuse.com/#search=overflow-x" target="_blank" rel="noopener">overflow-x</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/jONqyVd" target="_blank" rel="noopener">在线演示</a><br><img src="/images/4.gif" alt="tp1"></li></ul><h3 id="使用text-overflow控制文本溢出"><a href="#使用text-overflow控制文本溢出" class="headerlink" title="使用text-overflow控制文本溢出"></a>使用text-overflow控制文本溢出</h3><ul><li>要点：通过text-overflow:ellipsis对溢出的文本在末端添加<code>...</code></li><li>场景：单行文字溢出、多行文字溢出</li><li>兼容：<a href="https://caniuse.com/#search=text-overflow" target="_blank" rel="noopener">text-overflow</a>、<a href="https://caniuse.com/#search=line-clamp" target="_blank" rel="noopener">line-clamp</a>、<a href="https://www.w3school.com.cn/cssref/pr_box-orient.asp" target="_blank" rel="noopener">box-orient</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/mdbPmyy" target="_blank" rel="noopener">在线演示</a><br><img src="/images/5.png" alt="tp2"></li></ul><h3 id="使用transform描绘1px边框"><a href="#使用transform描绘1px边框" class="headerlink" title="使用transform描绘1px边框"></a>使用transform描绘1px边框</h3><ul><li>要点：分辨率比较低的屏幕下显示1px的边框会显得模糊，通过::before或::after和transform模拟细腻的1px边框</li><li>场景：容器1px边框</li><li>兼容：<a href="https://caniuse.com/#search=transform" target="_blank" rel="noopener">transform</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/YzKqMVO" target="_blank" rel="noopener">在线演示</a></li></ul><h3 id="使用transform翻转内容"><a href="#使用transform翻转内容" class="headerlink" title="使用transform翻转内容"></a>使用transform翻转内容</h3><ul><li>要点：通过transform:scale3d()对内容进行翻转(水平翻转、垂直翻转、倒序翻转)</li><li>场景：内容翻转</li><li>兼容：transform</li><li>代码：在线演示</li></ul><p><img src="/images/6.png" alt="tp2"></p><h3 id="使用letter-spacing排版倒序文本"><a href="#使用letter-spacing排版倒序文本" class="headerlink" title="使用letter-spacing排版倒序文本"></a>使用letter-spacing排版倒序文本</h3><p>要点：通过letter-spacing设置负值字体间距将文本倒序<br>场景：文言文、诗词</p><ul><li>兼容：<a href="https://caniuse.com/#search=letter-spacing" target="_blank" rel="noopener">letter-spacing</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/zYOBgqB" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/7.png" alt="tp2"></p><h3 id="使用margin-left排版左重右轻列表"><a href="#使用margin-left排版左重右轻列表" class="headerlink" title="使用margin-left排版左重右轻列表"></a>使用margin-left排版左重右轻列表</h3><ul><li>要点：使用flexbox横向布局时，最后一个元素通过margin-left:auto实现向右对齐</li><li>场景：右侧带图标的导航栏</li><li>兼容：<a href="https://caniuse.com/#search=margin" target="_blank" rel="noopener">margin</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/PoYpROw" target="_blank" rel="noopener">在线演示</a><h2 id="Behavior-Skill"><a href="#Behavior-Skill" class="headerlink" title="Behavior Skill"></a>Behavior Skill</h2><h3 id="使用overflow-scrolling支持弹性滚动"><a href="#使用overflow-scrolling支持弹性滚动" class="headerlink" title="使用overflow-scrolling支持弹性滚动"></a>使用overflow-scrolling支持弹性滚动</h3></li><li>要点：iOS页面非body元素的滚动操作会非常卡(Android不会出现此情况)，通过overflow-scrolling:touch调用Safari原生滚动来支持弹性滚动，增加页面滚动的流畅度</li><li>场景：iOS页面滚动</li><li>兼容：iOS自带-webkit-overflow-scrolling<pre><code class="css">body {  -webkit-overflow-scrolling: touch;}.elem {  overflow: auto;}</code></pre><h3 id="使用transform启动GPU硬件加速"><a href="#使用transform启动GPU硬件加速" class="headerlink" title="使用transform启动GPU硬件加速"></a>使用transform启动GPU硬件加速</h3></li><li>要点：有时执行动画可能会导致页面卡顿，可在特定元素中使用硬件加速来避免这个问题</li><li>场景：动画元素(绝对定位、同级中超过6个以上使用动画)</li><li>兼容：transform<pre><code class="css">.elem {  transform: translate3d(0, 0, 0); /* translateZ(0)亦可 */}</code></pre><h3 id="使用attr-抓取data"><a href="#使用attr-抓取data" class="headerlink" title="使用attr()抓取data-*"></a>使用attr()抓取data-*</h3></li><li>要点：在标签上自定义属性data-*，通过attr()获取其内容赋值到content上</li><li>场景：提示框</li><li>兼容：<a href="https://caniuse.com/#search=data-" target="_blank" rel="noopener">data-*</a>、<a href="https://caniuse.com/#search=attr()" target="_blank" rel="noopener">attr()</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/voRdKX" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/8.gif" alt="tp2"></p><h3 id="使用-valid和-invalid校验表单"><a href="#使用-valid和-invalid校验表单" class="headerlink" title="使用:valid和:invalid校验表单"></a>使用:valid和:invalid校验表单</h3><ul><li>要点：<input>使用伪类:valid和:invalid配合pattern校验表单输入的内容</li><li>场景：表单校验</li><li>兼容：<a href="https://caniuse.com/#search=pattern" target="_blank" rel="noopener">pattern</a>、<a href="https://caniuse.com/#search=%3Avalid" target="_blank" rel="noopener">:valid</a>、<a href="https://caniuse.com/#search=%3Ainvalid" target="_blank" rel="noopener">:invalid</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/QemxKr" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/9.gif" alt="tp"></p><h3 id="使用pointer-events禁用事件触发"><a href="#使用pointer-events禁用事件触发" class="headerlink" title="使用pointer-events禁用事件触发"></a>使用pointer-events禁用事件触发</h3><ul><li>要点：通过pointer-events:none禁用事件触发(默认事件、冒泡事件、鼠标事件、键盘事件等)，相当于<button>的disabled</li><li>场景：限时点击按钮(发送验证码倒计时)、事件冒泡禁用(多个元素重叠且自带事件、a标签跳转)</li><li>兼容：<a href="https://caniuse.com/#search=pointer-events" target="_blank" rel="noopener">pointer-events</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/dxmrLj" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/10.gif" alt="tp"></p><h3 id="使用-或-美化选项框"><a href="#使用-或-美化选项框" class="headerlink" title="使用+或~美化选项框"></a>使用+或~美化选项框</h3><ul><li>要点：<label>使用+或~配合for绑定radio或checkbox的选择行为</li><li>场景：选项框美化、选中项增加选中样式</li><li>兼容：<a href="https://caniuse.com/#search=+" target="_blank" rel="noopener">+</a>、<a href="https://caniuse.com/#search=~" target="_blank" rel="noopener">~</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/rXdbgZ" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/11.gif" alt="tp"></p><h3 id="使用-focus-within分发冒泡响应"><a href="#使用-focus-within分发冒泡响应" class="headerlink" title="使用:focus-within分发冒泡响应"></a>使用:focus-within分发冒泡响应</h3><ul><li>要点：表单控件触发focus和blur事件后往父元素进行冒泡，在父元素上通过:focus-within捕获该冒泡事件来设置样式</li><li>场景：登录注册弹框、表单校验、离屏导航、导航切换</li><li>兼容：:<a href="https://www.caniuse.com/#search=%3Afocus-within" target="_blank" rel="noopener">focus-within</a>、<a href="https://www.caniuse.com/#search=%3Aplaceholder-shown" target="_blank" rel="noopener">:placeholder-shown</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/BaBjaBP" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/12.gif" alt="tp"></p><h3 id="使用-hover描绘鼠标跟随"><a href="#使用-hover描绘鼠标跟随" class="headerlink" title="使用:hover描绘鼠标跟随"></a>使用:hover描绘鼠标跟随</h3><ul><li>要点：将整个页面等比划分成小的单元格，每个单元格监听:hover，通过:hover触发单元格的样式变化来描绘鼠标运动轨迹</li><li>场景：鼠标跟随轨迹、<a href="https://codepen.io/YusukeNakaya/pen/vvEqVx" target="_blank" rel="noopener">水波纹</a>、<a href="https://codepen.io/Chokcoco/pen/zyyYqN" target="_blank" rel="noopener">怪圈</a></li><li>兼容：<a href="https://www.caniuse.com/#search=%3Ahover" target="_blank" rel="noopener">:hover</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/wvwMLJY" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/13.gif" alt="p"></p><h3 id="使用max-height切换自动高度"><a href="#使用max-height切换自动高度" class="headerlink" title="使用max-height切换自动高度"></a>使用max-height切换自动高度</h3><ul><li><p>要点：通过max-height定义收起的最小高度和展开的最大高度，设置两者间的过渡切换</p></li><li><p>场景：隐藏式子导航栏、悬浮式折叠面板</p></li><li><p>兼容：<a href="https://caniuse.com/#search=max-height" target="_blank" rel="noopener">max-height</a></p></li><li><p>代码：<a href="https://codepen.io/JowayYoung/pen/NQYJpm" target="_blank" rel="noopener">在线演示</a><br><img src="/images/14.gif" alt="13"></p><h3 id="使用transform模拟视差滚动"><a href="#使用transform模拟视差滚动" class="headerlink" title="使用transform模拟视差滚动"></a>使用transform模拟视差滚动</h3></li><li><p>要点：通过background-attachment:fixed或transform让多层背景以不同的速度移动，形成立体的运动效果</p></li><li><p>场景：<a href="https://codepen.io/Chokcoco/pen/JBaQoY" target="_blank" rel="noopener">页面滚动</a>、<a href="https://codepen.io/Chokcoco/pen/XBgBBp" target="_blank" rel="noopener">视差滚动文字阴影</a>、<a href="https://codepen.io/Chokcoco/pen/PBXwdX" target="_blank" rel="noopener">视差滚动文字虚影</a></p></li><li><p>兼容：<a href="https://www.caniuse.com/#search=background-attachment" target="_blank" rel="noopener">background-attachment</a>、<a href="https://www.caniuse.com/#search=transform" target="_blank" rel="noopener">transform</a></p></li><li><p>代码：<a href="https://codepen.io/JowayYoung/pen/MWgaBoK" target="_blank" rel="noopener">在线演示</a></p></li></ul><p><img src="/images/15.gif" alt="15"></p><h3 id="使用animation-delay保留动画起始帧"><a href="#使用animation-delay保留动画起始帧" class="headerlink" title="使用animation-delay保留动画起始帧"></a>使用animation-delay保留动画起始帧</h3><ul><li>要点：通过transform-delay或animation-delay设置负值时延保留动画起始帧，让动画进入页面不用等待即可运行</li><li>场景：开场动画</li><li>兼容：<a href="https://www.caniuse.com/#search=transform" target="_blank" rel="noopener">transform</a>、<a href="https://www.caniuse.com/#search=animation" target="_blank" rel="noopener">animation</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/WNexVoB" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/16.gif" alt="16"></p><h3 id="使用resize拉伸分栏"><a href="#使用resize拉伸分栏" class="headerlink" title="使用resize拉伸分栏"></a>使用resize拉伸分栏</h3><ul><li>要点：通过resize设置横向自由拉伸来调整目标元素的宽度</li><li>场景：富文本编辑器、分栏阅读</li><li>兼容：<a href="https://caniuse.com/#search=resize" target="_blank" rel="noopener">resize</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/JjPEdWO" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/17.gif" alt="17"></p><h2 id="Color-Skill"><a href="#Color-Skill" class="headerlink" title="Color Skill"></a>Color Skill</h2><h3 id="使用color改变边框颜色"><a href="#使用color改变边框颜色" class="headerlink" title="使用color改变边框颜色"></a>使用color改变边框颜色</h3><ul><li>要点：border没有定义border-color时，设置color后，border-color会被定义成color</li><li>场景：边框颜色与文字颜色相同</li><li>兼容：<a href="https://caniuse.com/#search=color" target="_blank" rel="noopener">color</a><pre><code class="css">.elem {  border: 1px solid;  color: #f66;}</code></pre><img src="/images/18.gif" alt="18"></li></ul><h3 id="使用filter开启悼念模式"><a href="#使用filter开启悼念模式" class="headerlink" title="使用filter开启悼念模式"></a>使用filter开启悼念模式</h3><ul><li>要点：通过filter:grayscale()设置灰度模式来悼念某位去世的仁兄或悼念因灾难而去世的人们</li><li>场景：网站悼念</li><li>兼容：<a href="https://caniuse.com/#search=filter" target="_blank" rel="noopener">filter</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/vYBKqwe" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/19.png" alt="19"></p><h3 id="使用-selection改变文本选择颜色"><a href="#使用-selection改变文本选择颜色" class="headerlink" title="使用::selection改变文本选择颜色"></a>使用::selection改变文本选择颜色</h3><ul><li>要点：通过::selection根据主题颜色自定义文本选择颜色</li><li>场景：主题化</li><li>兼容：<a href="https://caniuse.com/#search=%3A%3Aselection" target="_blank" rel="noopener">::selection</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/jONrjXX" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/20.gif" alt="tup"></p><h3 id="使用linear-gradient控制背景渐变"><a href="#使用linear-gradient控制背景渐变" class="headerlink" title="使用linear-gradient控制背景渐变"></a>使用linear-gradient控制背景渐变</h3><ul><li>要点：通过linear-gradient设置背景渐变色并放大背景尺寸，添加背景移动效果</li><li>场景：主题化、彩虹背景墙</li><li>兼容：<a href="https://caniuse.com/#search=gradient" target="_blank" rel="noopener">gradient</a>、<a href="https://www.caniuse.com/#search=animation" target="_blank" rel="noopener">animation</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/oNvbRwN" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/21.gif" alt="tup"></p><h3 id="使用linear-gradient控制文本渐变"><a href="#使用linear-gradient控制文本渐变" class="headerlink" title="使用linear-gradient控制文本渐变"></a>使用linear-gradient控制文本渐变</h3><ul><li>要点：通过linear-gradient设置背景渐变色，配合background-clip:text对背景进行文本裁剪，添加滤镜动画</li><li>场景：主题化、特色标题</li><li>兼容：<a href="https://caniuse.com/#search=gradient" target="_blank" rel="noopener">gradient</a>、<a href="https://www.caniuse.com/#search=background-clip" target="_blank" rel="noopener">background-clip</a>、<a href="https://caniuse.com/#search=filter" target="_blank" rel="noopener">filter</a>、<a href="https://www.caniuse.com/#search=animation" target="_blank" rel="noopener">animation</a>、<a href="https://www.caniuse.com/#search=text-fill-color" target="_blank" rel="noopener">text-fill-color</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/pozgQVo" target="_blank" rel="noopener">在线演示</a></li></ul><h3 id="使用caret-color改变光标颜色"><a href="#使用caret-color改变光标颜色" class="headerlink" title="使用caret-color改变光标颜色"></a>使用caret-color改变光标颜色</h3><ul><li>要点：通过caret-color根据主题颜色自定义光标颜色<br>场景：主题化</li><li>兼容：<a href="https://caniuse.com/#search=caret-color" target="_blank" rel="noopener">caret-color</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/QemxKr" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/22.gif" alt="tip"></p><h3 id="使用-scrollbar改变滚动条样式"><a href="#使用-scrollbar改变滚动条样式" class="headerlink" title="使用::scrollbar改变滚动条样式"></a>使用::scrollbar改变滚动条样式</h3><ul><li>要点：通过scrollbar的scrollbar-track和scrollbar-thumb等属性来自定义滚动条样式</li><li>场景：主题化、页面滚动</li><li>兼容：<a href="https://www.caniuse.com/#search=scrollbar" target="_blank" rel="noopener">::scrollbar</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/ExYPMog" target="_blank" rel="noopener">在线演示</a></li></ul><h3 id="使用filter模拟Instagram滤镜"><a href="#使用filter模拟Instagram滤镜" class="headerlink" title="使用filter模拟Instagram滤镜"></a>使用filter模拟Instagram滤镜</h3><ul><li>要点：通过filter的滤镜组合起来模拟Instagram滤镜<br>场景：图片滤镜</li><li>兼容：<a href="https://caniuse.com/#search=filter" target="_blank" rel="noopener">filter</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/NWKbVNQ" target="_blank" rel="noopener">在线演示</a>、<a href="https://github.com/una/CSSgram/blob/master/README-CN.md" target="_blank" rel="noopener">css-gram</a></li></ul><h3 id="Figure-Skill"><a href="#Figure-Skill" class="headerlink" title="Figure Skill"></a>Figure Skill</h3><p><strong>使用div描绘各种图形</strong></p><ul><li>要点：<div>配合其伪元素(::before、::after)通过clip、transform等方式绘制各种图形</li><li>场景：各种图形容器</li><li>兼容：<a href="https://caniuse.com/#search=clip" target="_blank" rel="noopener">clip</a>、<a href="https://caniuse.com/#search=transform" target="_blank" rel="noopener">transform</a></li><li>代码：<a href="https://css-tricks.com/the-shapes-of-css/" target="_blank" rel="noopener">在线演示</a></li></ul><h3 id="使用mask雕刻镂空背景"><a href="#使用mask雕刻镂空背景" class="headerlink" title="使用mask雕刻镂空背景"></a>使用mask雕刻镂空背景</h3><ul><li>要点：通过mask为图像背景生成蒙层提供遮罩效果</li><li>场景：高斯模糊蒙层、<a href="https://codepen.io/HelKyle/pen/XxZPmY/" target="_blank" rel="noopener">票劵(电影票、购物卡)</a>、<a href="https://codepen.io/banik/pen/aRpvdW" target="_blank" rel="noopener">遮罩动画</a></li><li>兼容：<a href="https://www.caniuse.com/#search=mask" target="_blank" rel="noopener">mask</a>、<a href="https://caniuse.com/#search=perspective" target="_blank" rel="noopener">perspective</a>、<a href="https://caniuse.com/#search=transform-style" target="_blank" rel="noopener">transform-style</a>、<a href="https://www.caniuse.com/#search=animation" target="_blank" rel="noopener">animation</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/xxKZdZN" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/23.gif" alt="tp"></p><h3 id="使用linear-gradient描绘波浪线"><a href="#使用linear-gradient描绘波浪线" class="headerlink" title="使用linear-gradient描绘波浪线"></a>使用linear-gradient描绘波浪线</h3><ul><li>要点：通过linear-gradient绘制波浪线</li><li>场景：文字强化显示、文字下划线、内容分割线</li><li>兼容：<a href="https://caniuse.com/#search=gradient" target="_blank" rel="noopener">gradient</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/EqEzwq" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/24.png" alt="tp"></p><h3 id="使用linear-gradient描绘彩带"><a href="#使用linear-gradient描绘彩带" class="headerlink" title="使用linear-gradient描绘彩带"></a>使用linear-gradient描绘彩带</h3><ul><li>要点：通过linear-gradient绘制间断颜色的彩带</li><li>场景：主题化</li><li>兼容：<a href="https://caniuse.com/#search=gradient" target="_blank" rel="noopener">gradient</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/bGbeXZG" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/25.png" alt="325"></p><h3 id="使用conic-gradient描绘饼图"><a href="#使用conic-gradient描绘饼图" class="headerlink" title="使用conic-gradient描绘饼图"></a>使用conic-gradient描绘饼图</h3><ul><li>要点：通过conic-gradient绘制多种色彩的饼图</li><li>场景：项占比饼图</li><li>兼容：<a href="https://caniuse.com/#search=gradient" target="_blank" rel="noopener">gradient</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/XWrjrgE" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/26.png" alt="26"></p><h3 id="使用linear-gradient描绘方格背景"><a href="#使用linear-gradient描绘方格背景" class="headerlink" title="使用linear-gradient描绘方格背景"></a>使用linear-gradient描绘方格背景</h3><ul><li>要点：使用linear-gradient绘制间断颜色的彩带进行交互生成方格</li><li>场景：格子背景、占位图</li><li>兼容：<a href="https://caniuse.com/#search=gradient" target="_blank" rel="noopener">gradient</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/RwboXoV" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/27.png" alt="27"></p><h3 id="使用box-shadow描绘单侧投影"><a href="#使用box-shadow描绘单侧投影" class="headerlink" title="使用box-shadow描绘单侧投影"></a>使用box-shadow描绘单侧投影</h3><p>要点：通过box-shadow生成投影，且模糊半径和负的扩张半径一致，使投影偏向一侧<br>场景：容器投影、<a href="https://codepen.io/Chokcoco/pen/WaBYZL" target="_blank" rel="noopener">背景补间动画1</a>、<a href="https://codepen.io/davidkpiano/pen/LVzxPV" target="_blank" rel="noopener">背景补间动画2</a>、<a href="https://codepen.io/Chokcoco/pen/LgdRKE" target="_blank" rel="noopener">立体投影</a>、<a href="https://codepen.io/Chokcoco/pen/JmgNNa" target="_blank" rel="noopener">文字立体投影</a>、<a href="https://codepen.io/Chokcoco/pen/XxQJEB" target="_blank" rel="noopener">文字渐变立体投影</a>、<a href="https://codepen.io/Chokcoco/pen/qJvVGy" target="_blank" rel="noopener">长投影</a>、<a href="https://codepen.io/Chokcoco/pen/WaLdwX" target="_blank" rel="noopener">霓虹灯</a>、<a href="https://codepen.io/Chokcoco/pen/ReOgvq" target="_blank" rel="noopener">灯光阴影</a><br>兼容：<a href="https://caniuse.com/#search=box-shadow" target="_blank" rel="noopener">box-shadow</a>、<a href="https://caniuse.com/#search=filter" target="_blank" rel="noopener">filter</a>、<a href="https://caniuse.com/#search=text-shadow" target="_blank" rel="noopener">text-shadow</a><br>代码：<a href="https://codepen.io/JowayYoung/pen/BaBLqYo" target="_blank" rel="noopener">在线演示</a></p><p><img src="/images/28.png" alt="28"></p><h3 id="使用box-shadow裁剪图像"><a href="#使用box-shadow裁剪图像" class="headerlink" title="使用box-shadow裁剪图像"></a>使用box-shadow裁剪图像</h3><ul><li>要点：通过box-shadow模拟蒙层实现中间镂空</li><li>场景：图片裁剪、新手引导、背景镂空、投射定位</li><li>兼容：<a href="https://caniuse.com/#search=box-shadow" target="_blank" rel="noopener">box-shadow</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/zYONxRG" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/29.png" alt="29"></p><h3 id="使用outline描绘内边框"><a href="#使用outline描绘内边框" class="headerlink" title="使用outline描绘内边框"></a>使用outline描绘内边框</h3><ul><li>要点：通过outline设置轮廓进行描边，可设置outline-offset设置内描边</li><li>场景：内描边、外描边</li><li>兼容：<a href="https://caniuse.com/#search=outline" target="_blank" rel="noopener">outline</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/pozeVyL" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/30.png" alt="30"></p><h2 id="Figure-Skill-1"><a href="#Figure-Skill-1" class="headerlink" title="Figure Skill"></a>Figure Skill</h2><h2 id="Component-Skil"><a href="#Component-Skil" class="headerlink" title="Component Skil"></a>Component Skil</h2><h3 id="迭代计数器"><a href="#迭代计数器" class="headerlink" title="迭代计数器"></a>迭代计数器</h3><ul><li>要点：累加选项单位的计数器</li><li>场景：章节目录、选项计数器、<a href="https://codepen.io/CSSKing/pen/vEeMey" target="_blank" rel="noopener">加法计数器</a></li><li>兼容：<a href="https://caniuse.com/#search=counters" target="_blank" rel="noopener">counters</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/rXqRPo" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/31.gif" alt="31"></p><h3 id="下划线跟随导航栏"><a href="#下划线跟随导航栏" class="headerlink" title="下划线跟随导航栏"></a>下划线跟随导航栏</h3><ul><li>要点：下划线跟随鼠标移动的导航栏</li><li>场景：动态导航栏</li><li>兼容：<a href="https://caniuse.com/#search=+" target="_blank" rel="noopener">+</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/eYOJbNv" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/32.gif" alt="32"></p><h3 id="气泡背景墙"><a href="#气泡背景墙" class="headerlink" title="气泡背景墙"></a>气泡背景墙</h3><ul><li>要点：不间断冒出气泡的背景墙</li><li>场景：动态背景</li><li>兼容：<a href="https://www.caniuse.com/#search=animation" target="_blank" rel="noopener">animation</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/GRKoPdK" target="_blank" rel="noopener">在线演示</a></li></ul><h3 id="滚动指示器"><a href="#滚动指示器" class="headerlink" title="滚动指示器"></a>滚动指示器</h3><ul><li>要点：提示滚动进度的指示器</li><li>场景：<a href="https://codepen.io/MadeByMike/pen/ZOrEmr" target="_blank" rel="noopener">阅读进度</a></li><li>兼容：<a href="https://caniuse.com/#search=calc()" target="_blank" rel="noopener">calc()</a>、<a href="https://caniuse.com/#search=gradient" target="_blank" rel="noopener">gradient</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/ExYPMog" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/33.gif" alt="33"></p><h3 id="故障文本"><a href="#故障文本" class="headerlink" title="故障文本"></a>故障文本</h3><ul><li>要点：显示器故障形式的文本</li><li>场景：错误提示</li><li>兼容：<a href="https://caniuse.com/#search=data-" target="_blank" rel="noopener">data-*</a>、<a href="https://caniuse.com/#search=attr()" target="_blank" rel="noopener">attr()</a>、<a href="https://www.caniuse.com/#search=animation" target="_blank" rel="noopener">animation</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/xxKZNYv" target="_blank" rel="noopener">在线演示</a></li></ul><h3 id="换色器"><a href="#换色器" class="headerlink" title="换色器"></a>换色器</h3><ul><li>要点：通过拾色器改变图像色相的换色器</li><li>场景：图片色彩变换</li><li>兼容：<a href="https://www.caniuse.com/#search=mix-blend-mode" target="_blank" rel="noopener">mix-blend-mode</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/vYBLqBm" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/34.gif" alt="34"></p><h3 id="状态悬浮球"><a href="#状态悬浮球" class="headerlink" title="状态悬浮球"></a>状态悬浮球</h3><ul><li>要点：展示当前状态的悬浮球</li><li>场景：状态动态显示、波浪动画</li><li>兼容：<a href="https://caniuse.com/#search=gradient" target="_blank" rel="noopener">gradient</a>、<a href="https://www.caniuse.com/#search=animation" target="_blank" rel="noopener">animation</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/WNewOxa" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/35.gif" alt="35"></p><h3 id="粘粘球"><a href="#粘粘球" class="headerlink" title="粘粘球"></a>粘粘球</h3><ul><li>要点：相交粘粘效果的双球回弹运动</li><li>场景：<a href="https://codepen.io/Chokcoco/pen/QqWBqV" target="_blank" rel="noopener">粘粘动画</a></li><li>兼容：<a href="https://caniuse.com/#search=filter" target="_blank" rel="noopener">filter</a><a href="https://www.caniuse.com/#search=animation" target="_blank" rel="noopener">、animation</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/zYOqdBz" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/37.gif" alt="37"></p><h3 id="商城票券"><a href="#商城票券" class="headerlink" title="商城票券"></a>商城票券</h3><ul><li>要点：边缘带孔和中间折痕的票劵</li><li>场景：电影票、代金券、消费卡</li><li>兼容：<a href="https://caniuse.com/#search=gradient" target="_blank" rel="noopener">gradient</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/rNBeYza" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/36.png" alt="36"></p><h3 id="倒影加载条"><a href="#倒影加载条" class="headerlink" title="倒影加载条"></a>倒影加载条</h3><ul><li>要点：带有渐变倒影的加载条</li><li>场景：加载提示</li><li>兼容：<a href="https://caniuse.com/#search=box-reflect" target="_blank" rel="noopener">box-reflect</a>、<a href="https://www.caniuse.com/#search=animation" target="_blank" rel="noopener">animation</a><br>代码：<a href="https://codepen.io/JowayYoung/pen/GRKZzpg" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/38.gif" alt="38"></p><h3 id="三维立方体"><a href="#三维立方体" class="headerlink" title="三维立方体"></a>三维立方体</h3><ul><li>要点：三维建模的立方体</li><li>场景：三维建模</li><li>兼容：transform、perspective、transform-style、animation</li><li>代码：<a href="https://codepen.io/JowayYoung/pen/PoYNgXY" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/40.gif" alt="tp"></p><h3 id="动态边框"><a href="#动态边框" class="headerlink" title="动态边框"></a>动态边框</h3><ul><li>要点：鼠标悬浮时动态渐变显示的边框<br>场景：悬浮按钮、边框动画<br>兼容：<a href="https://caniuse.com/#search=gradient" target="_blank" rel="noopener">gradient</a><br>代码：在线演示</li></ul><p><img src="/images/41.gif" alt="41"></p><h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><ul><li>要点：可切换内容的标签页</li><li>场景：内容切换</li><li>兼容：<a href="https://caniuse.com/#search=scroll-behavior" target="_blank" rel="noopener">scroll-behavior</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/JjPRjMd" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/42.gif" alt="pr"></p><h3 id="标签导航栏"><a href="#标签导航栏" class="headerlink" title="标签导航栏"></a>标签导航栏</h3><ul><li>要点：可切换内容的导航栏</li><li>场景：页面切换</li><li>兼容：<a href="https://caniuse.com/#search=~" target="_blank" rel="noopener">~</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/oNvzoZg" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/43.gif" alt="43"></p><h3 id="星级评分"><a href="#星级评分" class="headerlink" title="星级评分"></a>星级评分</h3><ul><li>要点：点击星星进行评分的按钮</li><li>场景：评分</li><li>兼容：<a href="https://caniuse.com/#search=~" target="_blank" rel="noopener">~</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/MWgjGMj" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/44.gif" alt="44"></p><h3 id="加载指示器"><a href="#加载指示器" class="headerlink" title="加载指示器"></a>加载指示器</h3><ul><li>要点：变换…长度的加载提示</li><li>场景：加载提示</li><li>兼容：<a href="https://www.caniuse.com/#search=animation" target="_blank" rel="noopener">animation</a></li><li>代码：<a href="https://codepen.io/JowayYoung/pen/wvwoRbN" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/45.gif" alt="45"></p><h3 id="自适应相册"><a href="#自适应相册" class="headerlink" title="自适应相册"></a>自适应相册</h3><ul><li>要点：自适应照片数量的相册</li><li>场景：九宫格相册、微信相册、图集</li><li>兼容：:only-child、:first-child、:nth-child()、:nth-last-child()、~</li><li>代码：<a href="https://codepen.io/JowayYoung/pen/pozNGyj" target="_blank" rel="noopener">在线演示</a></li></ul><p><img src="/images/46.gif" alt="46"></p><p><a href="https://juejin.im/post/5d4d0ec651882549594e7293#heading-25" target="_blank" rel="noopener">学习地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>destructore</title>
      <link href="/2019/12/11/destructore/"/>
      <url>/2019/12/11/destructore/</url>
      
        <content type="html"><![CDATA[<h1 id="Desctructuring"><a href="#Desctructuring" class="headerlink" title="Desctructuring"></a>Desctructuring</h1><p>在 ES6 中新增了变量赋值的方式：解构赋值。如果对这个概念不了解，我们可以快速展示一个小示例一睹风采：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'Ilya'</span>, <span class="string">'Kantor'</span>]</span><br><span class="line"><span class="keyword">let</span> firstName = arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> surname = arr[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>想从数组中找出有意义的项要单独赋值给变量（一一的写），在 ES6 中就可以这样写了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [firstName, surname] = [<span class="string">'Ilya'</span>, <span class="string">'Kantor'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(firstName) <span class="comment">// Ilya</span></span><br><span class="line"><span class="built_in">console</span>.log(surname) <span class="comment">// Kantor</span></span><br></pre></td></tr></table></figure><blockquote><p>[!TIP]<br>解构赋值重点是在赋值，赋值的元素是要拷贝出来赋值给变量，赋值的元素本身是不会被改变的。</p></blockquote><h2 id="Array-Destructuring"><a href="#Array-Destructuring" class="headerlink" title="Array Destructuring"></a>Array Destructuring</h2><p>上述的小示例已经在描述数组的解构赋值了，可是那只是开始。</p><ul><li>可以跳过赋值元素<br>如果想忽略数组的某个元素对变量进行赋值，可以使用逗号来处理。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// second element is not needed</span></span><br><span class="line"><span class="keyword">let</span> [firstName, , title] = [<span class="string">"Julius"</span>, <span class="string">"Caesar"</span>, <span class="string">"Consul"</span>, <span class="string">"of the Roman Republic"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( title ); <span class="comment">// Consul</span></span><br></pre></td></tr></table></figure></li><li>赋值元素可以是任意可遍历的对象<br>赋值的元素不仅是数组，它可以是任意可遍历的对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = <span class="string">"abc"</span>; <span class="comment">// ["a", "b", "c"]</span></span><br><span class="line"><span class="keyword">let</span> [one, two, three] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重学ES5 </tag>
            
            <tag> Desctructuring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps</title>
      <link href="/2019/12/11/DevOps/"/>
      <url>/2019/12/11/DevOps/</url>
      
        <content type="html"><![CDATA[<h1 id="DevOps内容介绍"><a href="#DevOps内容介绍" class="headerlink" title="DevOps内容介绍"></a>DevOps内容介绍</h1><p><img src="/images/1577592770443.jpg" alt="tp"></p><h2 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h2><h3 id="创建SSH"><a href="#创建SSH" class="headerlink" title="创建SSH"></a>创建SSH</h3><p><a href="https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" target="_blank" rel="noopener">创建SSH</a></p><pre><code class="javaScript">$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code></pre><p><img src="/images/1577595253560.jpg" alt="创建公私钥"><br>![创建成功后的两个文件]](/images/1577595434937.jpg)<br><img src="/images/Xnip2019-12-29_13-01-28.jpeg" alt="查看pub文件"><br><img src="/images/1577598053476.jpg" alt="多个githup账户如何操作"></p><blockquote><p>config文件</p></blockquote><pre><code class="javaScript">Host test-github  HostName github.com  User lijinhai255  PreferredAuthentications publickey  IdentityFile /Users/a123/Desktop/project/test/githup_key</code></pre><blockquote><p>下载</p></blockquote><pre><code class="javaScript">git clone git@test-github:lijinhai255/iCSS.git</code></pre><p><img src="/images/1577600773810.jpg" alt="下载成功"></p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><h3 id="拉取更新"><a href="#拉取更新" class="headerlink" title="拉取更新"></a>拉取更新</h3><h2 id="git-flow及团队协作"><a href="#git-flow及团队协作" class="headerlink" title="git flow及团队协作"></a>git flow及团队协作</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h3 id="冲突管理"><a href="#冲突管理" class="headerlink" title="冲突管理"></a>冲突管理</h3><h2 id="gitlab-githbu-gitee等使用-私有部署方案"><a href="#gitlab-githbu-gitee等使用-私有部署方案" class="headerlink" title="gitlab/githbu/gitee等使用,私有部署方案"></a>gitlab/githbu/gitee等使用,私有部署方案</h2>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSR</title>
      <link href="/2019/12/02/SSR/"/>
      <url>/2019/12/02/SSR/</url>
      
        <content type="html"><![CDATA[<h1 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h1><p>服务端渲染及同步</p><h2 id="文件目录介绍"><a href="#文件目录介绍" class="headerlink" title="文件目录介绍"></a>文件目录介绍</h2><p><img src="../static/Xnip2019-12-10_14-19-45.jpg" alt="tp"></p><table><thead><tr><th>文件名称</th><th>作用</th><th>思路</th></tr></thead><tbody><tr><td>src</td><td>react主要的文件</td><td>分别打包成 client server 进行引入</td></tr><tr><td>server</td><td>服务器端执行脚本</td><td>返回渲染的页面</td></tr><tr><td>client</td><td>实现页面交互</td><td>注水  客户端入口 , 只需做事件监听</td></tr><tr><td>bulid</td><td>首屏静态资源</td><td>entry:’./server/index.js’,</td></tr><tr><td>public</td><td>client打包后的静态文件</td><td>entry:’./client/index.js’,</td></tr></tbody></table><p>server 服务器端 请求 返回渲染的页面<br>src  react文件<br>client 页面交互js文件 打包成public<br>bulid 首屏静态资源 js文件</p><h2 id="SSR环境搭建"><a href="#SSR环境搭建" class="headerlink" title="SSR环境搭建"></a>SSR环境搭建</h2><ul><li>初始化醒目<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ssr </span><br><span class="line">de ssh</span><br><span class="line">npm init y</span><br></pre></td></tr></table></figure></li><li>创建webpack文件<br><code>webpack.server.js</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">'webpack-node-externals'</span>)</span><br><span class="line"><span class="comment">// 服务端webpack</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    target:<span class="string">'node'</span>,</span><br><span class="line">    mode:<span class="string">'development'</span>,</span><br><span class="line">    entry:<span class="string">'./server/index.js'</span>,</span><br><span class="line">    output:&#123;</span><br><span class="line">        file:<span class="string">'bundle.js'</span>,</span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'build'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rulses:[&#123;</span><br><span class="line">            text:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                presets:[<span class="string">'@babel/preset-react'</span>,[<span class="string">'@babel/preset-env'</span>]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>安装依赖<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn  install webapck webpack-cli webpack-node-externals @babel/core @babel/preset-env @babel/preset-react -D</span><br></pre></td></tr></table></figure></li><li>创建指令<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">"dev:client"</span>: <span class="string">"webpack --config webpack.client.js --watch"</span>,</span><br><span class="line"><span class="string">"dev:server"</span>: <span class="string">"webpack --config webpack.server.js --watch"</span>,</span><br><span class="line"><span class="string">"dev:start"</span>: <span class="string">"nodemon --watch build --exec node \"./build/bundle.js\""</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="renderToString实现服务器渲染"><a href="#renderToString实现服务器渲染" class="headerlink" title="renderToString实现服务器渲染"></a>renderToString实现服务器渲染</h2><ul><li><p>安装依赖集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add react react-dom express nodemode --save</span><br><span class="line">npm i nodemon -save</span><br></pre></td></tr></table></figure></li><li><p>serve/index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>,</span><br><span class="line"><span class="keyword">import</span> &#123;renderToString&#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span></span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/App'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span>  Page =<span class="xml"><span class="tag">&lt;<span class="name">App</span>&gt;</span><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    // 把 react 解析成html</span></span><br><span class="line"><span class="xml">    const content = renderToString(Page)</span></span><br><span class="line"><span class="xml">    res.send(`</span></span><br><span class="line">    &lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset="utf-8"&gt;</span><br><span class="line">        &lt;title&gt; react ssr&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id="root"&gt;</span><br><span class="line">            $&#123;content&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/html&gt;</span><br><span class="line">    `)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>执行指令</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn  dev:server <span class="comment">// </span></span><br><span class="line">yarn  dev:start <span class="comment">// 启动后端</span></span><br></pre></td></tr></table></figure><h2 id="client-交互js实现"><a href="#client-交互js实现" class="headerlink" title="client 交互js实现"></a>client 交互js实现</h2><ul><li>新建文件 client - index.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/App'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDom.render()  即做dom初始化 也做事件监听</span></span><br><span class="line"><span class="comment">// 注水  客户端入口 , 只需做事件监听</span></span><br><span class="line">ReactDom.hydrate(App, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><h2 id="使用concurrently提升开发体验"><a href="#使用concurrently提升开发体验" class="headerlink" title="使用concurrently提升开发体验"></a>使用concurrently提升开发体验</h2><p>实现多次指令 一次执行</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"start":"concurrently \"npm run dev:client\" \"npm run dev:server\" \"npm run dev:start\"",</span><br></pre></td></tr></table></figure><h2 id="SSR-实现路由"><a href="#SSR-实现路由" class="headerlink" title="SSR 实现路由"></a>SSR 实现路由</h2><table><thead><tr><th>文件名称</th><th>作用</th></tr></thead><tbody><tr><td>client</td><td>使用BrouserRouter</td></tr><tr><td>server</td><td>使用StaticRouter</td></tr></tbody></table><h2 id="使用StaticRouter支持多页面ssr"><a href="#使用StaticRouter支持多页面ssr" class="headerlink" title="使用StaticRouter支持多页面ssr"></a>使用StaticRouter支持多页面ssr</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add react-router-dom --save</span><br></pre></td></tr></table></figure><ul><li><p>App.js<br>设置路由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Route&#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span></span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">"./router/index"</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">"./router/about"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/"</span> exact component=&#123;Index&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">    &lt;Route path=<span class="string">"/about"</span> exact component=&#123;About&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure></li><li><p>服务器端使用StaticRouter</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的node代码会用babel处理</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span></span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/App'</span></span><br><span class="line"><span class="keyword">import</span> &#123; StaticRouter &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="comment">// 设置静态资源目录-- public设置成静态资源目录</span></span><br><span class="line">app.use(express.static(<span class="string">'public'</span>))</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 解析app</span></span><br><span class="line">  <span class="keyword">const</span> content = renderToString(</span><br><span class="line">    &lt;StaticRouter location=&#123;req.url&#125;&gt;</span><br><span class="line">      &#123;App&#125;</span><br><span class="line">  &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">  res.send(`</span></span><br><span class="line"><span class="regexp">    &lt;html&gt;</span></span><br><span class="line"><span class="regexp">      &lt;head&gt;</span></span><br><span class="line"><span class="regexp">        &lt;meta charset="utf-8"/</span>&gt;</span><br><span class="line">        &lt;title&gt;react ssr&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">        &lt;div id=<span class="string">"root"</span>&gt;$&#123;content&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;script src="/</span>bundle.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">      &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">  `)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">app.listen(3003, () =&gt; &#123;</span></span><br><span class="line"><span class="string">  console.log('wacth')</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p>浏览器端使用BrowserRouter</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../src/App'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDom.render()  即做dom初始化 也做事件监听</span></span><br><span class="line"><span class="comment">// 注水  客户端入口 , 只需做事件监听</span></span><br><span class="line"><span class="keyword">const</span> Page = <span class="xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;App&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">ReactDom.hydrate(Page, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure></li></ul><h2 id="09-ssr支持数据流"><a href="#09-ssr支持数据流" class="headerlink" title="09-ssr支持数据流"></a>09-ssr支持数据流</h2><h2 id="实现redux"><a href="#实现redux" class="headerlink" title="实现redux"></a>实现redux</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn add axios --save</span><br><span class="line">yarn add redux --save</span><br><span class="line">yarn add redux-thunk --save</span><br><span class="line">yarn add react-redux --save</span><br></pre></td></tr></table></figure><h2 id="异步获取数据思路"><a href="#异步获取数据思路" class="headerlink" title="异步获取数据思路"></a>异步获取数据思路</h2><h3 id="server层实现数据获取"><a href="#server层实现数据获取" class="headerlink" title="server层实现数据获取"></a>server层实现数据获取</h3><blockquote><p>router index.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//第一步 数据首页显示</span></span><br><span class="line">  props.getIndexList()</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Function</title>
      <link href="/2019/12/02/Function/"/>
      <url>/2019/12/02/Function/</url>
      
        <content type="html"><![CDATA[<h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><p>对于函数而言，经常会用到参数，关于参数的默认值通常都是写在函数体中，如在 ES5 的时候大家都会这么写：</p><pre><code class="javaScript">function f (x, y, z) {    if (y === undefined)        y = 7;    if (z === undefined)        z = 42;    return x + y + z;};f(1) === 50;</code></pre><p>当一个函数有很多参数涉及初始化的时候，这样写代码极其丑陋，所以在 ES6 中改变了对这种知识的写法：</p><pre><code class="javaScript">function f (x, y = 7, z = 42) {    return x + y + z}f(1) === 50</code></pre><blockquote><p>[!TIP]<br>函数参数是从左到右解析，如果没有默认值会被解析成 undefined</p></blockquote><p>如果我们想让具体某个参数使用默认值，我们可以使用 undefined 进行赋值，如下段代码所示：</p><pre><code class="javaScript">function f (x, y = 7, z = 42) {  return x + y + z}console.log(f(1, undefined, 43))// 51</code></pre><p>在ES6中我们不仅可以给参数默认赋值具体的数值，同时参数赋值支持参数的逻辑运算进行赋值，如下段代码所示:</p><pre><code class="javaScript">function f (x, y = 7, z = x + y) {  return z * 0.5}console.log(f(1, 7))// 4</code></pre><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>在函数体内，有时候需要判断函数有几个参数，一共有2个办法。在 ES5 中可以在函数体内使用 arguments 来判断。</p><pre><code class="javaScript">function test (a, b = 1, c) {  console.log(arguments.length)}test(&#39;a&#39;, &#39;b&#39;)//2</code></pre><p>然而在 ES6 中不能再使用 arguments 来判断了，但可以借助 Function.length 来判断。</p><pre><code class="javaScript">function test (a, b = 1, c) {  console.log(test.length)}test(&#39;a&#39;, &#39;b&#39;)// 1</code></pre><p>细心的同学发现 Function.length 结果和 arguments 的结果不同！没错，Function.length 是统计第一个默认参数前面的变量数：</p><pre><code class="javaScript">function test (a = 2, b = 1, c) {  console.log(test.length)}test(&#39;a&#39;, &#39;b&#39;)// 0</code></pre><h2 id="Rest-Parameter"><a href="#Rest-Parameter" class="headerlink" title="Rest Parameter"></a>Rest Parameter</h2><p>在写函数的时候，部分情况我们不是很确定参数有多少个，比如求和运算，之前都是这么做的：</p><pre><code class="javaScript">function sum () {  let num = 0  Array.prototype.forEach.call(arguments, function (item) {    num += item * 1  })  return num}console.log(sum(1, 2, 3))// 6console.log(sum(1, 2, 3, 4))// 10</code></pre><p>其实在上面说过，这个代码在 ES5 中可以这么写，在 ES6 就不能这么写了，因为 arguments 的问题。现在需要这样写：</p><pre><code class="javaScript">function sum (...nums) {  let num = 0  nums.forEach(function (item) {    num += item * 1  })  return num}console.log(sum(1, 2, 3))// 6console.log(sum(1, 2, 3, 4))// 10</code></pre><p>当然，Rest Parameter 也可以和其他参数一起来用，比如：</p><pre><code class="javaSCript">function sum (base, ...nums) {  let num = base  nums.forEach(function (item) {    num += item * 1  })  return num}console.log(sum(30, 1, 2, 3))// 36console.log(sum(30, 1, 2, 3, 4))// 40</code></pre><blockquote><p>[!WARNING]<br>arguments 不是数组，所以不能直接使用数组的原生 API 如 forEach，而 Rest Parameter 是数组，可以直接使用数组的原生 API。</p></blockquote><h2 id="Spread-Operator"><a href="#Spread-Operator" class="headerlink" title="Spread Operator"></a>Spread Operator</h2><p>Spread Operator 和 Rest Parameter 是形似但相反意义的操作符，简单的来说 Rest Parameter 是把不定的参数“收敛”到数组，而 Spread Operator 是把固定的数组内容“打散”到对应的参数。示例如下：</p><pre><code class="javaScript">function sum (x = 1, y = 2, z = 3) {  return x + y + z}console.log(sum(...[4]))// 9console.log(sum(...[4, 5]))// 12console.log(sum(...[4, 5, 6]))// 15</code></pre><p>大家可以好好体会下前面两个示例，<code>Rest Parameter</code> 用来解决函数参数不确定的场景，Spread Operator 用来解决已知参数集合应用到固定参数的函数上，如果没有这个语法，可能需要这样做：</p><pre><code class="javaScript">function sum (x = 1, y = 2, z = 3) {  return x + y + z}console.log(sum.apply(null, [4]))// 9console.log(sum.apply(null, [4, 5]))// 12console.log(sum.apply(null, [4, 5, 6]))// 15</code></pre><p>这种代码是否似曾相识？所以有了 Spread Operator 你的操作将更加简单！</p><h2 id="Arrow-Function"><a href="#Arrow-Function" class="headerlink" title="Arrow Function"></a>Arrow Function</h2><p>箭头函数可以说是 ES6 很大的福利了，不管你是函数式爱好者还是面向对象开发者，函数是必须要用到的东西。之前声明函数需要使用 function，如下：</p><pre><code class="javaScript">function hello () {  console.log(&#39;say hello&#39;)}// 或let hello = function () {  console.log(&#39;say hello&#39;)}</code></pre><p>现在可以这样做</p><pre><code class="javaScript">let hello = () =&gt; {  console.log(&#39;say hello&#39;)}</code></pre><p>如果带参数该怎么做呢？</p><pre><code class="javaScript">let hello = (name) =&gt; {  console.log(&#39;say hello&#39;, name)}// 或者let hello = name =&gt; {  console.log(&#39;say hello&#39;, name)}</code></pre><blockquote><p>[!TIP]<br>如果只有一个参数，可以省略括号，如果大于一个参数一定要记得带括号</p></blockquote><p>函数的声明和参数写的很清楚了，那么对于返回值有什么要注意的地方呢？</p><ul><li>如果返回值是表达式</li></ul><p>如果返回值是表达式可以省略 return 和 {}</p><pre><code class="javaScript">let pow = x =&gt; x * x</code></pre><ul><li>如果返回值是字面量对象<br>如果返回值是字面量对象，一定要用小括号包起来<pre><code class="javaScript">let person = (name) =&gt; ({age: 20,addr: &#39;Beijing City&#39;})</code></pre></li></ul><pre><code>## 拓展看上去箭头函数真的很漂亮，可是它有什么神秘之处吗？this，对，就是它。普通函数和箭头函数对 this 的处理方式是截然不同的。````javaScriptlet test = {  name: &#39;test&#39;,  say: function () {    console.log(this.name)  }}console.log(test.say())// test</code></pre><p>这是用普通函数的写法，say 在被调用之后，this 指向的是调用 say 方法的对象，显示是 test 对象，所以 <code>this === test</code>，那么<code>this.name</code> 也就是 <code>test.name</code>。</p><pre><code class="javaScript">let test = {  name: &#39;test&#39;,  say: () =&gt; {    console.log(this.name, this)  }}console.log(test.say())// undefined</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters" target="_blank" rel="noopener">默认参数</a><br><a href="https://alligator.io/js/rest-parameters-es6/" target="_blank" rel="noopener">rest-parameters</a><br><a href="https://dev.to/sagar/three-dots---in-javascript-26ci" target="_blank" rel="noopener">Three dots ( … ) in JavaScript</a><br>Java在职加薪<br>链接：<a href="https://pan.baidu.com/s/1phoRfArS9wviGhR-8eRtng" target="_blank" rel="noopener">https://pan.baidu.com/s/1phoRfArS9wviGhR-8eRtng</a><br>提取码：8de9<br>Java架构师3大阶段<br>链接：<a href="https://pan.baidu.com/s/1DlXh33y5t4cZUmZH0cLvCw" target="_blank" rel="noopener">https://pan.baidu.com/s/1DlXh33y5t4cZUmZH0cLvCw</a><br>提取码：5s76<br>2019前端架构阶段<br>链接：<a href="https://pan.baidu.com/s/1Vi2NTEVnFHNkA4RKvrcrzw" target="_blank" rel="noopener">https://pan.baidu.com/s/1Vi2NTEVnFHNkA4RKvrcrzw</a><br>提取码：oefy<br>Web系统运维高级架构师大数据2019版带文档<br>链接：<a href="https://pan.baidu.com/s/1Gxpg9J5JI9gwuer1fEUkUw" target="_blank" rel="noopener">https://pan.baidu.com/s/1Gxpg9J5JI9gwuer1fEUkUw</a><br>提取码：okkw<br>Java简历模板<br>链接：<a href="https://pan.baidu.com/s/1I3XBXJ4QmCwvEaOP4WAO0g" target="_blank" rel="noopener">https://pan.baidu.com/s/1I3XBXJ4QmCwvEaOP4WAO0g</a><br>提取码：7ukn<br>Python3数据科学入门与实战<br>链接：<a href="https://pan.baidu.com/s/1AQMxz8j6YE4yy5mTwj-ckQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1AQMxz8j6YE4yy5mTwj-ckQ</a><br>提取码：k5q7<br>实际工作需求文档<br>链接：<a href="https://pan.baidu.com/s/15Xaz80OcmkNMTXJ8EDjsnQ" target="_blank" rel="noopener">https://pan.baidu.com/s/15Xaz80OcmkNMTXJ8EDjsnQ</a><br>提取码：rt8r<br>SpringCloud微服务实战<br>链接：<a href="https://pan.baidu.com/s/108715JLvDKvqmU09UNObRg" target="_blank" rel="noopener">https://pan.baidu.com/s/108715JLvDKvqmU09UNObRg</a><br>提取码：azii<br>300套小程序<br>链接：<a href="https://pan.baidu.com/s/10PMc80j6vSDYMFSIvNB8bQ" target="_blank" rel="noopener">https://pan.baidu.com/s/10PMc80j6vSDYMFSIvNB8bQ</a><br>提取码：aw33<br>Redis入门到高级<br>链接：<a href="https://pan.baidu.com/s/1r8m1-WuRTwTyltCDvxJ6hw" target="_blank" rel="noopener">https://pan.baidu.com/s/1r8m1-WuRTwTyltCDvxJ6hw</a><br>提取码：pis2<br>Google面试官Java面试<br>链接：<a href="https://pan.baidu.com/s/1860stw8CfcU_h3PpOS23zQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1860stw8CfcU_h3PpOS23zQ</a><br>提取码：c1n1<br>前端（一）<br>链接：<a href="https://pan.baidu.com/s/1SnV5KUZao9_CCzOltrio0w" target="_blank" rel="noopener">https://pan.baidu.com/s/1SnV5KUZao9_CCzOltrio0w</a><br>提取码：31xf<br>Java（一）<br>链接：<a href="https://pan.baidu.com/s/1aNXdxWWiaEA65y9G0iweSA" target="_blank" rel="noopener">https://pan.baidu.com/s/1aNXdxWWiaEA65y9G0iweSA</a><br>提取码：7a38<br>新python机器学习<br>链接：<a href="https://pan.baidu.com/s/1ZR-ekC7CDzQ52C4o0kfZKA" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZR-ekC7CDzQ52C4o0kfZKA</a><br>提取码：7adl<br>SpringBoot点餐系统<br>链接：<a href="https://pan.baidu.com/s/1dS50UstBXuEWeflAX63anQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1dS50UstBXuEWeflAX63anQ</a><br>提取码：y8pf<br>从0开始Java开发电商项目<br>链接：<a href="https://pan.baidu.com/s/1EQw5e82FRiFqXimS_SnBFQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1EQw5e82FRiFqXimS_SnBFQ</a><br>提取码：92d9<br>SSM开发大众点评<br>链接：<a href="https://pan.baidu.com/s/1uT5ZHfG0bjh4rBDQGRUYvg" target="_blank" rel="noopener">https://pan.baidu.com/s/1uT5ZHfG0bjh4rBDQGRUYvg</a><br>提取码：lqmy<br>Zookeeper分布式<br>链接：<a href="https://pan.baidu.com/s/14WWMFSa-SwUdBkZW5o7J_w" target="_blank" rel="noopener">https://pan.baidu.com/s/14WWMFSa-SwUdBkZW5o7J_w</a><br>提取码：hzd9<br>面试指导<br>链接：<a href="https://pan.baidu.com/s/1VWfxRKUqbUC4TSVeEBLYpA" target="_blank" rel="noopener">https://pan.baidu.com/s/1VWfxRKUqbUC4TSVeEBLYpA</a><br>提取码：kcam<br>C，C++全栈<br>链接：<a href="https://pan.baidu.com/s/1EptqnL50MNW6ZfNhWV8nGA" target="_blank" rel="noopener">https://pan.baidu.com/s/1EptqnL50MNW6ZfNhWV8nGA</a><br>提取码：xnk9<br>Java算法大全源码包<br>链接：<a href="https://pan.baidu.com/s/1YoR4za5eLaHKXlxKo7vApQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1YoR4za5eLaHKXlxKo7vApQ</a><br>提取码：ghe8<br>小程序教程大全<br>链接：<a href="https://pan.baidu.com/s/1rrQpafidyvBfRb7BgZQ2yA" target="_blank" rel="noopener">https://pan.baidu.com/s/1rrQpafidyvBfRb7BgZQ2yA</a><br>提取码：f3ig<br>前端成长之路<br>链接：<a href="https://pan.baidu.com/s/1onomcQfoCM5ps22ifPskJg" target="_blank" rel="noopener">https://pan.baidu.com/s/1onomcQfoCM5ps22ifPskJg</a><br>提取码：n46s<br>前端面试题<br>链接：<a href="https://pan.baidu.com/s/1EZmJLDjV0UeEaSMeYDJFRQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1EZmJLDjV0UeEaSMeYDJFRQ</a><br>提取码：d5yp<br>前端跳槽技巧<br>链接：<a href="https://pan.baidu.com/s/1aNQbYcJ8IugTmzqkLDa6Lg" target="_blank" rel="noopener">https://pan.baidu.com/s/1aNQbYcJ8IugTmzqkLDa6Lg</a><br>提取码：yjjl<br>Java面试套路<br>链接：<a href="https://pan.baidu.com/s/1lhCsHiXT8EwhOJ7OEIPs-Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1lhCsHiXT8EwhOJ7OEIPs-Q</a><br>提取码：mm1i<br>Java面试突击营<br>链接：<a href="https://pan.baidu.com/s/1lo6wQ_xKQyy-V8oC4G2o2A" target="_blank" rel="noopener">https://pan.baidu.com/s/1lo6wQ_xKQyy-V8oC4G2o2A</a><br>提取码：1tvy<br>9000套网页模板<br>链接：<a href="https://pan.baidu.com/s/1gtwGck3gyi8MbkoyTA9n9Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1gtwGck3gyi8MbkoyTA9n9Q</a><br>提取码：tm7n<br>Java笔试题库<br>链接：<a href="https://pan.baidu.com/s/1rQVRd_6jzbX7_u4NLsvilg" target="_blank" rel="noopener">https://pan.baidu.com/s/1rQVRd_6jzbX7_u4NLsvilg</a><br>提取码：177i<br>300套小程序源码<br>链接：<a href="https://pan.baidu.com/s/1itMrua0ZPVHtZ0tmw3j_DA" target="_blank" rel="noopener">https://pan.baidu.com/s/1itMrua0ZPVHtZ0tmw3j_DA</a><br>提取码：g6r6<br>进入大数据 Spark SQL 的世界<br>链接：<a href="https://pan.baidu.com/s/1_AINgCN8KaQEbnJRkWnKdw" target="_blank" rel="noopener">https://pan.baidu.com/s/1_AINgCN8KaQEbnJRkWnKdw</a><br>提取码：7j85<br>Java深入微服务原理改造房产销售平台<br>链接：<a href="https://pan.baidu.com/s/1O7VE9AOB8AKaYYp0d1HOrw" target="_blank" rel="noopener">https://pan.baidu.com/s/1O7VE9AOB8AKaYYp0d1HOrw</a><br>提取码：2f9i<br>表白神器链接：<a href="https://pan.baidu.com/s/1EXK0BYqX-gXuhZGOWWB8zg" target="_blank" rel="noopener">https://pan.baidu.com/s/1EXK0BYqX-gXuhZGOWWB8zg</a> 密码：m3ih<br>超实用前端资料链接：<a href="https://pan.baidu.com/s/1dzMNAgTWpmCDezHptpg_ig" target="_blank" rel="noopener">https://pan.baidu.com/s/1dzMNAgTWpmCDezHptpg_ig</a><br>提取码：7hcj<br>JS设计模式全解链接：<a href="https://pan.baidu.com/s/1G4jMHzWmVG_AioqN7I0rFQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1G4jMHzWmVG_AioqN7I0rFQ</a><br>提取码：uti9<br>疑难问题解决方案链接：<a href="https://pan.baidu.com/s/1cHivqaloYo0l4UL6ZHEP2w" target="_blank" rel="noopener">https://pan.baidu.com/s/1cHivqaloYo0l4UL6ZHEP2w</a><br>提取码：2lof<br>玩转算法<br>链接：<a href="https://pan.baidu.com/s/1gTGwVegBWmMntr7TJZMbyw" target="_blank" rel="noopener">https://pan.baidu.com/s/1gTGwVegBWmMntr7TJZMbyw</a><br>提取码：pywv<br>大数据视频和资料：<br>链接: <a href="https://pan.baidu.com/s/1bqUXYKf" target="_blank" rel="noopener">https://pan.baidu.com/s/1bqUXYKf</a> 密码: k38w<br>React Native项目实战<br>链接：<a href="https://pan.baidu.com/s/15-hC110OoVTQOiBczsb_WA" target="_blank" rel="noopener">https://pan.baidu.com/s/15-hC110OoVTQOiBczsb_WA</a><br>提取码：8mk7<br>React 贯穿全栈开发APP<br>链接：<a href="https://pan.baidu.com/s/1JgcdhfguEvYhlVFsgkzIEA" target="_blank" rel="noopener">https://pan.baidu.com/s/1JgcdhfguEvYhlVFsgkzIEA</a><br>提取码：a3yf<br>Java并发编程<br>链接：<a href="https://pan.baidu.com/s/1VKAN7wTnpKo7PN3QXywa5A" target="_blank" rel="noopener">https://pan.baidu.com/s/1VKAN7wTnpKo7PN3QXywa5A</a><br>提取码：hznr<br>前端视频和资料：<br> 链接: <a href="https://pan.baidu.com/s/1gfjxHL5" target="_blank" rel="noopener">https://pan.baidu.com/s/1gfjxHL5</a> 密码: hjua<br>Python高级编程技巧<br>链接：<a href="https://pan.baidu.com/s/1adz1uuxBOdelVeXAN0SC5g" target="_blank" rel="noopener">https://pan.baidu.com/s/1adz1uuxBOdelVeXAN0SC5g</a><br>提取码：evxr<br>bootstrap视频和资料：<br>链接：<a href="https://pan.baidu.com/s/1luqC5W0GBsqBfgRG2LuOMQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1luqC5W0GBsqBfgRG2LuOMQ</a> 密码：48w3<br>面试经验指导链接：<a href="https://pan.baidu.com/s/1DSDLCWW5T_PQ8zsf5LMkCQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1DSDLCWW5T_PQ8zsf5LMkCQ</a><br>提取码：r7qv<br>0基础入门安卓<br>链接：<a href="https://pan.baidu.com/s/1VcuZ8im8p5lDSw1izaQBIw" target="_blank" rel="noopener">https://pan.baidu.com/s/1VcuZ8im8p5lDSw1izaQBIw</a><br>提取码：a38m<br>第一套软件测试教程<br>链接：<a href="https://pan.baidu.com/s/1igq6HbJYK_11eG1XiSoIBQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1igq6HbJYK_11eG1XiSoIBQ</a><br>提取码：7d6b<br>软件测试指导<br>链接：<a href="https://pan.baidu.com/s/1uqSzKXVuAgg8JET0aoN3Nw" target="_blank" rel="noopener">https://pan.baidu.com/s/1uqSzKXVuAgg8JET0aoN3Nw</a><br>提取码：t1qo<br>高级架构师进阶<br>链接：<a href="https://pan.baidu.com/s/19r5i1FdXW6glSy2ZQ71eFA" target="_blank" rel="noopener">https://pan.baidu.com/s/19r5i1FdXW6glSy2ZQ71eFA</a><br>提取码：czb4 </p><p>python视频和资料：<br>链接: <a href="https://pan.baidu.com/s/1jJQaagA" target="_blank" rel="noopener">https://pan.baidu.com/s/1jJQaagA</a> 密码: e1gm<br>Java开发人工智能远程监控<br>链接：<a href="https://pan.baidu.com/s/1x2uzAHscTLf8t-G_3LrXLw" target="_blank" rel="noopener">https://pan.baidu.com/s/1x2uzAHscTLf8t-G_3LrXLw</a><br>提取码：b0hn<br>PPT2000套<br>链接：<a href="https://pan.baidu.com/s/1HH50bYZBc659scz8SROiHQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1HH50bYZBc659scz8SROiHQ</a><br>提取码：13h3<br>SSH个人理财系统<br>链接：<a href="https://pan.baidu.com/s/1-BybATsIfRR4TU7Z-PlAaQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1-BybATsIfRR4TU7Z-PlAaQ</a><br>提取码：5a99<br>Python全套（内有爬虫）<br>链接：<a href="https://pan.baidu.com/s/1GdOxS1nqNv2t33C6dS6tmA" target="_blank" rel="noopener">https://pan.baidu.com/s/1GdOxS1nqNv2t33C6dS6tmA</a><br>提取码：g19z<br>CMR系统<br>链接：<a href="https://pan.baidu.com/s/1NfKOLfudJqbE-gTd8SUuzQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1NfKOLfudJqbE-gTd8SUuzQ</a><br>提取码：fjq3<br>Spring源码解析<br>链接：<a href="https://pan.baidu.com/s/1zOHWBUyVsLfn4NGmN6etvw" target="_blank" rel="noopener">https://pan.baidu.com/s/1zOHWBUyVsLfn4NGmN6etvw</a><br>提取码：i8gd<br>Hadoop视频和资料：<br> 链接：<a href="https://pan.baidu.com/s/1wjhXxD3-ZuoRHv0tRLsP8w" target="_blank" rel="noopener">https://pan.baidu.com/s/1wjhXxD3-ZuoRHv0tRLsP8w</a> 密码：y075<br>软件方法论<br>链接：<a href="https://pan.baidu.com/s/1JcqLQS4jIDNHwcZ8rlv95g" target="_blank" rel="noopener">https://pan.baidu.com/s/1JcqLQS4jIDNHwcZ8rlv95g</a><br>提取码：9p8h<br>基于Spring团购项目链接：<br><a href="https://pan.baidu.com/s/12oqsuKtR46etIWYs2KpH8A" target="_blank" rel="noopener">https://pan.baidu.com/s/12oqsuKtR46etIWYs2KpH8A</a><br>提取码：8yzq<br>Linux指导<br>链接：<a href="https://pan.baidu.com/s/1RfFQWLu_VmkSYHp4Aj2RVg" target="_blank" rel="noopener">https://pan.baidu.com/s/1RfFQWLu_VmkSYHp4Aj2RVg</a><br>提取码：9t8i<br>JavaEE实战<br>链接：<a href="https://pan.baidu.com/s/1Fk8JM8gzNBamvbxLnJ-2ow" target="_blank" rel="noopener">https://pan.baidu.com/s/1Fk8JM8gzNBamvbxLnJ-2ow</a><br>提取码：semf<br>mysql视频和资料：<br>链接：<a href="https://pan.baidu.com/s/14EoVSlWFwAEzsa8-XC61-A" target="_blank" rel="noopener">https://pan.baidu.com/s/14EoVSlWFwAEzsa8-XC61-A</a> 密码：6cde<br>宅急送项目<br>链接：<a href="https://pan.baidu.com/s/1UQbC8H0B5QqOimfOq2W2Kg" target="_blank" rel="noopener">https://pan.baidu.com/s/1UQbC8H0B5QqOimfOq2W2Kg</a><br>提取码：oz3h<br>Java开发二维码<br>链接：<a href="https://pan.baidu.com/s/1MeERyivNIJOaFznLUATEBA" target="_blank" rel="noopener">https://pan.baidu.com/s/1MeERyivNIJOaFznLUATEBA</a><br>提取码：yd6d<br>开发云盘<br>链接：<a href="https://pan.baidu.com/s/1yq5BbW-Hu19XCYyxnJZHHg" target="_blank" rel="noopener">https://pan.baidu.com/s/1yq5BbW-Hu19XCYyxnJZHHg</a><br>提取码：di81<br>在线支付系统<br>链接：<a href="https://pan.baidu.com/s/1iCzfUMQgE25KmaVix4c_Ig" target="_blank" rel="noopener">https://pan.baidu.com/s/1iCzfUMQgE25KmaVix4c_Ig</a><br>提取码：u6bw<br>Java开发音频播放器<br>链接：<a href="https://pan.baidu.com/s/1LD4WajbwkGajDRmYAdqX7A" target="_blank" rel="noopener">https://pan.baidu.com/s/1LD4WajbwkGajDRmYAdqX7A</a><br>提取码：lxx5<br>高并发程序设计<br>链接：<a href="https://pan.baidu.com/s/1HpWceif04YiUVd_LvQCFiA" target="_blank" rel="noopener">https://pan.baidu.com/s/1HpWceif04YiUVd_LvQCFiA</a><br>提取码：bj3u<br>数据分析视频和资料：<br> 链接：<a href="https://pan.baidu.com/s/19t389HP0bx2RJdK6GlTQOA" target="_blank" rel="noopener">https://pan.baidu.com/s/19t389HP0bx2RJdK6GlTQOA</a> 密码：gezo<br>Lonic3多平台开发企业级社区平台链接：<br>链接：<a href="https://pan.baidu.com/s/15NPZG_CnPkisup_0wpez-g" target="_blank" rel="noopener">https://pan.baidu.com/s/15NPZG_CnPkisup_0wpez-g</a><br>提取码：nbzv<br>高并发商城<br>链接：<a href="https://pan.baidu.com/s/1_TBNzl3uBxIFYfwzPZEPrw" target="_blank" rel="noopener">https://pan.baidu.com/s/1_TBNzl3uBxIFYfwzPZEPrw</a><br>提取码：6cmm<br>自动化测试Selenium<br>链接：<a href="https://pan.baidu.com/s/1gW2FcR5mcgguVg4w05S2vQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1gW2FcR5mcgguVg4w05S2vQ</a><br>提取码：ksxo<br>让你的页面性能飞起来<br>链接：<a href="https://pan.baidu.com/s/1Lx4mhEK3bygVGWzjMequCg" target="_blank" rel="noopener">https://pan.baidu.com/s/1Lx4mhEK3bygVGWzjMequCg</a><br>提取码：1w12<br>Netty开发聊天系统<br>链接：<a href="https://pan.baidu.com/s/1IbkUVZ82HvRZLFfoP0eYlQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1IbkUVZ82HvRZLFfoP0eYlQ</a><br>提取码：lbno<br>报名系统<br>链接：<a href="https://pan.baidu.com/s/1m1L4shEaGHi_aaRuwHlUeQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1m1L4shEaGHi_aaRuwHlUeQ</a><br>提取码：36o3<br>go语言视频和资料：<br>链接：<a href="https://pan.baidu.com/s/1bIqDCXld1oHxHTqfhx6Acw" target="_blank" rel="noopener">https://pan.baidu.com/s/1bIqDCXld1oHxHTqfhx6Acw</a> 密码：xp6v<br>手机端开发视频和资料：<br>链接：<a href="https://pan.baidu.com/s/1z8Q2bZ_ZYzLbjIHRqVjrvQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1z8Q2bZ_ZYzLbjIHRqVjrvQ</a> 密码：1xgt<br>scale视频和资料：<br>链接：<a href="https://pan.baidu.com/s/1IOX-gjWJtWam3XYZk9l6BQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1IOX-gjWJtWam3XYZk9l6BQ</a> 密码：euql<br>微服务气象实战：<br>链接：<a href="https://pan.baidu.com/s/1A-9DPRPK7D3d2KcocZwRig" target="_blank" rel="noopener">https://pan.baidu.com/s/1A-9DPRPK7D3d2KcocZwRig</a><br>提取码：qz2f<br>spark视频和资料：<br>链接：<a href="https://pan.baidu.com/s/1IOX-gjWJtWam3XYZk9l6BQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1IOX-gjWJtWam3XYZk9l6BQ</a> 密码：euql<br>响应式一招开发制胜<br>链接：<a href="https://pan.baidu.com/s/1yLxWwW2Ql0fo0R-p8mt_qw" target="_blank" rel="noopener">https://pan.baidu.com/s/1yLxWwW2Ql0fo0R-p8mt_qw</a><br>提取码：r52v<br>四大维度解锁Webpack3.0前端工程化<br>链接：<a href="https://pan.baidu.com/s/1svUZaIruItMV8NPAMzW-cw" target="_blank" rel="noopener">https://pan.baidu.com/s/1svUZaIruItMV8NPAMzW-cw</a><br>提取码：uwe7<br>SVN视频和资料：<br>链接：<a href="https://pan.baidu.com/s/1QOXjJNF0_BOLN2hePal5_g" target="_blank" rel="noopener">https://pan.baidu.com/s/1QOXjJNF0_BOLN2hePal5_g</a> 密码：1way<br>网上商城Extjs4.1+Spring3.2+hibernate4.1+MySql5（视频+源码）：<br>链接：<a href="https://pan.baidu.com/s/1wQAGwXBDK5XmZCl_J29Qug" target="_blank" rel="noopener">https://pan.baidu.com/s/1wQAGwXBDK5XmZCl_J29Qug</a><br>提取码：xyme<br>vue.js高仿饿了么<br>链接：<a href="https://pan.baidu.com/s/1uqBpqttmP_jCZoao57Gz9g" target="_blank" rel="noopener">https://pan.baidu.com/s/1uqBpqttmP_jCZoao57Gz9g</a><br>提取码：km8w<br>大型SpringMVC，Mybatis，Redis，Solr，Nginx，SSM分布式电商项目视频教程<br>链接：<a href="https://pan.baidu.com/s/1m71jc-K-0xfJ3zC6Au_byQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1m71jc-K-0xfJ3zC6Au_byQ</a><br>提取码：tjpx<br>Spring Cloud<br>链接：<a href="https://pan.baidu.com/s/1EkZwDVcqLY8OZ42NxHEuPA" target="_blank" rel="noopener">https://pan.baidu.com/s/1EkZwDVcqLY8OZ42NxHEuPA</a><br>提取码：18nj</p><p>第一套前端全套视频和源码：<br>链接：<a href="https://pan.baidu.com/s/1-eTjKfe1Ozge0YccblhY4w" target="_blank" rel="noopener">https://pan.baidu.com/s/1-eTjKfe1Ozge0YccblhY4w</a> 密码：eyxs<br>第二套前端全套视频和源码：<br>链接：<a href="https://pan.baidu.com/s/1e6OC7fBWWQuzU6sGDj0Spw" target="_blank" rel="noopener">https://pan.baidu.com/s/1e6OC7fBWWQuzU6sGDj0Spw</a> 密码：p8qm<br>第三套前端全套视频和源码：<br>链接：<a href="https://pan.baidu.com/s/1rd6gB64fS17ylqi3A9IA-w" target="_blank" rel="noopener">https://pan.baidu.com/s/1rd6gB64fS17ylqi3A9IA-w</a> 密码：egy5<br>PHP全套第一套视频和资料：<br>链接：<a href="https://pan.baidu.com/s/13DCQxHpLos6VcB6gY5LZSw" target="_blank" rel="noopener">https://pan.baidu.com/s/13DCQxHpLos6VcB6gY5LZSw</a> 密码：tmqq<br>PHP全套第二套视频和资料：<br>链接：<a href="https://pan.baidu.com/s/18GF5u8Z4PploD2lYFgs_Ww" target="_blank" rel="noopener">https://pan.baidu.com/s/18GF5u8Z4PploD2lYFgs_Ww</a> 密码：l84u<br>Web自动化测试 Selenium基础到企业应用<br>链接：<a href="https://pan.baidu.com/s/1XAuKpMXenB9qs1QNMF9g-Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1XAuKpMXenB9qs1QNMF9g-Q</a><br>提取码：2xew<br>京东手机端制作视频和源码：<br>链接：<a href="https://pan.baidu.com/s/1GcCgnuYoZoOUadA8IpiywA" target="_blank" rel="noopener">https://pan.baidu.com/s/1GcCgnuYoZoOUadA8IpiywA</a> 密码：o7z9<br>基于Laravel，AngularJS全栈开发知乎<br>链接：<a href="https://pan.baidu.com/s/1MKwxwY6GmHJIdT2d3s_F2Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1MKwxwY6GmHJIdT2d3s_F2Q</a><br>提取码：uvv7<br>强力django+杀手级xadmin 打造上线标准的在线教育平台<br>链接：<a href="https://pan.baidu.com/s/1enDpWa6jmRh5FR5cMvTFJQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1enDpWa6jmRh5FR5cMvTFJQ</a><br>提取码：bfwy<br>前端 Vue+Node+MongoDB高级全栈开发<br>链接：<a href="https://pan.baidu.com/s/1EpuXIb7kpVc_7VrstTMWRg" target="_blank" rel="noopener">https://pan.baidu.com/s/1EpuXIb7kpVc_7VrstTMWRg</a><br>提取码：8vcp<br>电商秒杀活动视频和源码<br>链接：<a href="https://pan.baidu.com/s/1RHHV8SOC7Q9BnPRTSVWYNg" target="_blank" rel="noopener">https://pan.baidu.com/s/1RHHV8SOC7Q9BnPRTSVWYNg</a> 密码：ze4h<br>Web自动化测试 Selenium基础到企业应用<br>链接：<a href="https://pan.baidu.com/s/1IlcpX_iHrC2b3d3lyJbZ4w" target="_blank" rel="noopener">https://pan.baidu.com/s/1IlcpX_iHrC2b3d3lyJbZ4w</a><br>提取码：23jb<br>Nginx<br>链接：<a href="https://pan.baidu.com/s/1fRjIbk-rsL0HBo1WWaM-OQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1fRjIbk-rsL0HBo1WWaM-OQ</a><br>提取码：5z3a<br>麦子商城制作视频和源码：<br>链接：<a href="https://pan.baidu.com/s/1DpoF958TsQwdqYGK7r34lw" target="_blank" rel="noopener">https://pan.baidu.com/s/1DpoF958TsQwdqYGK7r34lw</a> 密码：5ab6<br>前端到后台ThinkPHP开发整站<br>链接：<a href="https://pan.baidu.com/s/1FZa8O03NLEOdSeqqb_HgEw" target="_blank" rel="noopener">https://pan.baidu.com/s/1FZa8O03NLEOdSeqqb_HgEw</a><br>提取码：3km2<br>快速上手Linux 玩转典型应用<br>链接：<a href="https://pan.baidu.com/s/1dPZA47vku2eYQY_PhfCOtg" target="_blank" rel="noopener">https://pan.baidu.com/s/1dPZA47vku2eYQY_PhfCOtg</a><br>提取码：2rdm<br>Vue核心技术 vue实战精讲<br> 链接：<a href="https://pan.baidu.com/s/1sHStCWy4XJWflft6H_qAKA" target="_blank" rel="noopener">https://pan.baidu.com/s/1sHStCWy4XJWflft6H_qAKA</a><br>提取码：0ybr<br>天猫商城购物车实战视频资料：<br>链接：<a href="https://pan.baidu.com/s/1UxtMqsszcAKpZ_2a41raSQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1UxtMqsszcAKpZ_2a41raSQ</a> 密码：c1rd<br>移动端混合APP视频和资料：<br>链接：<a href="https://pan.baidu.com/s/1bwDYjR8UMk5pgpvPcxWBfA" target="_blank" rel="noopener">https://pan.baidu.com/s/1bwDYjR8UMk5pgpvPcxWBfA</a> 密码：tkyj<br>企业级网站前端制作视频和源码：<br>链接：<a href="https://pan.baidu.com/s/1joNyOi5CegvJW4G-UeBODA" target="_blank" rel="noopener">https://pan.baidu.com/s/1joNyOi5CegvJW4G-UeBODA</a> 密码：wock<br>企业级网站后台制作视频和源码：<br>链接：<a href="https://pan.baidu.com/s/1769hXRG6OnWOfpZWwMpA-w" target="_blank" rel="noopener">https://pan.baidu.com/s/1769hXRG6OnWOfpZWwMpA-w</a> 密码：k2wn<br>OA办公自动化项目<br>链接：<a href="https://pan.baidu.com/s/1YqRWtnWJZAFNNCf_Z2SLtA" target="_blank" rel="noopener">https://pan.baidu.com/s/1YqRWtnWJZAFNNCf_Z2SLtA</a><br>密码：ccj9<br>CRM客户管理项目<br>链接：<a href="https://pan.baidu.com/s/1I-OJSE-VXbX9dm8aN0QP4w" target="_blank" rel="noopener">https://pan.baidu.com/s/1I-OJSE-VXbX9dm8aN0QP4w</a><br>密码：o1vv<br>宅急送项目<br>链接：<a href="https://pan.baidu.com/s/1VFJ7TTwApFUZsQQnogjr-A" target="_blank" rel="noopener">https://pan.baidu.com/s/1VFJ7TTwApFUZsQQnogjr-A</a><br>密码：phtf<br>校园网项目<br>链接：<a href="https://pan.baidu.com/s/1H4nUEtw3-WKVN78b6TuklA" target="_blank" rel="noopener">https://pan.baidu.com/s/1H4nUEtw3-WKVN78b6TuklA</a><br> 密码：87gc<br>Java邮件开发教程<br>链接：<a href="https://pan.baidu.com/s/1ZpLoacAYhk4v8_PzyGzxIg" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZpLoacAYhk4v8_PzyGzxIg</a><br>密码：yzsb<br>Java网上在线支付实战视频<br>链接：<a href="https://pan.baidu.com/s/1t3DjD7Fa7Vv66wyTND2ddQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1t3DjD7Fa7Vv66wyTND2ddQ</a><br>密码：3q1o<br>俄罗斯方块游戏开发视频教程<br>链接：<a href="https://pan.baidu.com/s/1_qXE5PpkEA3h2BX9dz64Bw" target="_blank" rel="noopener">https://pan.baidu.com/s/1_qXE5PpkEA3h2BX9dz64Bw</a><br>密码：jat1<br>银行业务调度系统视频教程<br>链接：<a href="https://pan.baidu.com/s/18cZZ22va495qjlAAU4jFzA" target="_blank" rel="noopener">https://pan.baidu.com/s/18cZZ22va495qjlAAU4jFzA</a><br>密码：w6ri<br>供应链系统视频教程<br>链接：<a href="https://pan.baidu.com/s/1TfV2dfrLnUAYlCVG8ppOlA" target="_blank" rel="noopener">https://pan.baidu.com/s/1TfV2dfrLnUAYlCVG8ppOlA</a><br>密码：hpz8<br>网上商城项目<br>链接：<a href="https://pan.baidu.com/s/1nHpOCPTinMDOhi07YFRR4w" target="_blank" rel="noopener">https://pan.baidu.com/s/1nHpOCPTinMDOhi07YFRR4w</a><br>密码：xrz0<br>药品集中采购视频教程<br>链接：<a href="https://pan.baidu.com/s/1i4xffBJjF-dwFC-QhrZA0g" target="_blank" rel="noopener">https://pan.baidu.com/s/1i4xffBJjF-dwFC-QhrZA0g</a><br>密码：mwtw<br>杰信商贸ssm版<br>链接：<a href="https://pan.baidu.com/s/1m0EmptzKd7WDpYQ_i5fa4Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1m0EmptzKd7WDpYQ_i5fa4Q</a><br>密码：yukp<br>国家税务协同平台项目<br>链接：<a href="https://pan.baidu.com/s/1VkFTRv4DfKShN4VrlZyxdA" target="_blank" rel="noopener">https://pan.baidu.com/s/1VkFTRv4DfKShN4VrlZyxdA</a><br>密码：runc<br>Javaweb聊天室<br>链接：<a href="https://pan.baidu.com/s/1qKyQEzRABYDXAOK7Mx8XDQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1qKyQEzRABYDXAOK7Mx8XDQ</a><br>密码：evf5<br>网上书店<br>链接：<a href="https://pan.baidu.com/s/1Ya2NhTvoSNWthhCAvHUnSw" target="_blank" rel="noopener">https://pan.baidu.com/s/1Ya2NhTvoSNWthhCAvHUnSw</a><br>密码：82od<br>手机进销存系统<br>链接：<a href="https://pan.baidu.com/s/1SgZnAA_OhOZEjlB4Tr5GRA" target="_blank" rel="noopener">https://pan.baidu.com/s/1SgZnAA_OhOZEjlB4Tr5GRA</a><br>密码：lbng<br>QQ聊天器<br>链接：<a href="https://pan.baidu.com/s/1G1CX_GerVYMYWI3y7bbJRQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1G1CX_GerVYMYWI3y7bbJRQ</a><br>密码：yvbn<br>坦克大战<br>链接：<a href="https://pan.baidu.com/s/1iQD04fXlCqrSG1Ezna_iqg" target="_blank" rel="noopener">https://pan.baidu.com/s/1iQD04fXlCqrSG1Ezna_iqg</a><br>密码：fjtv<br>五子棋游戏<br>链接：<a href="https://pan.baidu.com/s/1Nwau0LZyWxAWp6Yqmsz0fw" target="_blank" rel="noopener">https://pan.baidu.com/s/1Nwau0LZyWxAWp6Yqmsz0fw</a><br>密码：pw1l<br>报名系统<br>链接：<a href="https://pan.baidu.com/s/1bpJwXzysEgiOfLmULBMBOQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1bpJwXzysEgiOfLmULBMBOQ</a><br>密码：vm11<br>OA供应链系统<br>链接：<a href="https://pan.baidu.com/s/1YBoNDKUmmRg-ycTMKxeMNg" target="_blank" rel="noopener">https://pan.baidu.com/s/1YBoNDKUmmRg-ycTMKxeMNg</a><br>密码：kr6t<br>用户管理系统<br>链接：<a href="https://pan.baidu.com/s/1-LO1aDSdC0Kxy0c7ZNU_Bg" target="_blank" rel="noopener">https://pan.baidu.com/s/1-LO1aDSdC0Kxy0c7ZNU_Bg</a><br>密码：2wlf<br>Java web网上图书商城·完整项目<br>链接：<a href="https://pan.baidu.com/s/1tjmhDwGAn3Mdsof0Iu-efA" target="_blank" rel="noopener">https://pan.baidu.com/s/1tjmhDwGAn3Mdsof0Iu-efA</a><br>密码：k3sx<br>VIP商场<br>链接：<a href="https://pan.baidu.com/s/1n3DuWFFIyyRzGI2RxR7jsw" target="_blank" rel="noopener">https://pan.baidu.com/s/1n3DuWFFIyyRzGI2RxR7jsw</a><br>密码：q8zt<br>《企业招聘系统》视频-jeecg开源频台<br>链接：<a href="https://pan.baidu.com/s/12b_V2LxoBoEP7EWK4Kc_Ew" target="_blank" rel="noopener">https://pan.baidu.com/s/12b_V2LxoBoEP7EWK4Kc_Ew</a><br>密码：20sd<br>博客系统项目<br>链接：<a href="https://pan.baidu.com/s/1xGTxVPr-tijhyZPup54Euw" target="_blank" rel="noopener">https://pan.baidu.com/s/1xGTxVPr-tijhyZPup54Euw</a><br>密码：4em4<br>超级玛丽<br>链接：<a href="https://pan.baidu.com/s/1Xr3S8Q4DKPoYQkNaW6oOuA" target="_blank" rel="noopener">https://pan.baidu.com/s/1Xr3S8Q4DKPoYQkNaW6oOuA</a><br>密码：aw9z<br>成绩管理系统<br>链接：<a href="https://pan.baidu.com/s/1ilvozGK8oB_-j5bhlvcB7w" target="_blank" rel="noopener">https://pan.baidu.com/s/1ilvozGK8oB_-j5bhlvcB7w</a><br>密码：l4v2<br>个人理财系统<br>链接：<a href="https://pan.baidu.com/s/1uBY0ym-8jrNTn9ues_a-aw" target="_blank" rel="noopener">https://pan.baidu.com/s/1uBY0ym-8jrNTn9ues_a-aw</a><br>密码：lbpc<br>人事管理系统项目实战视频<br>链接：<a href="https://pan.baidu.com/s/1wCNWOG-xaLb1yAvsIdK5Og" target="_blank" rel="noopener">https://pan.baidu.com/s/1wCNWOG-xaLb1yAvsIdK5Og</a><br>密码：3ayb<br>JBPM采购申请系统<br>链接：<a href="https://pan.baidu.com/s/1tZdSrIIYH4bnZrMBOBqGHg" target="_blank" rel="noopener">https://pan.baidu.com/s/1tZdSrIIYH4bnZrMBOBqGHg</a><br>密码：0su2</p>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
            <tag> 重学ES5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grid</title>
      <link href="/2019/12/02/grid/"/>
      <url>/2019/12/02/grid/</url>
      
        <content type="html"><![CDATA[<h1 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h1><h2 id="CSS网格布局简介"><a href="#CSS网格布局简介" class="headerlink" title="CSS网格布局简介"></a>CSS网格布局简介</h2><p><code>table=&gt; float=&gt; position=&gt; inlne=&gt; FlexBox=&gt; Grid</code></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="容器-Grid-Container"><a href="#容器-Grid-Container" class="headerlink" title="容器 Grid Container"></a>容器 Grid Container</h3><p>采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。</p><pre><code class="html">&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;item&quot;&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt;  &lt;div class=&quot;item&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt;  &lt;div class=&quot;item&quot;&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.container{  display:grid}</code></pre><p>上面代码中，最外层的<div>元素就是容器，内层的三个<div>元素就是项目。</p><p>注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的<p>元素就不是项目。Grid 布局只对项目生效。</p><h3 id="项目-Grid-Item"><a href="#项目-Grid-Item" class="headerlink" title="项目 Grid Item"></a>项目 Grid Item</h3><h3 id="网格线-Grid-Line"><a href="#网格线-Grid-Line" class="headerlink" title="网格线 Grid Line"></a>网格线 Grid Line</h3><p>划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。</p><p>正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线，比如三行就有四根水平网格线。<br><img src="/images/1_bg2019032503.png" alt="tp"></p><h3 id="网格轨道-Grid-Track"><a href="#网格轨道-Grid-Track" class="headerlink" title="网格轨道  Grid Track"></a>网格轨道  Grid Track</h3><p>两个相邻的网格线之间为网格轨道</p><h3 id="网格单元-Grid-Cell"><a href="#网格单元-Grid-Cell" class="headerlink" title="网格单元 Grid Cell"></a>网格单元 Grid Cell</h3><p>两个 相邻的列网格线和两个相邻的行网格线组成的是网格单元</p><h3 id="网格区域-Grid-Area"><a href="#网格区域-Grid-Area" class="headerlink" title="网格区域 Grid Area"></a>网格区域 Grid Area</h3><p>四个网格线包围的总空间</p><h3 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h3><ul><li>fr(单位)<br>剩余空间分配数。 用于在一系列长度值中分配剩余空间，如果多个已指定了多个部分，则剩下的空间根据格子的数字按比例分配。</li></ul><h3 id="gr-单位"><a href="#gr-单位" class="headerlink" title="gr(单位)"></a>gr(单位)</h3><p>网格数</p><h3 id="行和列"><a href="#行和列" class="headerlink" title="行和列"></a>行和列</h3><p>容器里面的水平区域称为”行”（row），垂直区域称为”列”（column）。</p><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。</p><h3 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h3><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><p><strong>注意</strong> 当元素设置网格布局，column 、float 、 clear 、 vertical-align属性无效<br>display:subgrid 目前所有浏览器都不兼容</p><p><code>display:grid|inline-grid|subgrid</code></p><p>将元素定义为<code>grid container</code>,并为其内容建立新的网格格式化上下文(grid formatting context)</p><pre><code class="html">&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;  &lt;div class=&quot;item&quot;&gt;2&lt;/div&gt;  &lt;div class=&quot;item&quot;&gt;3&lt;/div&gt;  &lt;div class=&quot;item&quot;&gt;4&lt;/div&gt;  &lt;div class=&quot;item&quot;&gt;5&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.container{  display:grid/*块级网格*/ | inline-grid /*行内网格*/| subgrid(如果网格容器本身是  网格项(嵌套网格容器)，此属性用来继承其父网格容器的列行大小)}</code></pre><h4 id="grid-template"><a href="#grid-template" class="headerlink" title="grid-template"></a>grid-template</h4><blockquote><p>grid-template-columns/ grid-template-rows  使用以空格分割多个值来定义网格的列和行</p></blockquote><pre><code class="css">.container{  grid-template-columns:&lt;track-size&gt;....| &lt;line-name&gt; &lt;track-size&gt;...  grid-template-row:&lt;track-size&gt;....| &lt;line-name&gt; &lt;track-size&gt;...;}</code></pre><h5 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h5><ul><li>轨道大小(track-size): 可以使用css长度(px em等) 、百分比或用百分比（用fr单位）</li></ul><p><img src="/images/Xnip2019-12-20_14-09-44.jpeg" alt="tp"></p><ul><li>网格线名称(line-name) :可以选择任何名字</li></ul><p><img src="/images/1576823538820.jpg" alt="tp1"></p><h4 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h4><p>通过引用 grid-area  属性 指定网络区域的名称来定义网络模版。</p><ul><li><grid-area-name>: 使用grid-area属性设置的网格区域名称</li><li>“.”:点号表示一个空网格单元</li><li>none ： 没有定义的网格区域</li></ul><pre><code class="css">.container{  grid-template-areas:none |  &quot;grid-area-name|.grid-area-name|.grid-area-name|. ...&quot;   &quot;grid-area-name|.grid-area-name|.grid-area-name|. ...&quot;}</code></pre><p><img src="/images/Xnip2019-12-20_14-40-13.jpeg" alt="ti"><br><img src="/images/Xnip2019-12-20_14-49-36.jpeg" alt="tu1"><br><img src="/images/Xnip2019-12-20_15-42-26.jpeg" alt="tu2"></p><h5 id="grid-template-1"><a href="#grid-template-1" class="headerlink" title="grid-template"></a>grid-template</h5><p><img src="/images/Xnip2019-12-20_15-53-30.jpeg" alt="tu1"></p><h4 id="gap"><a href="#gap" class="headerlink" title="gap"></a>gap</h4><p><strong>grid-column-gap/grid-row-gap</strong> 指定网格线的大小，可以想象设置列/行之间的间距的宽度</p><pre><code class="css">.container{  grid-column-gap:&lt;linr-size&gt;;  grid-row-gap:&lt;line-size&gt;;}</code></pre><p><img src="/images/Xnip2019-12-20_16-30-10.jpeg" alt="tp1"></p><h5 id="属性值-line-size"><a href="#属性值-line-size" class="headerlink" title="属性值 line-size"></a>属性值 line-size</h5><pre><code class="css">.container{  grid-column-gap:10px;  grid-row-gap:15px;}</code></pre><p><img src="/images/Xnip2019-12-20_16-36-27.jpeg" alt="gap"><br><img src="/images/Xnip2019-12-20_16-42-15.jpeg" alt="gap"><br><img src="/images/Xnip2019-12-20_16-45-36.jpeg" alt="gap"></p><h4 id="items"><a href="#items" class="headerlink" title="items"></a>items</h4><h5 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h5><p><img src="/images/Xnip2019-12-20_16-48-05.jpeg" alt="items"></p><pre><code class="css">.container{  justify-items:start| end| center| stretch ;}</code></pre><p><img src="/images/Xnip2019-12-20_16-50-14.jpeg" alt="ru"><br><img src="/images/Xnip2019-12-20_16-52-57.jpeg" alt="tp2"></p><h4 id="content"><a href="#content" class="headerlink" title="content"></a>content</h4><h4 id="grid-auto"><a href="#grid-auto" class="headerlink" title="grid-auto"></a>grid-auto</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 大前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object</title>
      <link href="/2019/12/02/Object/"/>
      <url>/2019/12/02/Object/</url>
      
        <content type="html"><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h2 id="Enhanced-Object-Properties"><a href="#Enhanced-Object-Properties" class="headerlink" title="Enhanced Object Properties"></a>Enhanced Object Properties</h2><ul><li>Property Shorthand</li></ul><p>在 ES6 之前 Object 的属性必须是 key-value 形式，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">obj = &#123; <span class="attr">x</span>: x, <span class="attr">y</span>: y &#125;;</span><br></pre></td></tr></table></figure><p>在 ES6 之后是可以用简写的形式来表达：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>, y = <span class="number">0</span></span><br><span class="line">obj = &#123; x, y &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x= <span class="number">2</span>; <span class="keyword">let</span> y =<span class="number">2</span> ; <span class="keyword">let</span> z =<span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> obj =&#123;</span><br><span class="line">    <span class="string">'x'</span>:x,</span><br><span class="line">    y,</span><br><span class="line">    [z+y]:<span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Computed Property Names<br>在 ES6 之前 Object 的 key 在定义时必须是字符串，如果想增加“动态”的 key，必须是先计算出 key，利用 <code>object[key] = value</code> 的方式来修改；<br>在 ES6 之后可以直接用变量或者表达式来定义 key。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">'bar'</span>,</span><br><span class="line">  ([<span class="string">'baz'</span>+ quux()]): <span class="number">42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[!DANGER]<br>上述代码中不应该有()直接书写[‘baz’+ quux()]就可以，之所以这么写是 markdown 高亮插件还不支持计算属性。<br>而不用在这样写</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br><span class="line">obj[<span class="string">'baz'</span> + quux()] = <span class="number">42</span></span><br></pre></td></tr></table></figure><h2 id="Method-Properties"><a href="#Method-Properties" class="headerlink" title="Method Properties"></a>Method Properties</h2>从 ES6 开始对象内的方法可以简写，包括常规函数和异步函数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  foo (a, b) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  bar (x, y) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  * quux (x, y) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在 ES5 时代只能这样写<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  quux: no equivalent in ES5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[!WARNING]<br>ES5 时代 Object 的属性只支持常规函数，对于异步函数是不支持的</p></blockquote></li></ul><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>在 JavaScript 里通常使用 Array 或 Object 来存储数据。但是在频繁操作数据的过程中查找或者统计并需要手动来实现，并不能简单的直接使用。<br>比如如何保证 Array 是去重的，如何统计 Object 的数据总数等，必须自己去手动实现类似的需求，不是很方便。<br>在 ES6 中为了解决上述痛点，新增了数据结构 Set 和 Map，它们分别对应传统数据结构的“集合”和“字典”。首先，我们先来学习下 Set 数据结构。</p><h2 id="生成-Set-实例"><a href="#生成-Set-实例" class="headerlink" title="生成 Set 实例"></a>生成 Set 实例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br></pre></td></tr></table></figure><p>可以定义一个空的 Set 实例，也可以在实例化的同时传入默认的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><blockquote><p>[!TIP]<br>初始化的参数必须是可遍历的，可以是数组或者自定义遍历的数据结构。</p></blockquote><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="string">'hello'</span>)</span><br><span class="line">s.add(<span class="string">'goodbye'</span>)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="string">'hello'</span>).add(<span class="string">'goodbye'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>[!NOTE]<br>敲黑板了，Set 数据结构不允许数据重复，所以添加重复的数据是无效的</p></blockquote><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>删除数据分两种，一种是删除指定的数据，一种是删除全部数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定数据</span></span><br><span class="line">s.delete(<span class="string">'hello'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 删除全部数据</span></span><br><span class="line">s.clear()</span><br></pre></td></tr></table></figure><h2 id="统计数据"><a href="#统计数据" class="headerlink" title="统计数据"></a>统计数据</h2><p>Set 可以快速进行统计数据，如数据是否存在、数据的总数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否包含数据项，返回 true 或 false</span></span><br><span class="line">s.has(<span class="string">'hello'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 计算数据项总数</span></span><br><span class="line">s.size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><ul><li>keys()：返回键名的遍历器</li><li>values()：返回键值的遍历器</li><li>entries()：返回键值对的遍历器</li><li>forEach()：使用回调函数遍历每个成员</li><li>for…of：可以直接遍历每个成员</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s.keys()); <span class="comment">// SetIterator &#123;"hello", "goodbye"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(s.values()); <span class="comment">// SetIterator &#123;"hello", "goodbye"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(s.entries()); <span class="comment">// SetIterator &#123;"hello" =&gt; "hello", "goodbye" =&gt; "goodbye"&#125;</span></span><br><span class="line">s.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item) <span class="comment">// hello // goodbye</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// goodbye</span></span><br></pre></td></tr></table></figure><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>前面我们讲过 Set 和 Map 的背景，Map 是用来实现字典的功能（Object 键值对）。我们来看下它的用法：</p><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([iterable])</span><br></pre></td></tr></table></figure><p>Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, ‘one’ ],[ 2, ‘two’ ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。</p><h2 id="添加数据-1"><a href="#添加数据-1" class="headerlink" title="添加数据"></a>添加数据</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keyObj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> keyFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> keyString = <span class="string">'a string'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加键</span></span><br><span class="line">map.set(keyString, <span class="string">"和键'a string'关联的值"</span>)</span><br><span class="line">map.set(keyObj, <span class="string">'和键keyObj关联的值'</span>)</span><br><span class="line">map.set(keyFunc, <span class="string">'和键keyFunc关联的值'</span>)</span><br></pre></td></tr></table></figure><h2 id="删除数据-1"><a href="#删除数据-1" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定的数据</span></span><br><span class="line">map.delete(keyObj)</span><br><span class="line"><span class="comment">// 删除所有数据</span></span><br><span class="line">map.clear()</span><br></pre></td></tr></table></figure><h2 id="统计数据-1"><a href="#统计数据-1" class="headerlink" title="统计数据"></a>统计数据</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计所有 key-value 的总数</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">//2</span></span><br><span class="line"><span class="comment">// 判断是否有 key-value</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(keyObj)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="查询数据-1"><a href="#查询数据-1" class="headerlink" title="查询数据"></a>查询数据</h2><ul><li>get() 方法返回某个 Map 对象中的一个指定元素</li><li>keys() 返回一个新的 Iterator 对象。它包含按照顺序插入 Map 对象中每个元素的 key 值</li><li>values() 方法返回一个新的 Iterator 对象。它包含按顺序插入Map对象中每个元素的 value 值</li><li>entries() 方法返回一个新的包含 [key, value] 对的 Iterator ?对象，返回的迭代器的迭代顺序与 Map 对象的插入顺序相同</li><li>forEach() 方法将会以插入顺序对 Map 对象中的每一个键值对执行一次参数中提供的回调函数</li><li>for…of 可以直接遍历每个成员<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(map.get(keyObj)) <span class="comment">// 和键keyObj关联的值</span></span><br><span class="line"><span class="built_in">console</span>.log(map.keys()) <span class="comment">// Iterator</span></span><br><span class="line"><span class="built_in">console</span>.log(map.values()) <span class="comment">// Iterator</span></span><br><span class="line"><span class="built_in">console</span>.log(map.entries()) <span class="comment">// Iterator</span></span><br><span class="line">map.forEach(<span class="function">(<span class="params">value, key, map</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value, key, map)</span><br><span class="line">&#125;, thisArg)</span><br><span class="line"><span class="keyword">for</span> ([key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach</a></p></blockquote></li></ul><p>其实 Object 也是按键值对存储和读取的，那么他俩之间除了我们之前说的区别以外还有其他的吗？</p><ul><li>键的类型<br>一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。</li><li>键的顺序<br>Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。</li><li>键值对的统计<br>你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。</li><li>键值对的遍历<br>Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。</li><li>性能<br>Map 在涉及频繁增删键值对的场景下会有些性能优势。<h1 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h1>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，它将返回目标对象。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">b</span>: <span class="number">4</span>, <span class="attr">c</span>: <span class="number">5</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> returnedTarget = <span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target)</span><br><span class="line"><span class="comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(returnedTarget)</span><br><span class="line"><span class="comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br></pre></td></tr></table></figure>基本语法<blockquote><p>Object.assign(target, …sources)</p></blockquote></li></ul><table><thead><tr><th>参数</th><th>含义</th><th>必选</th></tr></thead><tbody><tr><td>target</td><td>目标对象</td><td>Y</td></tr><tr><td>sources</td><td>源对象</td><td>N</td></tr><tr><td>&gt; [!TIP]</td><td></td><td></td></tr><tr><td>从语法上可以看出源对象的个数是不限制的（零个或多个），如果是零个直接返回目的对象，如果是多个相同属性的会被后边的源对象的属相覆盖。</td><td></td><td></td></tr><tr><td><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Object</span>.assign(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;)</span><br><span class="line"><span class="comment">// &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure></td><td></td><td></td></tr><tr><td>&gt; [!WARNING]</td><td></td><td></td></tr><tr><td>如果目的对象不是对象，则会自动转换为对象</td><td></td><td></td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="built_in">Object</span>.assign(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// Number &#123;2&#125;</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Object</span>.assign(<span class="number">2</span>, &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// Number &#123;2, a: 2&#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.sitepoint.com/es6-enhanced-object-literals/" target="_blank" rel="noopener">es6-enhanced-object-literals</a><br><a href="https://codetower.github.io/es6-features/" target="_blank" rel="noopener">es6-features</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">Object.assign()</a></p>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象 - 重学ES5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux指令</title>
      <link href="/2019/12/02/linux%E6%8C%87%E4%BB%A4/"/>
      <url>/2019/12/02/linux%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="linux命令汇总"><a href="#linux命令汇总" class="headerlink" title="linux命令汇总"></a>linux命令汇总</h1><h2 id="linux-入门"><a href="#linux-入门" class="headerlink" title="linux 入门"></a>linux 入门</h2><table><thead><tr><th>目录</th><th>解释</th></tr></thead><tbody><tr><td>bin</td><td>存放二进制可执行文件（ls, cat, mkdir, cp, chmod, chown, date, mv, bash等），常用命令一般都在这里。bin 放置的是单人维护模式下还能够被操作的指令。 在bin底下的指令可以被root 与一般账号所使用。</td></tr><tr><td>usr/bin</td><td>众多的应用程序， /bin -&gt; /usr/bin。</td></tr><tr><td>sbin</td><td>存放二进制可执行文件，只有root 才能访问。这里存放的是系统管理员使用的系统级别的 管理命令和 程序，如 ifconfig等. Linux有非常多的指令是用来设定系统环境的，这些指令只有root 才能够利用来设定系统，其他使用者只能用来查询而已。放在 /sbin 底下的为开机过程所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放在 /usr/sbin/ 当中。至于本机的自行安装的软件所产生的系统执行档（ system binary ），则放到 /usr/local/sbin 当中了，常见的指令包括: fdisk, fsck, ifconfig, init, mkfs 等</td></tr><tr><td>usr/sbin</td><td>root用户的一些管理程序， /sbin -&gt; /usr/sbin</td></tr><tr><td>boot</td><td>用于存放系统引导时使用的各种文件。开机会使用这个文档，包括Linux 核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的文档名为：vmlinuz, 如果使用的是 grub这个开机管理程式，则还会存在 /boot/grub/ 这个目录</td></tr><tr><td>dev</td><td>用于存放设备文件 （如鼠标，键盘等），任何装置和周边设备都是以档案形式存在这个目录当中。只要通过存取这个目录下的某个档案就等于存取某个装置。 比如重要的档案有：/dev/null, /dev/zero, /dev/tty/, /dev/lp, /dev/hd, /dev/sd ,等等。</td></tr><tr><td>media</td><td>同dev相似，存放外部设备的目录（可读型的，如u盘等）。</td></tr><tr><td>etc</td><td>存放系统管理和配置文件。系统的主要设定档几乎都放置在这里， 例如人员的账号密码档、各种服务器的启始档等等。一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root可以修改。 FHS 建议不要放置可执行档（binary）在这个目录中。比较重要的档案有：/ect/inittap, /etc/init.d/ （所有服务的预设启动 script 都放置在这里，例如要启动或者关闭iptables的话，/etc/init.d/iptables start、 /etc/init.d/iptables stop）, /etc/modprobe.conf, /etc/X11/ (与X Window 有关的各种设定档都在这里，尤其是 xorg.conf 或 XF86Config 这两个 X Server的设定档), /etc/fstab, /etc/sysconfig/ 等等</td></tr><tr><td>home</td><td>存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是 /home/user, 可以用 ~user 表示。这是系统预设使用者的家目录，在你新增一个一般使用者的账号时，预设的使用者家目录都会规范到这里来</td></tr><tr><td>root</td><td>超级管理员目录。之所以放置在这里，是因为进入单人维护模式而仅挂载根目录时，该目录就能够拥有 root 的家目录，所以我们希望 root 的家目录与根目录放在同一个分区中。</td></tr><tr><td>lib</td><td>存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似 Windows 下的 .dll 文件，存放了根文件系统程序运行所需的共享文件。系统的函数式库非常多，而 /lib 放置的则是在开机的时候会用到的库，以及在 /bin 或 /sbin 底下的指令会呼叫的函数式库而已。什么是函数式库呢？ 可以将它想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。尤其重要的是 /lib/mmodules/ 这个目录，因为该目录会放置核心相关的模组（驱动程式）</td></tr><tr><td>lib64</td><td>大量以 .so 结尾的动态库</td></tr><tr><td>mnt</td><td>系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他文件系统。在很久前，这个目录的用途与 /media 相同，只是有了 /media 之后，这个目录就用来暂时暂时挂载用了</td></tr><tr><td>opt</td><td>额外安装的可选应用程序包所存放的位置。一般情况下，我们可以把 Tomcat 等都安装到这里（在以前的系统里，习惯放置在 /usr/local 目录下）。</td></tr><tr><td>proc</td><td>虚拟文件系统目录，是系统内存的映射。可以直接访问这个目录来获取系统信息</td></tr><tr><td>run</td><td>虚拟文件系统目录，是系统内存的映射。可以直接访问这个目录来获取系统信息</td></tr><tr><td>srv</td><td>srv 可以视为 service的缩写，是一些网络服务启动之后，这些服务所需要启用的资料目录。常见的服务例如 WWW，FTP等等。举例来说， WWW 伺服器需要网页资料就可以放置在 /srv/WWW/ 里面。</td></tr><tr><td>tmp</td><td>用于存放各种临时文件，是公用的临时文件存储点。这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以不能放置重要的资料。这里要定时清理下，FHS 甚至建议在开机时清空 /tmp</td></tr><tr><td>var</td><td>用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比如各种服务的日志文件（系统启动日志）等</td></tr><tr><td>lost+found</td><td>这个目录平时是空的，系统非正常关机而留下的 ”无家可归“ 的文件 。（Windows 下叫 XXX.chk）</td></tr><tr><td>usr</td><td>用于存放系统应用程序，这是最庞大的目录，要用到的应用程序和文件几乎都是在这个目录。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $path</span><br></pre></td></tr></table></figure><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chomd 775 文件名称</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js获取文本</title>
      <link href="/2019/12/02/js%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC/"/>
      <url>/2019/12/02/js%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="js获取鼠标选中的文字内容"><a href="#js获取鼠标选中的文字内容" class="headerlink" title="js获取鼠标选中的文字内容"></a>js获取鼠标选中的文字内容</h1><h2 id="1、获取选中的文字："><a href="#1、获取选中的文字：" class="headerlink" title="1、获取选中的文字："></a>1、获取选中的文字：</h2><pre><code class="javaScript">document.selection.createRange().text; IE9以下使用window.getSelection().toString(); 其他浏览器使用$(&#39;p&#39;).mouseup(function(){    var txt = window.getSelection?window.getSelection():document.selection.createRange().text;    alert(txt) ;})</code></pre><h2 id="2、取消处于选中状态的文字："><a href="#2、取消处于选中状态的文字：" class="headerlink" title="2、取消处于选中状态的文字："></a>2、取消处于选中状态的文字：</h2><pre><code class="javaScript">document.selection.empty(); IE9以下使用window.getSelection().removeAllRanges(); 其他浏览器使用$(&#39;p&#39;).mouseup(function(){    window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();})</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svn指令</title>
      <link href="/2019/12/02/svn%E6%8C%87%E4%BB%A4/"/>
      <url>/2019/12/02/svn%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="svn-基本操作"><a href="#svn-基本操作" class="headerlink" title="svn 基本操作"></a>svn 基本操作</h1><h2 id="常用svn-命令行操作"><a href="#常用svn-命令行操作" class="headerlink" title="常用svn 命令行操作"></a>常用svn 命令行操作</h2><h3 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h3><p><code>svn add fileName [fileName] …</code></p><h3 id="强制添加文件"><a href="#强制添加文件" class="headerlink" title="强制添加文件"></a>强制添加文件</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn add . --force</span><br></pre></td></tr></table></figure><blockquote><p>强制提交会添加所有的未使用add的文件，忽略已经add的文件</p></blockquote><h3 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">svn commit -m “对于本次修改的描述”</span><br><span class="line"></span><br><span class="line">提交指定文件</span><br><span class="line"></span><br><span class="line">svn ci -m ’ ’ 文件名 文件名</span><br></pre></td></tr></table></figure><blockquote><p>在svn中使用commit 之后所有的文件都会提交到远程</p></blockquote><h3 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn update</span><br></pre></td></tr></table></figure><h3 id="第一次从远程仓库拉取代码"><a href="#第一次从远程仓库拉取代码" class="headerlink" title="第一次从远程仓库拉取代码"></a>第一次从远程仓库拉取代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn checkout url</span><br></pre></td></tr></table></figure><h3 id="查看svn仓库信息"><a href="#查看svn仓库信息" class="headerlink" title="查看svn仓库信息"></a>查看svn仓库信息</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn info</span><br></pre></td></tr></table></figure><h3 id="解决文件冲突"><a href="#解决文件冲突" class="headerlink" title="解决文件冲突"></a>解决文件冲突</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn resolved fileName</span><br></pre></td></tr></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn delete 文件名 文件名</span><br></pre></td></tr></table></figure><h3 id="添加gitignore"><a href="#添加gitignore" class="headerlink" title="添加gitignore"></a>添加gitignore</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; svn propedit svn:ignore &#39; file</span><br><span class="line">&gt; flle</span><br><span class="line">&gt; file &#39; .</span><br></pre></td></tr></table></figure><h3 id="查看svn状态"><a href="#查看svn状态" class="headerlink" title="查看svn状态"></a>查看svn状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看状态：svn log -v [要查看状态的文件名]</span><br><span class="line">这个命令会打印出所有的svn更改记录</span><br></pre></td></tr></table></figure><h3 id="查看gitignore"><a href="#查看gitignore" class="headerlink" title="查看gitignore"></a>查看gitignore</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn propget svn:ignore</span><br></pre></td></tr></table></figure><h3 id="svn-创建分支命令"><a href="#svn-创建分支命令" class="headerlink" title="svn 创建分支命令"></a>svn 创建分支命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn copy 当前分支 新分支 --message ‘创建新分支 test’</span><br><span class="line">svn copy svn:&#x2F;&#x2F;127.0.0.1&#x2F;repos&#x2F;dev svn:&#x2F;&#x2F;127.0.0.1&#x2F;repos&#x2F;branch -m “test”</span><br></pre></td></tr></table></figure><blockquote><p>创建分支，只能在同一个仓库内进行，跨仓库是不行的</p></blockquote><h3 id="svn-合并分之到主干"><a href="#svn-合并分之到主干" class="headerlink" title="svn 合并分之到主干"></a>svn 合并分之到主干</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  将目录cd到主干目录（trunk）</span><br><span class="line"><span class="bullet">1.  </span>运行svn update:</span><br><span class="line"><span class="code">     查看版本 库的的最新版本号（18665）</span></span><br><span class="line">2.运行svn merge：</span><br><span class="line">svn merge 将要被合并的分支</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 大前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>template</title>
      <link href="/2019/12/02/template/"/>
      <url>/2019/12/02/template/</url>
      
        <content type="html"><![CDATA[<h1 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h1><p>在 ES6 之前对字符串的处理是相当的麻烦，看如下场景：</p><ul><li><ol><li>字符串很长要换行<br>字符串很长包括几种情形一个是开发时输入的文本内容，一个是接口数据返回的文本内容。如果对换行符处理不当，就会带来异常。</li></ol></li><li><ol start="2"><li>字符串中有变量或者表达式<br>如果字符串不是静态内容，往往是需要加载变量或者表达式，这个也是很常见的需求。之前的做法是字符串拼接:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">'JavaScript'</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'My age is '</span> + (a + b) + <span class="string">' and I love '</span> + c</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure>如果字符串有大量的变量和表达式，这个拼接简直是噩梦。</li></ol></li><li><ol start="3"><li>字符串中有逻辑运算</li></ol></li></ul><p>我们通常写代码都是有逻辑运算的，对于字符串也是一样，它包含的内容不是静态的，通常是根据一定的规则在动态变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> retailPrice = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> wholesalePrice = <span class="number">16</span></span><br><span class="line"><span class="keyword">var</span> type = <span class="string">'retail'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> showTxt = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type === <span class="string">'retail'</span>) &#123;</span><br><span class="line">  showTxt += <span class="string">'您此次的购买单价是：'</span> + retailPrice</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  showTxt += <span class="string">'您此次的批发价是：'</span> + wholesalePrice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这样的代码一定会感到很熟悉，通常大家的做法是使用上述的字符串拼接+逻辑判断，或者采用字符串模板类库来操作。</p><h2 id="String-Literals"><a href="#String-Literals" class="headerlink" title="String Literals"></a>String Literals</h2><p>看了上述的应用场景，就要引入 String Literals 话题，这个是用来解决字符串拼接问题，从 ES6 开始可以这样定义字符串了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`string text`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`string text line 1</span></span><br><span class="line"><span class="string"> string text line 2`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></span><br></pre></td></tr></table></figure><p>在这里你可以任意插入变量或者表达式，只要用 ${} 包起来就好。</p><blockquote><p>[!WARNING]<br>这里的符号是反引号，也就是数字键 1 左边的键，不是单引号或者双引号</p></blockquote><p>这样就可以轻松解决字符串包含变量或者表达式的问题了，对于多行的字符串，之前是这样处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'string text line 1\n'</span> +</span><br><span class="line"><span class="string">'string text line 2'</span>);</span><br><span class="line"><span class="comment">// "string text line 1</span></span><br><span class="line"><span class="comment">// string text line 2"</span></span><br></pre></td></tr></table></figure><p>现在可以这样做了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"><span class="comment">// "string text line 1</span></span><br><span class="line"><span class="comment">// string text line 2"</span></span><br></pre></td></tr></table></figure><p>完全不需要 <code>\n</code> 来参与。</p><h2 id="Tag-Literals"><a href="#Tag-Literals" class="headerlink" title="Tag Literals"></a>Tag Literals</h2><p>前面的字符串字面量解决了字符串拼接的问题，对于包含复杂逻辑的字符串并不是简单的表达式能搞定的。所以需要另一种解决方案：Tag Literals，还是看上述那个例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> retailPrice = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> wholesalePrice = <span class="number">16</span></span><br><span class="line"><span class="keyword">var</span> type = <span class="string">'retail'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> showTxt = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type === <span class="string">'retail'</span>) &#123;</span><br><span class="line">  showTxt += <span class="string">'您此次的购买单价是：'</span> + retailPrice</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  showTxt += <span class="string">'您此次的批发价是：'</span> + wholesalePrice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以定义一个 Tag 函数，然后用这个 Tag 函数来充当一个模板引擎：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Price</span> (<span class="params">strings, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = strings[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> retailPrice = <span class="number">20</span></span><br><span class="line">  <span class="keyword">const</span> wholesalePrice = <span class="number">16</span></span><br><span class="line">  <span class="keyword">let</span> txt = <span class="string">''</span></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'retail'</span>) &#123;</span><br><span class="line">    txt = <span class="string">`购买单价是：<span class="subst">$&#123;retailPrice&#125;</span>`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    txt = <span class="string">`批发价是：<span class="subst">$&#123;wholesalePrice&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;s1&#125;</span><span class="subst">$&#123;txt&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> showTxt = Price<span class="string">`您此次的<span class="subst">$&#123;<span class="string">'retail'</span>&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(showTxt) <span class="comment">//您此次的购买单价是：20</span></span><br></pre></td></tr></table></figure><blockquote><p>[!TIP]<br>strings 参数指的是 Tag 函数后面被变量分割开的字符串集合，type 参数是对应第一个变量，Tag 函数可以有多个 type 类似的参数</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings" target="_blank" rel="noopener">模板字符串</a><br><a href="https://developers.google.com/web/updates/2015/01/ES6-Template-Strings" target="_blank" rel="noopener">Getting Literal With ES6 Template Strings</a><br><a href="https://flaviocopes.com/javascript-template-literals/" target="_blank" rel="noopener">A guide to JavaScript Template Literals</a></p>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重学ES5 </tag>
            
            <tag> Template </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端环境安装指令</title>
      <link href="/2019/12/02/%E5%89%8D%E7%AB%AF%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E6%8C%87%E4%BB%A4/"/>
      <url>/2019/12/02/%E5%89%8D%E7%AB%AF%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="开发系统环境"><a href="#开发系统环境" class="headerlink" title="开发系统环境"></a>开发系统环境</h1><h2 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h2><ul><li>下载nvm<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash</span><br></pre></td></tr></table></figure></li><li>添加nvm换奖变量<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NVM<span class="emphasis">_DIR="$([ -z "$&#123;XDG_</span>CONFIG<span class="emphasis">_HOME-&#125;" ] &amp;&amp; printf %s "$&#123;HOME&#125;/.nvm" || printf %s "$&#123;XDG_</span>CONFIG_HOME&#125;/nvm")"</span><br><span class="line">[ -s "$NVM<span class="emphasis">_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_</span>DIR/nvm.sh" # This loads nvm</span><br></pre></td></tr></table></figure></li><li>相关指令<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nvm -version</span><br><span class="line">nvm install 8.0.0                     Install a specific version number</span><br><span class="line">nvm use 8.0                           Use the latest available 8.0.x release</span><br><span class="line">nvm run 6.10.3 app.js                 Run app.js using node 6.10.3</span><br><span class="line">nvm exec 4.8.3 node app.js            Run <span class="code">`node app.js`</span> with the PATH pointing to node 4.8.3</span><br><span class="line">nvm alias default 8.1.0               Set default node version on a shell</span><br><span class="line">nvm alias default node                Always default to the latest available node version on a shell</span><br><span class="line">nvm list</span><br></pre></td></tr></table></figure></li></ul><h2 id="更改yarn-registry"><a href="#更改yarn-registry" class="headerlink" title="更改yarn registry"></a>更改yarn registry</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn config set registry 'https://registry.npm.taobao.org/'</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br><span class="line">uname -a</span><br><span class="line">df </span><br><span class="line">df -Th</span><br><span class="line">cd / </span><br><span class="line">ls -la</span><br><span class="line">home 个人目录</span><br><span class="line">var  日志文件</span><br><span class="line">top  进程</span><br></pre></td></tr></table></figure><h2 id="linux常见"><a href="#linux常见" class="headerlink" title="linux常见"></a>linux常见</h2><ul><li>文档型<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a  // 查看版本</span><br><span class="line">df -Th // 查看磁盘</span><br><span class="line">top // cup资源 磁盘资源</span><br><span class="line">cd /home/</span><br><span class="line">mkdir test // 创建测试目录</span><br><span class="line">ls</span><br><span class="line">touch test.txt</span><br><span class="line">vi test.txt</span><br><span class="line">i</span><br><span class="line">esc</span><br><span class="line">:wq </span><br><span class="line">:q! 不对文件保存 </span><br><span class="line">cat //查看文件</span><br><span class="line">echo  '121' &gt;&gt; text.txt// 添加插入</span><br><span class="line">cat test.text// 查看文件</span><br><span class="line">echo 'hellow' &gt; text.txt // 覆盖文件内容</span><br><span class="line">cat 文件名 // 查看文件</span><br><span class="line">rm 文件名 // 删除文件</span><br><span class="line">rm -r textdir/ // 删除文件名</span><br><span class="line">rm -rf </span><br><span class="line">touch</span><br><span class="line">cat</span><br><span class="line">echo</span><br><span class="line">rm</span><br><span class="line">vi</span><br><span class="line">cd</span><br></pre></td></tr></table></figure></li><li>功能型： 压缩/解压， 下载，远程<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget  //链接地址</span><br><span class="line">tar zxvf // 文件名称  // z:gz  v:过程  f：归档文件</span><br><span class="line">tar zcvf 文件最终的名字 //</span><br></pre></td></tr></table></figure></li><li>查看进程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep  &#x2F;&#x2F; 查看进程 </span><br><span class="line">kill -9 p）id &#x2F;&#x2F; 终止</span><br></pre></td></tr></table></figure></li><li>服务命令</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">service sshd status</span><br><span class="line">service sshd stop</span><br><span class="line">service sshd restart</span><br><span class="line">systemctl status firewalld.service</span><br></pre></td></tr></table></figure><h2 id="SSH密钥方式链接Linux"><a href="#SSH密钥方式链接Linux" class="headerlink" title="SSH密钥方式链接Linux"></a>SSH密钥方式链接Linux</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -p <span class="number">22</span><span class="comment">// </span></span><br><span class="line">ssh root@<span class="number">473105.212</span><span class="number">.161</span> <span class="comment">//用户名</span></span><br></pre></td></tr></table></figure><ul><li>修改SSH默认端口号<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service sshd status</span><br><span class="line">netstat -anlp | grep sshd 或者 vi /etc/ssh/sshd_config</span><br><span class="line">vi  a</span><br></pre></td></tr></table></figure></li><li>SSH密钥登陆<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"><span class="comment">//反查</span></span><br><span class="line">semange port -a -t ssh_port_t -p tcp <span class="number">10022</span></span><br><span class="line">yum whatprovides semange</span><br><span class="line">yum install -y <span class="comment">//包名</span></span><br><span class="line">semange port -a -t ssh_port_t -p tcp <span class="number">10022</span></span><br><span class="line">semange port -l |grep ssh</span><br><span class="line">semange port -d -t ssh_port_t -p tcp <span class="number">27000</span> <span class="comment">// 删除端口号</span></span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><h2 id="免密钥方式"><a href="#免密钥方式" class="headerlink" title="免密钥方式"></a>免密钥方式</h2></li><li>生成ssh <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ls</span><br><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim指令</title>
      <link href="/2019/12/02/vim%E6%8C%87%E4%BB%A4/"/>
      <url>/2019/12/02/vim%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="vim-使用技巧"><a href="#vim-使用技巧" class="headerlink" title="vim 使用技巧"></a>vim 使用技巧</h1><blockquote><p>vim 是一个功能强大的屏幕文本编辑器，是Linux/unix 上最常用的文本编辑器，他的作用是建立、编辑、显示文本文件<br>vim没有菜单，只有命令<br>vim 的三个模式</p><ul><li>命令模式（键盘上的每个按键都是一个命令）；</li><li>编辑模式（在命令模式下输入 ：即进入编辑模式）</li><li>插入模式 （在命令模式下按 i ，即可进入插入模式）</li></ul></blockquote><h2 id="进入命令模式"><a href="#进入命令模式" class="headerlink" title="进入命令模式"></a>进入命令模式</h2><blockquote><p>vi fileName</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">常用命令：</span><br><span class="line"><span class="bullet">1. </span>插入模式</span><br><span class="line">a   在光标所在字符后插入</span><br><span class="line">A   在光标所在行行尾插入</span><br><span class="line">i    在光标所在字符前插入</span><br><span class="line">I    在光标所在行行首插入</span><br><span class="line">o   (小写字母o)在光标下插入新行</span><br><span class="line">O   （大写字母O）在光标上插入新行</span><br><span class="line"></span><br><span class="line"><span class="bullet">2. </span>定位命令</span><br><span class="line">:set nu   // 设置行号</span><br><span class="line">:set nonu   // 取消行号</span><br><span class="line">gg     // 到第一行</span><br><span class="line">G      // 到第 最后一行</span><br><span class="line">nG     // 到第n行</span><br><span class="line">:n      // 到第n行</span><br><span class="line">$       // 移至行尾</span><br><span class="line">0        // 移至行首   这个是零</span><br><span class="line"></span><br><span class="line"><span class="bullet">3. </span>删除命令</span><br><span class="line">x    // 删除光标所在处字符</span><br><span class="line">nx  // 删除光标所在处后 n个字符</span><br><span class="line">dd   // 删除光标所在行    // ndd 删除  n行</span><br><span class="line">dG   // 删除光标所在行到文件末尾的内容</span><br><span class="line">D     // 删除光标所在处到行尾内容</span><br><span class="line">:n1,n2d   // 删除指定范围的行</span><br><span class="line"></span><br><span class="line"><span class="bullet">4. </span>复制和剪切命令</span><br><span class="line"></span><br><span class="line">yy    复制当前行</span><br><span class="line">nyy   复制当前行一下几行</span><br><span class="line">dd     剪切当前行</span><br><span class="line">ndd    剪切当前行一下n行</span><br><span class="line">p        小写  粘贴所在行下</span><br><span class="line">P         大写 粘贴所在行上</span><br><span class="line"></span><br><span class="line"><span class="bullet">5. </span>替换和取消命令</span><br><span class="line">r     替换光标所在处字符</span><br><span class="line">R    从光标处开始替换字符，直到按Esc 才能退出替换模式</span><br><span class="line">u     取消上一步操作</span><br><span class="line"></span><br><span class="line"><span class="bullet">6. </span>搜索和替换命令</span><br><span class="line">/string              // 搜索指定字符串，</span><br><span class="line"><span class="code">                       //  搜索时忽略大小写   :set ic</span></span><br><span class="line">n                // 搜索指定字符串的下一个出现位置</span><br><span class="line">:%s/old/new/g       // 全文替换指定字符串</span><br><span class="line">:n1,n2s/old/new/g          // 在一定范围内替换指定字符串</span><br><span class="line">//   :9,10s/zoe/qiphon/g    // 把第9和第10行的zoe 替换成 qiphon</span><br><span class="line"></span><br><span class="line"><span class="bullet">7. </span>保存退出命令</span><br><span class="line">:w             // 保存修改</span><br><span class="line">:w new_fileName   // 另存为指定文件</span><br><span class="line">:wq            // 保存并退出</span><br><span class="line">ZZ            // 快捷键，保存并退出</span><br><span class="line">:q!            // 不保存修改退出</span><br><span class="line">:wq!           // 保存修改并退出（文件所有者及root可使用）</span><br></pre></td></tr></table></figure><h2 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h2><blockquote><p>命令模式输入 ：即进入 编辑模式</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 比如 ，设置行号</span><br><span class="line">:set nu  Enter</span><br><span class="line">// 编辑模式输入完之后会进入命令模式</span><br></pre></td></tr></table></figure><h2 id="vim-常用技巧"><a href="#vim-常用技巧" class="headerlink" title="vim 常用技巧"></a>vim 常用技巧</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 导入别的文件到当前文件贯标位置</span><br><span class="line">:r  fileName</span><br><span class="line"></span><br><span class="line">// 查看命令位置</span><br><span class="line">:!which 命令</span><br><span class="line">// 例子   :!which ls</span><br><span class="line"></span><br><span class="line">// 导入 命令执行的结果</span><br><span class="line">:r !命令</span><br><span class="line">// 例子</span><br><span class="line">:r  !which ls</span><br><span class="line">:r  !date</span><br><span class="line"></span><br><span class="line">// 定义快捷键</span><br><span class="line">:map 快捷键   触发命令</span><br><span class="line"></span><br><span class="line">// 示例，添加注释的快捷键</span><br><span class="line">:map ^_ 0i#<span class="xml"><span class="tag">&lt;<span class="name">Esc</span>&gt;</span></span></span><br><span class="line">// Ctrl + v + /   即可出现 ^_  ,这个时问号位置键    我们定义的快捷键时  CTRL + ？</span><br><span class="line">// 后面时要执行的操作  0 到行首，i 前面插入 # 要插入的字符  <span class="xml"><span class="tag">&lt;<span class="name">Esc</span>&gt;</span></span>  相当于按 Esc</span><br><span class="line">// 连续行注释</span><br><span class="line">:n1,n2s/^/#/g      // 插入#  </span><br><span class="line">:n1,n2s/^#//g      // 删除行首</span><br><span class="line">:n1,n2s/^\/\//g     // 行首添加双 // </span><br><span class="line"></span><br><span class="line">// 定制快捷替换短语</span><br><span class="line">:ab  mymail   qiphon@12.com</span><br><span class="line">// 之后在编辑模式下 输入   mymail  按回车或空格就会补充后面的邮箱了</span><br></pre></td></tr></table></figure><blockquote><p>vim 配置文件（.vimrc）位置<br>/home/username/.vimrc /root/.vimrc</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具</title>
      <link href="/2019/12/02/%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/12/02/%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.ctolib.com/react.html" target="_blank" rel="noopener">Reactk库</a><br><a href="https://segmentfault.com/a/1190000017261691" target="_blank" rel="noopener">导出excel表格</a><br><a href="https://github.com/fullcalendar/fullcalendar" target="_blank" rel="noopener">日历插件</a><br>simulator</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类</title>
      <link href="/2019/12/02/%E7%B1%BB/"/>
      <url>/2019/12/02/%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><blockquote><p>Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。</p></blockquote><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>对于面向对象编程而言，更关注类的声明、属性、方法、静态方法、继承、多态、私有属性。</p><h2 id="Basic-Syntax"><a href="#Basic-Syntax" class="headerlink" title="Basic Syntax"></a>Basic Syntax</h2><p>首先我们要先来说明在 JavaScript 世界里如何声明一个 “类”。在 ES6 之前大家都是这么做的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Animal = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = type</span><br><span class="line">  <span class="keyword">this</span>.walk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am walking`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Animal(<span class="string">'dog'</span>)</span><br><span class="line"><span class="keyword">let</span> monkey = <span class="keyword">new</span> Animal(<span class="string">'monkey'</span>)</span><br></pre></td></tr></table></figure><p>在上述代码中，我们定义了一个叫 Animal 的类，类中声明了一个属性 type、一个方法 walk；然后通过 new Animal 这个类生成实例，完成了类的定义和实例化。当然你也可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Animal = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.walk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`I am walking`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Animal(<span class="string">'dog'</span>)</span><br><span class="line"><span class="keyword">let</span> monkey = <span class="keyword">new</span> Animal(<span class="string">'monkey'</span>)</span><br></pre></td></tr></table></figure><p>在 ES6 中把类的声明专业化了，不在用 function 的方式了，请看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (type) &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type</span><br><span class="line">  &#125;</span><br><span class="line">  walk () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am walking`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Animal(<span class="string">'dog'</span>)</span><br><span class="line"><span class="keyword">let</span> monkey = <span class="keyword">new</span> Animal(<span class="string">'monkey'</span>)</span><br></pre></td></tr></table></figure><p>很明显，从定义上就很专业了，有构造函数、方法，但是 ES6 增加了新的数据类型 class 吗？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Animal); <span class="comment">//function</span></span><br></pre></td></tr></table></figure><p>可以发现 class 的类型还是 function，和 ES5 貌似并没有什么区别，那么 class 中定义的方法在哪呢？我们知道只要是函数，就一定会有 prototype 对象。那么类的方法和 prototype 对象有什么关系呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Animal.prototype);</span><br><span class="line"><span class="comment">// &#123;constructor: ƒ, walk: ƒ&#125;</span></span><br><span class="line"><span class="comment">//   constructor: class Animal</span></span><br><span class="line"><span class="comment">//   walk: ƒ walk()</span></span><br><span class="line"><span class="comment">//   __proto__:</span></span><br><span class="line"><span class="comment">//   constructor: ƒ Object()</span></span><br><span class="line"><span class="comment">//   hasOwnProperty: ƒ hasOwnProperty()</span></span><br><span class="line"><span class="comment">//   isPrototypeOf: ƒ isPrototypeOf()</span></span><br><span class="line"><span class="comment">//   propertyIsEnumerable: ƒ propertyIsEnumerable()</span></span><br><span class="line"><span class="comment">//   toLocaleString: ƒ toLocaleString()</span></span><br><span class="line"><span class="comment">//   toString: ƒ toString()</span></span><br><span class="line"><span class="comment">//   valueOf: ƒ valueOf()</span></span><br><span class="line"><span class="comment">//   __defineGetter__: ƒ __defineGetter__()</span></span><br><span class="line"><span class="comment">//   __defineSetter__: ƒ __defineSetter__()</span></span><br><span class="line"><span class="comment">//   __lookupGetter__: ƒ __lookupGetter__()</span></span><br><span class="line"><span class="comment">//   __lookupSetter__: ƒ __lookupSetter__()</span></span><br><span class="line"><span class="comment">//   get __proto__: ƒ __proto__()</span></span><br><span class="line"><span class="comment">//   set __proto__: ƒ __proto__()</span></span><br></pre></td></tr></table></figure><p>可以看出在 Animal.prototype 对象上有两个方法，一个是构造函数（constructor）、一个是自定义的方法（walk）。这是不是和 ES5 的第二种写法一模一样？我们再来看下属性，在 ES5 中有个 API 用来判断对象的自有属性（hasOwnProperty）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(dog.hasOwnProperty(<span class="string">'type'</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>这个表现也和 ES5 中直接使用 function 定义类的方式相同，所以得出一个结论：class 的方式是 function 方式的语法糖。</p><h2 id="Setters-amp-Getters"><a href="#Setters-amp-Getters" class="headerlink" title="Setters &amp; Getters"></a>Setters &amp; Getters</h2><p>对于类中的属性，可以直接在 constructor 中通过 this 直接定义，还可以直接在类的顶层来定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (type, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type</span><br><span class="line">    <span class="keyword">this</span>._age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> age () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> age (val) &#123;</span><br><span class="line">    <span class="keyword">this</span>._age = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码演示了，通过 get/set 来给类定一个属性，不过貌似没有说服力。因为 age 和 _age 都是类的属性，而且是相同的含义这样做感觉没有实际用途。但是如果一个属性是个只读的呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (type) &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> addr () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'北京动物园'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毋庸赘述，大家都能看出来含义。再来看下如下的应用场景：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> html () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> html (value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 set/get 实现了对 element.innerHTML 的简单封装。</p><p>可是，有时候我们真的需要设置一个私有属性(闭包)，然后通过一定的规则来限制对它的修改，利用 set/get就可以轻松实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let #age = 1</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(type) &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> age() &#123;</span><br><span class="line">    return #age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> age(val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val &gt; <span class="number">0</span> &amp;&amp; val &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      #age = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Static-Methods"><a href="#Static-Methods" class="headerlink" title="Static Methods"></a>Static Methods</h2><p>静态方法是面向对象最常用的功能，在 ES5 中利用 function 实现的类是这样实现一个静态方法的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Animal = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = type</span><br><span class="line">  <span class="keyword">this</span>.walk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am walking`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`I am eating`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ES6 中使用 static 的标记是不是静态方法，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (type) &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type</span><br><span class="line">  &#125;</span><br><span class="line">  walk () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am walking`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> eat () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am eating`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sub-Classes"><a href="#Sub-Classes" class="headerlink" title="Sub Classes"></a>Sub Classes</h2><p>面向对象只所以可以应对复杂的项目实现，很大程度上要归功于继承。如果对继承概念不熟悉的同学，可以自行查询。在 ES5 中怎么实现继承呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="keyword">let</span> Animal = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = type</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义方法</span></span><br><span class="line">Animal.prototype.walk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`I am walking`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义静态方法</span></span><br><span class="line">Animal.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`I am eating`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义子类</span></span><br><span class="line"><span class="keyword">let</span> Dog = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化父类</span></span><br><span class="line">  Animal.call(<span class="keyword">this</span>, <span class="string">'dog'</span>)</span><br><span class="line">  <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I can run'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line">Dog.prototype = Animal.prototype</span><br></pre></td></tr></table></figure><p>从代码上看，是不是很繁琐？而且阅读性也较差。再看看 ES6 是怎么解决这些问题的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (type) &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type</span><br><span class="line">  &#125;</span><br><span class="line">  walk () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am walking`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> eat () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am eating`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">'dog'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I can run'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 ES6 在类的定义上仅是 ES5 定义类的语法糖，但是从开发者的角度而言，开发更有效率了，代码可阅读性大大提升。</p>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 - 重学ES5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2019/12/02/%E6%95%B0%E7%BB%84/"/>
      <url>/2019/12/02/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组中遍历的方法"><a href="#数组中遍历的方法" class="headerlink" title="数组中遍历的方法"></a>数组中遍历的方法</h1><p>在 ES6 中新增了很多实用的原生 API，方便开发者对 Array 的操控性更强，如 for…of、from、of、fill、find、findIndex等。</p><h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><pre><code>看这个名字就知道这个语法是用来遍历数组的，我们简单回忆下原始的数组遍历方法是怎样的？</code></pre><pre><code class="javaScript">for (var i = 0; i &lt; array.length; i++) {  console.log(array[i]);}</code></pre><p>后来语法有所升级，到 ES5 遍历数组的 API 多了起来，其中有 forEach、every、filter等，同样的功能可以用 forEach 或者 every 来实现。</p><pre><code class="javaScript">array.forEach(function(i){  console.log(i);})</code></pre><p>这个语法看起来要简洁很多，不需要通过索引去访问数组项，然而它的缺点也是很明显，不支持 break、continue 等。</p><pre><code class="javaScript">[1,2,3,4,5].forEach(function(i){  if(i===2){    return;  }else{    console.log(i)  }})</code></pre><p>这段代码的”本意”是从第一个元素开始遍历，遇到数组项 2 之后就结束遍历，不然打印出所遍历过的数值项。可是，事实让你大跌眼镜，因为它的输出是 1,3,4,5</p><blockquote><p>[!DANGER]<br>forEach 的代码块中不能使用 break、continue，它会抛出异常。</p></blockquote><pre><code class="javaScript">[1,2,3,4,5].every(function(i){  if(i===2){    return false;  }else{    console.log(i)    return true  }})</code></pre><pre><code class="javaScript">arr.every(function(){    if(item===2){    }else{        console.log(item)    }})</code></pre><pre><code class="javaScript">arr.every(function(){  if(item===2){  }else{    console.log(item)  }  return true})</code></pre><p>同样完成刚才的目标，使用 every 遍历就可以做到 break 那样的效果，简单的说 return false 等同于 break，return true 等同于 continue。如果不写，默认是 return false。</p><blockquote><p>[!DANGER]<br>every 的代码块中不能使用 break、continue，它会抛出异常。</p></blockquote><h2 id="for…in…"><a href="#for…in…" class="headerlink" title="for…in…"></a>for…in…</h2><p>是为对象设计 如果arr.a =8 会打印出 a和 8 a变成了索引</p><pre><code class="javascript">for (var index in array) {  if(index ===2){    continue  }  console.log(array[index]);}</code></pre><p>注意：for…in… 是支持continue和break 但是注意的是 index 是字符串 而不是数字</p><h2 id="for…of…"><a href="#for…of…" class="headerlink" title="for…of…"></a>for…of…</h2><pre><code class="javaScript">for (let val of [1,2,3]) {  console.log(val);}// 1,2,3</code></pre><p>····javaScript<br>const Price = {<br>  A: [1.5, 2.3, 4.5],<br>  B: [3, 4, 5],<br>  C: [0.5, 0.8, 1.2]<br>}<br>for(let key in Price){<br>  console.log(key,Price[key])<br>}<br>····<br>然后给这个数据结构自定义遍历规则(Iterator)，希望对这个遍历之后可以输出 1.5、3、0.5。（先不要关心 Iterator 是怎么实现的，ES6的新增语法，后面会讲）。</p><p>面对这样的数据结构，for、forEach、every、for…in 都无能为力吧？使用 for…of 就木有问题，它就是为解决这种问题而生。</p><blockquote><p>[!TIP]<br>for…of是支持 break、continue、return的，所以在功能上非常贴近原生的 for。</p></blockquote><h2 id="Array-prototype-from"><a href="#Array-prototype-from" class="headerlink" title="Array.prototype.from()"></a>Array.prototype.from()</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="noopener">Array.from</a></p><blockquote><p>伪数组转换成数组的方法<br>数组是开发中经常用到的数据结构，它非常好用。在 JavaScript 的世界里有些对象被理解为数组，然而缺不能使用数组的原生 API，比如函数中的 arguments、DOM中的 NodeList等。当然，还有一些可遍历的对象，看上去都像数组却不能直接使用数组的 API，因为它们是伪数组（Array-Like）。要想对这些对象使用数组的 API 就要想办法把它们转化为数组，传统的做法是这样的：</p></blockquote><pre><code class="javaScript">let args = [].slice.call(arguments);// collectionlet imgs = [].slice.call(document.querySelectorAll(&#39;img&#39;));// nodelist</code></pre><p>基本原理是使用 call 将数组的 api 应用在新的对象上，换句话说是利用改变函数的上下文来间接使用数组的 api。在 ES6 中提供了新的 api 来解决这个问题，就是 Array.from，代码如下：</p><pre><code class="javascript">let args = Array.from(arguments);let imgs = Array.from(document.querySelectorAll(&#39;img&#39;));// nodelist</code></pre><blockquote><p>[!TIP]<br>伪数组具备两个特征，1. 按索引方式储存数据 2. 具有length属性；如：<br>let arrLike = {<br>0: ‘a’,<br>1: ‘b’,<br>2: ‘c’,<br>length: 3<br>}</p></blockquote><h3 id="Array-from-语法"><a href="#Array-from-语法" class="headerlink" title="Array.from 语法"></a>Array.from 语法</h3><table><thead><tr><th>参数</th><th>含义</th><th>必选</th></tr></thead><tbody><tr><td>arrayLike</td><td>想要转换成数组的伪数组对象或可迭代对象</td><td>Y</td></tr><tr><td>mapFn</td><td>如果指定了该参数，新数组中的每个元素惠执行该函数回调函数</td><td>N</td></tr><tr><td>thisArg</td><td>可选参数，执行函数mapFn时this对象</td><td>N</td></tr></tbody></table><p>看了这几个参数至少能看到 Array.from 还具备 map 的功能，比如我们想初始化一个长度为 5 的数组，每个数组元素默认为 1，之前的做法是这样的：</p><pre><code class="javaScript">let arr = Array(6).join(&#39; &#39;).split(&#39;&#39;).map(item=&gt;1)// [1,1,1,1,1]</code></pre><p>这样写虽然也能实现，但是用起来比较繁琐，使用 Array.from 就会简洁很多。</p><pre><code class="javascript">Array.from({ length: 5 }, function () { return 1 })Array.from({length:5},()=&gt;1)</code></pre><h2 id="如何创建新数组"><a href="#如何创建新数组" class="headerlink" title="如何创建新数组"></a>如何创建新数组</h2><h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><pre><code class="javaScript">let array = Array(5);let array = [&#39;&#39;,&#39;&#39;]</code></pre><h3 id="Array"><a href="#Array" class="headerlink" title="Array."></a>Array.</h3><p>Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。</p><p>Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个长度为7的空数组（注意：这是指一个有7个空位(empty)的数组，而不是由7个undefined组成的数组）。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/of" target="_blank" rel="noopener">Array.of</a></p><pre><code class="javaScript">Array.of(7);       // [7]Array.of(1, 2, 3); // [1, 2, 3]Array(7);          // [ , , , , , , ]Array(1, 2, 3);    // [1, 2, 3]</code></pre><p>语法：<code>Array.of(element0[, element1[, …[, elementN]]])</code><br>参数 | 含义 | 必选<br>———— | ————-  | ————-<br>elementN | 任意个参数，将按顺序成为返回数组中的元素 | Y</p><h3 id="Array-prototype-fill"><a href="#Array-prototype-fill" class="headerlink" title="Array.prototype.fill"></a>Array.prototype.fill</h3><p>fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p><pre><code class="javaScript">let array = [1, 2, 3, 4]array.fill(0, 1, 2)// [1,0,3,4]</code></pre><p>这个操作是将 array 数组的第二个元素（索引为1）到第三个元素（索引为2）内的数填充为 0，不包括第三个元素，所以结果是 [1,0,3,4]</p><pre><code class="javaScript">let array = Array(5).fill(1)console.log(array)</code></pre><pre><code class="javaScript">let arr = [1,2,3,4,5]console.log(arr.fill(8,2,4))</code></pre><blockquote><p>[!TIP]<br>fill 不具备遍历的功能，它是通过指定要操作的索引范围来进行，通过这道题目可以看出不指定索引会对所有元素进行操作</p></blockquote><p>语法：<code>arr.fill(value[, start[, end]])</code></p><table><thead><tr><th>参数</th><th>含义</th><th>必选</th></tr></thead><tbody><tr><td>value</td><td>用来填充数组元素的值</td><td>Y</td></tr><tr><td>start</td><td>起始索引，默认值为0</td><td>N</td></tr><tr><td>end</td><td>终止索引，默认值为 this.length</td><td>N</td></tr></tbody></table><h2 id="ES5中如何查找元素"><a href="#ES5中如何查找元素" class="headerlink" title="ES5中如何查找元素"></a>ES5中如何查找元素</h2><h3 id="Array-prototype-find"><a href="#Array-prototype-find" class="headerlink" title="Array.prototype.find()"></a>Array.prototype.find()</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find" target="_blank" rel="noopener">Array.prototype.find()</a><br>find() 方法返回数组中满足提供的测试函数的第一个元素的值，否则返回 undefined。</p><pre><code class="javaScript">let array = [5, 12, 8, 130, 44];let found = array.find(function(element) {  return element &gt; 10;});console.log(found);// 12</code></pre><p>语法：<code>arr.find(callback[, thisArg])</code><br>参数 | 含义 | 必选<br>———— | ————-  | ————-<br>callback | 在数组每一项上执行的函数，接收 3 个参数，element、index、array | Y<br>thisArg | 执行回调时用作 this 的对象     | N</p><h3 id="Array-filter"><a href="#Array-filter" class="headerlink" title="Array.filter"></a>Array.filter</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="noopener">Array.filter</a></p><pre><code class="javaScript">let array = [1,2,3,4,6]let find = array.filter((item)=&gt; item%2 ===0)console.log(find)</code></pre><h3 id="Array-prototype-findIndex"><a href="#Array-prototype-findIndex" class="headerlink" title="Array.prototype.findIndex()"></a>Array.prototype.findIndex()</h3><p>findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。其实这个和 find() 是成对的，不同的是它返回的是索引而不是值。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex" target="_blank" rel="noopener">Array.prototype.findIndex()</a></p><pre><code class="javaScript">let array = [5, 12, 8, 130, 44];let found = array.find(function(element) {  return element &gt; 10;});console.log(found);// 1</code></pre><p>语法：<code>arr.findIndex(callback[, thisArg])</code><br>参数 | 含义 | 必选<br>———— | ————-  | ————-<br>callback | 在数组每一项上执行的函数，接收 3 个参数，element、index、array | Y<br>thisArg | 执行回调时用作 this 的对象     | N</p>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 - 重学ES5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>案例</title>
      <link href="/2019/12/02/%E6%A1%88%E4%BE%8B/"/>
      <url>/2019/12/02/%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="走出前端半生-，-归来仍是切图少年"><a href="#走出前端半生-，-归来仍是切图少年" class="headerlink" title="走出前端半生 ， 归来仍是切图少年"></a>走出前端半生 ， 归来仍是切图少年</h1><p><a href="/images/烟花.html"> 烟花<a/><br><a href="/images/烟花.html">烟花</a></p>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mac</title>
      <link href="/2019/12/02/mac/"/>
      <url>/2019/12/02/mac/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac快捷键"><a href="#Mac快捷键" class="headerlink" title="Mac快捷键"></a>Mac快捷键</h1><p><img src="/images/1577597335876.jpg" alt="mac图标"><br><img src="/images/1577597535992.jpg" alt="访达文件夹指令"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js方法速查</title>
      <link href="/2019/12/02/js%E6%96%B9%E6%B3%95%E9%80%9F%E6%9F%A5/"/>
      <url>/2019/12/02/js%E6%96%B9%E6%B3%95%E9%80%9F%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="JS方法速查"><a href="#JS方法速查" class="headerlink" title="JS方法速查"></a>JS方法速查</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-数组去重"><a href="#1-数组去重" class="headerlink" title="1.数组去重"></a>1.数组去重</h3><pre><code class="javaScript">let arrs = [1,2,2,3,3,6,5,5];// ES6[...new Set(arr)] // [1,2,3,6,5]// 此方法也能去除数组中重复的项：[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;) // abc// 其他方法function uniq(array){    let temp = [];    let l = array.length;    for(let i = 0; i &lt; l; i++) {        for(let j = i + 1; j &lt; l; j++){            if (array[i] === array[j]){                i++;                j = i;            }        }        temp.push(array[i]);    }    return temp;}console.log(uniq(arrs)); // [1,2,3,6,5]</code></pre><h3 id="2-数组合并"><a href="#2-数组合并" class="headerlink" title="2.数组合并"></a>2.数组合并</h3><pre><code class="javaScript">let arr1 = [1,2,3]let arr2 = [4,5,6]// ES6[...arr1, ...arr2] // [1, 2, 3, 4, 5, 6]// 方法2：concat方法（挂载Array原型链上）let c = a.concat(b);console.log(c); // [1, 2, 3, 4, 5, 6]console.log(a); // [1, 2, 3]  不改变本身// 备注：看似concat似乎是 数组对象的深拷贝，其实，concat 只是对数组的第一层进行深拷贝// 方法3：apply方法Array.prototype.push.apply(a, b);console.log(a); // [1, 2, 3, 4, 5, 6] 改变原目标数组console.log(b); // [4, 5, 6]</code></pre><h3 id="3-数组排序（sort）"><a href="#3-数组排序（sort）" class="headerlink" title="3.数组排序（sort）"></a>3.数组排序（sort）</h3><pre><code class="javaScript">let objArr = [  {name: &#39;test1&#39;, age: 20},  {name: &#39;test1&#39;, age: 22},  {name: &#39;test1&#39;, age: 21}]// 第一参数a， 第二参数b ---&gt; a-b升序（从小到大）;b-a降序（从大到小），原理就是 两数计算，如果返回的是负数，就保留前者（我可能说的不对，欢迎纠正）objArr.sort((a, b) =&gt; {  return a.age - b.age}) // 结果会按照年龄从小到大的顺序排列</code></pre><h3 id="4-多维数组转一维数组（flat）"><a href="#4-多维数组转一维数组（flat）" class="headerlink" title="4.多维数组转一维数组（flat）"></a>4.多维数组转一维数组（flat）</h3><pre><code class="javaScript">let arr = [1, [2], [[3], 4], 5];// ES6 数组的flat()arr.flat() // [1, 2, Array(1), 4, 5] 如果这样写的话只能展开二维数组，但是可以加参数Infinity，就是能展开多维数组arr.flat(Infinity) // [1, 2, 3, 4, 5] 注意如果原数组有空位，flat()方法会跳过空位// 其他方法const deepFlatten = arr =&gt; [].concat(...arr.map(v =&gt; (Array.isArray(v) ? deepFlatten(v) : v)));deepFlatten(arr); // [1,2,3,4,5]// 执行效率验证（拓展）// let start = new Date().getTime();// console.log(&#39;reduceDimension: &#39;, deepFlatten([1, [2], [[3], 4], 5]);// console.log(&#39;耗时: &#39;, new Date().getTime() - start); // *ms// ES6 数组的flatMap() 方法大家可以自行查阅一下，拓展下自己的知识面</code></pre><h3 id="5-过滤数组（filter）"><a href="#5-过滤数组（filter）" class="headerlink" title="5.过滤数组（filter）"></a>5.过滤数组（filter）</h3><pre><code class="javaScript">let json = [  { id: 1, name: &#39;john&#39;, age: 24 },  { id: 2, name: &#39;zkp&#39;, age: 21 },  { id: 3, name: &#39;mike&#39;, age: 50 }];// ES6json.filter( item =&gt; item.age &gt; 22) // [{id: 1, name: &#39;john&#39;, age: 24}, { id: 3, name: &#39;mike&#39;, age: 50 }]// ES5</code></pre><h3 id="6-判断数组中的项是否满足于某个条件（some，every）"><a href="#6-判断数组中的项是否满足于某个条件（some，every）" class="headerlink" title="6.判断数组中的项是否满足于某个条件（some，every）"></a>6.判断数组中的项是否满足于某个条件（some，every）</h3><pre><code class="javaScript">let arr = [4, 2, 3]// ES6 some方法（有符合）arr.some( item =&gt; item &gt; 1) // truearr.some( item =&gt; item &gt; 3) // true// ES5 every（全符合）arr.every(item =&gt; item &gt; 1) // truearr.every(item =&gt; item &gt; 3) // false// 注意：上面两个有不同哦，一个是有符合的判定，一个是全符合的判定</code></pre><h3 id="7-操作数组中的每一项，并使其按照一定的逻辑返回（map）"><a href="#7-操作数组中的每一项，并使其按照一定的逻辑返回（map）" class="headerlink" title="7.操作数组中的每一项，并使其按照一定的逻辑返回（map）"></a>7.操作数组中的每一项，并使其按照一定的逻辑返回（map）</h3><pre><code class="javaScript">var potatos = [  { id: &#39;1001&#39;, weight: 50 },  { id: &#39;1002&#39;, weight: 80 },  { id: &#39;1003&#39;, weight: 120 },  { id: &#39;1004&#39;, weight: 40 }]// ES6写法const fn = (arr, key) =&gt; arr.map(arr =&gt;  arr[key])fn(potatos, &#39;id&#39;) // [&quot;1001&quot;, &quot;1002&quot;, &quot;1003&quot;, &quot;1004&quot;]fn(potatos, &#39;weight&#39;) // [50, 80, 120, 40]</code></pre><h3 id="8-其他常用的ES6-Array方法"><a href="#8-其他常用的ES6-Array方法" class="headerlink" title="8.其他常用的ES6 Array方法"></a>8.其他常用的ES6 Array方法</h3><pre><code class="javaScript">// forEach() 遍历数组// pop() 删除数组中最后一个元素，并返回该元素的值。此方法更改数组的长度// shift() 删除数组中第一个元素，并返回该元素的值。此方法更改数组的长度// push() 将一个或多个元素添加到数组的末尾，并返回该数组的新长度// unshift() 将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)// 🔥Array.prototype.filter() 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素，不会改变原有值，如果没符合的返回[]let arr = [1, 2, 3]arr.filter( x =&gt; x &gt; 1) // [2, 3]// Array.prototype.join() 将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串[&#39;Fire&#39;, &#39;Air&#39;, &#39;Water&#39;].join() // &quot;Fire,Air,Water&quot;// Array.prototype.slice() 取出任意元素, | 参数一：从哪开始，参数二（可选）结束位置，不选的话 就节选到最后了[1, 2, 3].slice(0, 1) // [1]// Array.prototype.splice() 删除任意元素，操作任意元素 | 参数一：从哪开始 | 参数二：操作元素的个数 | 参数三：插入元素的值...（可以写多个参数三）[1, 2, 3].splice(0, 1) // 删除 [2, 3]// Array.prototype.includes() 用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。[1, 2, 3].includes(1) // true// Array.prototype.reverse() 颠倒数组[1, 2, 3].reverse() // [3, 2, 1]</code></pre><h3 id="9-获得数组最大最小值"><a href="#9-获得数组最大最小值" class="headerlink" title="9.获得数组最大最小值"></a>9.获得数组最大最小值</h3><pre><code class="javaScript">// 使用 Math 中的 max/min 方法let arr = [22,13,6,55,30];// ES6Math.max(...arr); // 55Math.min(...arr); // 6// ES5Math.max.apply(null, arr); // 55Math.min.apply(null, arr); // 6</code></pre><h3 id="10-获取数组交集"><a href="#10-获取数组交集" class="headerlink" title="10.获取数组交集"></a>10.获取数组交集</h3><pre><code class="javaScript">// ES6 写法const similarity = (arr1, arr2) =&gt; arr1.filter(v =&gt; arr2.includes(v));similarity([1, 2, 3], [1, 2, 4]); // [1,2]// ES5 写法// function similarity(arr1, arr2) {//   return arr2.filter(function(v) {//     return arr1.includes(v)//   })// }</code></pre><h3 id="11-数组对象去重"><a href="#11-数组对象去重" class="headerlink" title="11.数组对象去重"></a>11.数组对象去重</h3><pre><code class="javaScript">let arr = [  {id: 1, name: &#39;Jhon1&#39;},  {id: 2, name: &#39;sss&#39;},  {id: 3, name: &#39;Jhon2&#39;},  {id: 4, name: &#39;Jhon3&#39;}]// ES6const uniqueElementsBy = (arr, fn) =&gt;arr.reduce((acc, v) =&gt; {if (!acc.some(x =&gt; fn(v, x))) acc.push(v);return acc;}, []);// 下面的示例表示，去重依据是 id ，就是 id一样的，只留下一个uniqueElementsBy(arr, (a, b) =&gt; a.id === b.id) // [{id: 1, name: &#39;Jhon1&#39;}, {id: 2, name: &#39;sss&#39;}]</code></pre><h3 id="12-数组乱序"><a href="#12-数组乱序" class="headerlink" title="12.数组乱序"></a>12.数组乱序</h3><pre><code class="javaScript">function shuffle(arr) {  let array = arr  let index = array.length  while (index) {    index -= 1    let randomInedx = Math.floor(Math.random() * index)    let middleware = array[index]    array[index] = array[randomInedx]    array[randomInedx] = middleware  }  return array}let arr = [1,2,3,4,5]shuffle(arr) // [3, 4, 2, 5, 1] 结果不定</code></pre><h3 id="13-检查数组中某元素出现的次数"><a href="#13-检查数组中某元素出现的次数" class="headerlink" title="13.检查数组中某元素出现的次数"></a>13.检查数组中某元素出现的次数</h3><pre><code class="javaScript">function countOccurrences(arr, value) {  return arr.reduce((a, v) =&gt; v === value ? a + 1 : a + 0, 0);}let arr = [1,2,3,4,1,2,4]countOccurrences(arr, 1) // 2</code></pre><h3 id="14-检查数组中的所有元素是否相等"><a href="#14-检查数组中的所有元素是否相等" class="headerlink" title="14.检查数组中的所有元素是否相等"></a>14.检查数组中的所有元素是否相等</h3><pre><code class="javaScript">const allEqual = arr =&gt; arr.every(val =&gt; val === arr[0]);// 示例allEqual([1, 2, 3, 4, 5, 6]); // falseallEqual([1, 1, 1, 1]); // true</code></pre><h3 id="15-数组对象，求某一列属性的总和"><a href="#15-数组对象，求某一列属性的总和" class="headerlink" title="15.数组对象，求某一列属性的总和"></a>15.数组对象，求某一列属性的总和</h3><pre><code class="javaScript">var potatos = [  { id: &#39;1001&#39;, weight: 50 },  { id: &#39;1002&#39;, weight: 80 },  { id: &#39;1003&#39;, weight: 120 },  { id: &#39;1004&#39;, weight: 40 }]// ES6写法const fn = (arr, key) =&gt; arr.reduce((sum, p) =&gt; { return p[key] + sum },0)fn(potatos, &#39;weight&#39;) // 290fn(potatos, &#39;id&#39;) // &quot;10041003100210010&quot; 字符串相加就是这个结果，如果有各自的需求，可以自己加上</code></pre><h3 id="16-分割数组，并操作每一项数组（函数）"><a href="#16-分割数组，并操作每一项数组（函数）" class="headerlink" title="16.分割数组，并操作每一项数组（函数）"></a>16.分割数组，并操作每一项数组（函数）</h3><pre><code class="javaScript">/** * 数组分隔方法，并且可以传入一个处理函数，用来分隔之前处理数组的每一项 *  * @category Array * @param {Array} array 需要处理的数组 * @param {number} [size = 1] 每个数组区块的长度 * @param {Function} [fn = item =&gt; item] 函数 * @returns {Array} 返回一个包含拆分区块的新数组（相当于一个二维数组）。 * @example * * chunk([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], 2) * // =&gt; [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]] * * chunk([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], 3) * // =&gt; [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;d&#39;]] * * chunk([1, 2, 3, 4], 3, item =&gt; item * 2) * // =&gt; [[2, 4, 6], [8]] */function chunk(array, size = 1, fn = item =&gt; item) {    array = array.map(fn)    size = Math.max(size, 0) // 这一句就很妙，当传入值小于0的时候，置为0，大于0的时候，不写，但不知道性能怎么样    const length = array == null ? 0 : array.length    if (!length || size &lt; 1) {      return []    }    let index = 0    let resIndex = 0    const result = new Array(Math.ceil(length / size))    while (index &lt; length) {      result[resIndex++] = array.slice(index, (index += size))    }    return result}</code></pre><h2 id="👫对象"><a href="#👫对象" class="headerlink" title="👫对象"></a>👫对象</h2><h3 id="1-对象合并"><a href="#1-对象合并" class="headerlink" title="1.对象合并"></a>1.对象合并</h3><pre><code class="javaScript">// 1️⃣ ES6方法let obj1 = {    a:1,    b:{         b1:2     }}let obj2 = { c:3, d:4 }console.log({...obj1, ...obj2}) // {a: 1, b: {…}, c: 3, d: 4}// 支持无限制合并，但如果对象之间存在相同属性，则后面属性会覆盖前面属性。*请注意，这仅适用于浅层合并。// 2️⃣ Obj.assign()：可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象let o1 = { a: 1 };let o2 = { b: 2 };let obj = Object.assign(o1, o2);console.log(obj); // { a: 1, b: 2 }console.log(o1);  // { a: 1, b: 2 }, 且 **目标对象** 自身也会改变（也就是assign第一个对象）console.log(o2); // { b: 2 } 不改变// 备注：Object.assign() 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值// 备注：数组合并用 concat() 方法// 3️⃣ $.extend()</code></pre><h3 id="2-浅拷贝，深拷贝"><a href="#2-浅拷贝，深拷贝" class="headerlink" title="2.浅拷贝，深拷贝"></a>2.浅拷贝，深拷贝</h3><pre><code class="javaScript">/** * 此函数，可以完全生成一个新的拷贝对象，也可以将一个对象中的属性拷贝到另一个对象中去 * @parmas {Object} 需要被拷贝的对象 * @parmas {Object} 可选，目标对象，如果不填直接返回一个对象 */function deepClone(origin, target = {}) {    // 循环遍历对象的属性    for (key in origin) {        let isType = Object.prototype.toString.call(origin[key])        // 克隆对象类型        if (isType === &#39;[object Object]&#39;) {            target[key] = {}            deepClone(origin[key], target[key])            continue        }        // 克隆数组类型         if (isType === &#39;[object Array]&#39;) {            target[key] = []            deepClone(origin[key], target[key])            continue        }        // 克隆 Set 类型        // 克隆 Map 类型        // 克隆其他类型        // 克隆基础类型        target[key] = origin[key]    }    return target}let zhu = {  name: &#39;朱昆鹏&#39;,  technology: [&#39;css&#39;, &#39;html&#39;, &#39;js&#39;],  girlfriend: {    name: &#39;lyt&#39;  }}let zhuClone = deepClone(zhu) // zhuClone 内容完全和 zhu 一样let zhuTest = { test: &#39;测试&#39; }let zhuTestClone = deepClone(zhuTest, zhu) // zhuTestClone 不仅有 zhu所有内容，还有 zhuTest 的内容// JSON.parse(JSON.stringify(obj) 方法进行拷贝，了解就行const obj = {  name:&#39;axuebin&#39;,  sayHello:function(){    console.log(&#39;Hello World&#39;);  }}console.log(JSON.parse(JSON.stringify(obj)); // {name: &quot;axuebin&quot;} ???// undefined、function、symbol 会在转换过程中被忽略，所以就不能用这个方法进行深拷贝// 浅拷贝function clone(origin, target = {}) {    let target = {};    for (const key in origin) {        target[key] = origin[key];    }    return target;};</code></pre><h3 id="3-拓展：首层浅拷贝"><a href="#3-拓展：首层浅拷贝" class="headerlink" title="3.拓展：首层浅拷贝"></a>3.拓展：首层浅拷贝</h3><pre><code class="javaScript">function shallowClone(source) {  const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象  for (let keys in source) { // 遍历目标    if (source.hasOwnProperty(keys)) {      targetObj[keys] = source[keys];    }  }  return targetObj;}const originObj = {  a:&#39;a&#39;,  b:&#39;b&#39;,  c:[1, 2, 3],  d:{ dd: &#39;dd&#39; }};const cloneObj = shallowClone(originObj);console.log(cloneObj === originObj); // falsecloneObj.a = &#39;aa&#39;;cloneObj.c = [1, 1, 1];cloneObj.d.dd = &#39;surprise&#39;;console.log(cloneObj); // {a:&#39;aa&#39;,b:&#39;b&#39;,c:[1,1,1],d:{dd:&#39;surprise&#39;}}console.log(originObj); // {a:&#39;a&#39;,b:&#39;b&#39;,c:[1,2,3],d:{dd:&#39;surprise&#39;}}</code></pre><h3 id="4-判断对象是否为空对象"><a href="#4-判断对象是否为空对象" class="headerlink" title="4.判断对象是否为空对象"></a>4.判断对象是否为空对象</h3><pre><code class="javaScript">// 参考：https://www.cnblogs.com/HKCC/p/6083575.htmlif (JSON.stringify(对象) === &#39;{}&#39;) {  console.log(&#39;空&#39;);}</code></pre><h3 id="5-判断对象中属性的个数"><a href="#5-判断对象中属性的个数" class="headerlink" title="5.判断对象中属性的个数"></a>5.判断对象中属性的个数</h3><pre><code class="javaScript">let obj = {name: &#39;朱昆鹏&#39;, age: 21}// ES6Object.keys(obj).length // 2// ES5let attributeCount = obj =&gt; {    let count = 0;    for(let i in obj) {        if(obj.hasOwnProperty(i)) {  // 建议加上判断,如果没有扩展对象属性可以不加            count++;        }    }    return count;}attributeCount(obj) // 2</code></pre><h3 id="6-JS-对象转-url-查询字符串"><a href="#6-JS-对象转-url-查询字符串" class="headerlink" title="6.JS 对象转 url 查询字符串"></a>6.JS 对象转 url 查询字符串</h3><pre><code class="javaScript">const objectToQueryString = (obj) =&gt; Object.keys(obj).map((key) =&gt; `${encodeURIComponent(key)}=${encodeURIComponent(obj[key])}`).join(&#39;&amp;&#39;);objectToQueryString({name: &#39;Jhon&#39;, age: 18, address: &#39;beijing&#39;})// name=Jhon&amp;age=18&amp;address=beijing</code></pre><h3 id="7-对象遍历"><a href="#7-对象遍历" class="headerlink" title="7.对象遍历"></a>7.对象遍历</h3><pre><code class="javaScript">let objs = {    1: {        name: &#39;朱昆鹏&#39;    },    2: {        name: &#39;林雨桐&#39;    }}Object.keys(objs).forEach( ket =&gt; {  console.log(key,objs[key])})// 1 {name: &#39;朱昆鹏&#39;} 2 {nama:&#39;林雨桐&#39;}</code></pre><h2 id="🌴DOM"><a href="#🌴DOM" class="headerlink" title="🌴DOM"></a>🌴DOM</h2><h3 id="1-常用DOM接口"><a href="#1-常用DOM接口" class="headerlink" title="1.常用DOM接口"></a>1.常用DOM接口</h3><pre><code class="javaScript">// 获取DOM节点document.getElementById() // 通过ID获取document.getElementsByTagName() // 标签名document.getElementsByClassName() // 类名document.querySelector() // 通过选择器获取一个元素document.querySelectorAll() // 通过选择器获取一组元素document.body // 获取body的方法document.getElementsByName(name) // 通过name属性查找元素节点document.documentElement // 获取html的方法// 节点类型元素节点（标签） // 属性nodeType返回值1属性节点（标签里的属性）// 返回值2文本节点 // 返回值3注释节点（comment） // 返回值8document // 返回值9DocumentFragment // 返回值11// 节点接口dom元素.parentNode // 返回当前元素的父节点dom元素.childNodes // 子节点们dom元素.firstChild // 第一个子节点dom元素.lastChild // 最后一个子节点dom元素.nextSibling // 后一个兄弟节点 previousSibling -&gt; 前一个兄弟节点// 元素节点接口dom元素.parentElement // 返回当前元素的父元素节点dom元素.children // 返回当前元素的元素子节点dom元素.firstElementChild // 第一个元素子节点（IE不兼容）dom元素.lastElementChild // 最后一个元素子节点（IE不兼容）dom元素.nextElementSibling // 返回后一个兄弟元素节点dom元素.previousElementSibling // 返回前一个兄弟元素节点// 节点的四个属性和一个方法节点.nodeName // 元素的标签名，以大写形式表示（只读）节点.nodeValue // Text节点或者Comment节点的文本内容，（读写）节点.nodeType // 该节点的类型（只读）节点.attributes // Element节点的属性集合节点.hasChildNodes() // 判断节点 是否有子节点// Element节点的 属性和方法dom元素.innerHtmldom元素.innerTextdom元素.attributes // 获取元素身上所有属性构成的集合dom元素.setAttribute(&quot;属性名&quot;,&quot;属性值&quot;)// 给元素设置属性和属性值dom元素.getAttribute(&quot;属性名&quot;)// 获取属性值的方法dom元素.removerAttribute(&quot;属性&quot;) // 删除属性// ============== 操作接口 ==================// 增document.createElement() // 创建元素节点document.createTextNode() // 创建文本节点document.creaetComment() //创建注释节点document.createDocumentFragment() // 创建文档碎片节点// 插父元素节点.appendChild(子元素对象) // 在元素节点的子元素最后插入子元素父元素节点.insertBefore(父元素中的子元素a, 需要插入的子元素b) // 最后的结果是，父元素节点中 b元素插入到了 a的前面// 删元素节点.remove() // 删除DOM元素（自己）父元素节点.removeChild(子元素节点) // 删除子元素// 替换父元素节点.replaceChild(新的节点, 需要被替换的子节点)// 复制元素节点.cloneChild() // 返回值是 复制出来的节点// 元素节点赋值 示例dom元素.style.width = ...dom元素.style.backgroundColor = ...dom元素.className = ...</code></pre><h3 id="2-判断当前位置是否为页面底部"><a href="#2-判断当前位置是否为页面底部" class="headerlink" title="2.判断当前位置是否为页面底部"></a>2.判断当前位置是否为页面底部</h3><pre><code class="javaScript">function bottomVisible() {  return document.documentElement.clientHeight + window.scrollY &gt;= (document.documentElement.scrollHeight || document.documentElement.clientHeight)}bottomVisible() // 返回值为true/false</code></pre><h3 id="3-全屏"><a href="#3-全屏" class="headerlink" title="3.全屏"></a>3.全屏</h3><pre><code class="javaScript">function launchFullscreen(element) {  if (element.requestFullscreen) {    element.requestFullscreen()  } else if (element.mozRequestFullScreen) {    element.mozRequestFullScreen()  } else if (element.msRequestFullscreen) {    element.msRequestFullscreen()  } else if (element.webkitRequestFullscreen) {    element.webkitRequestFullScreen()  }}launchFullscreen(document.documentElement) // 整个页面进入全屏launchFullscreen(document.getElementById(&quot;id&quot;)) //某个元素进入全屏</code></pre><h3 id="退出全屏"><a href="#退出全屏" class="headerlink" title="退出全屏"></a>退出全屏</h3><pre><code class="javaScript">function exitFullscreen() {  if (document.exitFullscreen) {    document.exitFullscreen()  } else if (document.msExitFullscreen) {    document.msExitFullscreen()  } else if (document.mozCancelFullScreen) {    document.mozCancelFullScreen()  } else if (document.webkitExitFullscreen) {    document.webkitExitFullscreen()  }}exitFullscreen()</code></pre><h3 id="全屏事件"><a href="#全屏事件" class="headerlink" title="全屏事件"></a>全屏事件</h3><pre><code class="javaScript">document.addEventListener(&quot;fullscreenchange&quot;, function (e) {  if (document.fullscreenElement) {    console.log(&#39;进入全屏&#39;)  } else {    console.log(&#39;退出全屏&#39;)  }})</code></pre><h3 id="4-判断dom元素是否具有某个className"><a href="#4-判断dom元素是否具有某个className" class="headerlink" title="4.判断dom元素是否具有某个className"></a>4.判断dom元素是否具有某个className</h3><p>方法一：使用HTML5新增classList 来操作类名</p><pre><code class="javaScript">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;test&quot; class=&quot;te&quot;&gt;&lt;/div&gt;  &lt;script&gt;    let div = document.getElementById(&#39;test&#39;)    console.log(div.classList.contains(&quot;te&quot;)) // true  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>拓展：</p><ul><li>classList.add(newClassName)；添加新的类名，如已经存在，取消添加</li><li>classList.contains(oldClassName)：确定元素中是否包含指定的类名，返回值为true，false</li><li>classList.remove(oldClassName)：移除已经存在的类名;</li><li>classList.toggle(className)：如果classList中存在给定的值，删除它，否则，添加它；<br>方法二<pre><code class="javaScript">const  hasClass = (el, className) =&gt; new RegExp(`(^|\\s)${className}(\\s|$)`).test(el.className);</code></pre></li></ul><pre><code>## 🌱BOM### 1.返回当前网页地址````javaScriptfunction currentURL() {  return window.location.href}currentURL() // &quot;https://juejin.im/timeline&quot;</code></pre><h3 id="2-获取滚动条位置"><a href="#2-获取滚动条位置" class="headerlink" title="2.获取滚动条位置"></a>2.获取滚动条位置</h3><pre><code class="javaScript">function getScrollPosition(el = window) {  return {    x: (el.pageXOffset !== undefined) ? el.pageXOffset : el.scrollLeft,    y: (el.pageYOffset !== undefined) ? el.pageYOffset : el.scrollTop  }}getScrollPosition() // {x: 0, y: 692}</code></pre><h3 id="3-获取url中的参数"><a href="#3-获取url中的参数" class="headerlink" title="3.获取url中的参数"></a>3.获取url中的参数</h3><pre><code class="javaScript">function getURLParameters(url) {  const params = url.match(/([^?=&amp;]+)(=([^&amp;]*))/g)  return params?params.reduce(    (a, v) =&gt; (a[v.slice(0, v.indexOf(&#39;=&#39;))] = v.slice(v.indexOf(&#39;=&#39;) + 1), a), {}  ):[]}getURLParameters(&#39;http://www.baidu.com/index?name=tyler&#39;) // {name: &quot;tyler&quot;}</code></pre><h3 id="4-检测设备类型"><a href="#4-检测设备类型" class="headerlink" title="4.检测设备类型"></a>4.检测设备类型</h3><pre><code class="javaScript">const detectDeviceType = () =&gt;/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|OperaMini/i.test(navigator.userAgent) ? &#39;Mobile&#39; : &#39;Desktop&#39;;detectDeviceType() // &quot;Desktop&quot;</code></pre><h2 id="🕰时间"><a href="#🕰时间" class="headerlink" title="🕰时间"></a>🕰时间</h2><h3 id="1-Date-常用API"><a href="#1-Date-常用API" class="headerlink" title="1.Date 常用API"></a>1.Date 常用API</h3><pre><code class="javaScript">new Date() // 创建一个时间对象 Fri Jul 12 2019 19:59:59 GMT+0800 (中国标准时间)// 返回自1970年1月1日 00:00:00 UTC到当前时间的毫秒数。Date.now(); // 1562932828164// 解析一个表示某个日期的字符串，并返回从1970-1-1 00:00:00 UTC 到该日期对象（该日期对象的UTC时间）的毫秒数Date.parse(&#39;2019.7.12&#39;) // 1562860800000// 年月日时分秒 获取let dateMe = new Date()dateMe.getFullYear() // 2019 | 根据本地时间返回指定日期的年份dateMe.getMonth() // 6 | 根据本地时间，返回一个指定的日期对象的月份，为基于0的值（0表示一年中的第一月）。dateMe.getDate() // 12 | 根据本地时间，返回一个指定的日期对象为一个月中的哪一日（从1--31）dateMe.getHours() // 20 |根据本地时间，返回一个指定的日期对象的小时。dateMe.getMinutes() // 11 | 根据本地时间，返回一个指定的日期对象的分钟数。dateMe.getSeconds() // 29 | 方法根据本地时间，返回一个指定的日期对象的秒数dateMe.getMilliseconds() // 363 | 根据本地时间，返回一个指定的日期对象的毫秒数。dateMe.toJSON() // 🔥 &quot;2019-07-12T12:05:15.363Z&quot; | 返回 Date 对象的字符串形式dateMe.getDay() // 5 | 根据本地时间，返回一个具体日期中一周的第几天，0 表示星期天（0 - 6）dateMe.getTime() // 1562933115363 | 方法返回一个时间的格林威治时间数值。dateMe.toString() // &quot;Fri Jul 12 2019 20:05:15 GMT+0800 (中国标准时间)&quot; | 返回一个字符串，表示该Date对象dateMe.getTimezoneOffset() // -480（说明比正常时区慢480分钟，所以要加480分钟才对） | 返回协调世界时（UTC）相对于当前时区的时间差值，单位为分钟。dateMe.toDateString() // &quot;Fri Jul 12 2019&quot; | 以美式英语和人类易读的形式返回一个日期对象日期部分的字符串。</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">MDN</a></p><h3 id="2-一个时间戳格式的数字，是多少-天小时分钟秒毫秒"><a href="#2-一个时间戳格式的数字，是多少-天小时分钟秒毫秒" class="headerlink" title="2.一个时间戳格式的数字，是多少 天小时分钟秒毫秒"></a>2.一个时间戳格式的数字，是多少 天小时分钟秒毫秒</h3><pre><code class="javaScript">const formatDuration = ms =&gt; {  if (ms &lt; 0) ms = -ms;  const time = {    day: Math.floor(ms / 86400000),    hour: Math.floor(ms / 3600000) % 24,    minute: Math.floor(ms / 60000) % 60,    second: Math.floor(ms / 1000) % 60,    millisecond: Math.floor(ms) % 1000  };  return Object.entries(time)    .filter(val =&gt; val[1] !== 0)    .map(([key, val]) =&gt; `${val} ${key}${val !== 1 ? &#39;s&#39; : &#39;&#39;}`)    .join(&#39;, &#39;);};formatDuration(3161012); // 52 minutes, 41 seconds, 12 milliseconds</code></pre><h3 id="3-格林尼治时间-转-北京时间（可传格林尼治时间-或者-时间戳）"><a href="#3-格林尼治时间-转-北京时间（可传格林尼治时间-或者-时间戳）" class="headerlink" title="3.格林尼治时间 转 北京时间（可传格林尼治时间 或者 时间戳）"></a>3.格林尼治时间 转 北京时间（可传格林尼治时间 或者 时间戳）</h3><pre><code class="javaScript">function myTimeToLocal(inputTime){    if(!inputTime &amp;&amp; typeof inputTime !== &#39;number&#39;){        return &#39;&#39;;    }    let localTime = &#39;&#39;;    inputTime = new Date(inputTime).getTime();    const offset = (new Date()).getTimezoneOffset();    localTime = (new Date(inputTime - offset * 60000)).toISOString();    localTime = localTime.substr(0, localTime.lastIndexOf(&#39;.&#39;));    localTime = localTime.replace(&#39;T&#39;, &#39; &#39;);    return localTime;}console.log(myTimeToLocal(1530540726443)); // 2018-07-02 22:12:06console.log(myTimeToLocal(&#39;2017-11-16T05:23:20.000Z&#39;)); // 2017-11-16 13:23:20</code></pre><h3 id="4-获取两个日期相差天数"><a href="#4-获取两个日期相差天数" class="headerlink" title="4.获取两个日期相差天数"></a>4.获取两个日期相差天数</h3><pre><code class="javaScript">function getDaysDiffBetweenDates (dateInitial, dateFinal) {    return (dateFinal - dateInitial) / (1000 * 3600 * 24);}getDaysDiffBetweenDates(new Date(&#39;2017-12-13&#39;), new Date(&#39;2017-12-22&#39;)); // 9</code></pre><h3 id="5-一个数组中，有时间，需要将这个数组按照时间进行排序"><a href="#5-一个数组中，有时间，需要将这个数组按照时间进行排序" class="headerlink" title="5.一个数组中，有时间，需要将这个数组按照时间进行排序"></a>5.一个数组中，有时间，需要将这个数组按照时间进行排序</h3><pre><code class="javaScript">let data = [{  id: 1,  publishTime: &quot;2019-05-14 18:10:29&quot;},{  id: 2,  publishTime: &quot;2019-05-14 18:17:29&quot;},{  id: 3,  publishTime: &quot;2019-05-14 15:09:25&quot;}]data.sort((a, b) =&gt; b.publishTime - a.publishTime);// 0: {id: 2, publishTime: &quot;2019-05-14 18:17:29&quot;}// 1: {id: 1, publishTime: &quot;2019-05-14 18:10:29&quot;}// 2: {id: 3, publishTime: &quot;2019-05-14 15:09:25&quot;}</code></pre><h2 id="💍处理JS原生具有的一些问题"><a href="#💍处理JS原生具有的一些问题" class="headerlink" title="💍处理JS原生具有的一些问题"></a>💍处理JS原生具有的一些问题</h2><h3 id="1-加减法精度缺失问题"><a href="#1-加减法精度缺失问题" class="headerlink" title="1.加减法精度缺失问题"></a>1.加减法精度缺失问题</h3><pre><code class="javaScript">// 减法函数（因为JS小数计算 丢失精度）function sub(arg1, arg2) {     let r1, r2, m, n;     try { r1 = arg1.toString().split(&quot;.&quot;)[1].length } catch (e) { r1 = 0 }     try { r2 = arg2.toString().split(&quot;.&quot;)[1].length } catch (e) { r2 = 0 }     m = Math.pow(10, Math.max(r1, r2));     n = (r1 &gt;= r2) ? r1 : r2;     return Number(((arg1 * m - arg2 * m) / m).toFixed(n)); }</code></pre><h3 id="2-递归优化（尾递归）"><a href="#2-递归优化（尾递归）" class="headerlink" title="2.递归优化（尾递归）"></a>2.递归优化（尾递归）</h3><pre><code class="javaScript">// 尾递归函数 摘自阮一峰ES6 | 自己懒得写了function tco(f) {  let value;  let active = false;  let accumulated = [];  return function accumulator() {    accumulated.push(arguments);    if (!active) {      active = true;      while (accumulated.length) {        value = f.apply(this, accumulated.shift());      }      active = false;      return value;    }  };}// 使用新的函数 = tco(递归函数)</code></pre><h2 id="🙏其他"><a href="#🙏其他" class="headerlink" title="🙏其他"></a>🙏其他</h2><h3 id="1-Math函数的一些应用"><a href="#1-Math函数的一些应用" class="headerlink" title="1.Math函数的一些应用"></a>1.Math函数的一些应用</h3><pre><code class="javaScript">parseInt(5.12) // 5 | 只保留整数部分（丢弃小数部分）Math.floor(5.12) // 5 | 向下取整（效果和parseInt一样）Math.ceil(5.12) // 6 | 向上取整（有小数，整数就+1）Math.round(5.499) // 5 | 四舍五入Math.round(5.501) // 6 | 四舍五入Math.abs(-5) // 5 | 绝对值Math.max(5, 6) // 6 | 返回两者中较大的数Math.min(5, 6) // 5 | 返回两者中较小的数Math.random() // 随机数 (0-1)</code></pre><h3 id="2-常用正则速查"><a href="#2-常用正则速查" class="headerlink" title="2.常用正则速查"></a>2.常用正则速查</h3><ul><li><p>消除字符串首尾两端的空格（替换）</p><pre><code class="javaScript">let reg = /^\s+|\s+$/g;let str = &#39; #id div.class &#39;; str.replace(reg, &#39;&#39;) // &quot;#id div.class&quot;</code></pre></li><li><p>把手机号码替换成（替换)</p><pre><code class="javaScript">var reg = /1[24578]\d{9}/;var str = &#39;姓名：朱昆鹏 手机：15932638907&#39;; // 手记号瞎写的str.replace(reg, &#39;***&#39;) //&quot;姓名：朱昆鹏 手机：***&quot;</code></pre></li><li><p>替换敏感字（替换）</p><pre><code class="javaScript">let str = &#39;中国中国人民解放军中华人民共和国&#39;;let r = str.replace(/中国|军/g, input =&gt; {  let t = &#39;&#39;;  for (let i = 0; i&lt;input.length; i++) {      t += &#39;*&#39;;  }  return t;})console.log(r); //****人民解放*中华人民共和国 </code></pre></li><li><p>千位分隔符（替换）</p><pre><code class="javaScript">let reg = /(\d)(?=(?:\d{3})+$)/glet str = &#39;100002003232322&#39;;    let r = str.replace(, &#39;$1,&#39;); //100,002,003,232,322</code></pre></li><li><p>匹配网页标签（匹配）</p><pre><code class="javaScript">var reg = /&lt;(.+)&gt;.+&lt;\/\1&gt;/;var str = &#39;朱昆鹏&lt;div&gt;2707509@.qq.com&lt;/div&gt;朱昆鹏&#39;;    str.match(reg); // [&quot;&lt;div&gt;2707509@.qq.com&lt;/div&gt;&quot;]</code></pre></li><li><p>验证手机号</p><pre><code class="javaScript">let reg = /^1((3[\d])|(4[5,6,9])|(5[0-3,5-9])|(6[5-7])|(7[0-8])|(8[1-3,5-8])|(9[1,8,9]))\d{8}$/;reg.test(&#39;15932539095&#39;); //truereg.test(&#39;234554568997&#39;); //false</code></pre></li><li><p>验证邮箱地址(验证)</p><pre><code class="javaScript">let reg = /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/reg.test(&#39;2775033@hotmail.com&#39;); //truereg.test(&#39;abc@&#39;); //false</code></pre></li><li><p>验证身份证（验证）</p><pre><code class="javaScript">let reg = /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/reg.test(&#39;31210119651230518X&#39;); //true 自己瞎写的reg.test(&#39;2101196523s230518X&#39;); //false 自己瞎写的</code></pre></li><li><p>验证中国邮箱编码（验证）</p><pre><code class="javaScript">let reg = /^(0[1-7]|1[0-356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[0-5]|8[013-6])\d{4}$/reg.test(&#39;065900&#39;); //truereg.test(&#39;999999&#39;); //false</code></pre></li><li><p>验证ipv4地址正则（验证）</p><pre><code class="javaScript">let reg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/reg.test(&#39;192.168.1.192&#39;); //truereg.test(&#39;127.0.0.1s&#39;); //false</code></pre></li><li><p>验证银行卡号（16或19位）</p><pre><code class="javaScript">let reg = /^([1-9]{1})(\d{15}|\d{18})$/reg.test(&#39;6222026006705354218&#39;) // true</code></pre></li><li><p>验证中文姓名（验证）</p><pre><code class="javaScript">let reg = /^([\u4e00-\u9fa5\·]{2,10})$/reg.test(&#39;朱昆鹏&#39;); //truereg.test(&#39;Zhu Kunpeng&#39;); //false</code></pre><h3 id="3-变换变量"><a href="#3-变换变量" class="headerlink" title="3.变换变量"></a>3.变换变量</h3><pre><code class="javaScript"></code></pre></li></ul><p>// [letA，letB] = [letB，letA];</p><p>let a = 1;<br>let b = 2;<br>[a, b] = [b, a] // a = 2 b = 1</p><pre><code>### 4.格式化对象为JSON代码````javaScriptconst formatted = JSON.stringify({name: &#39;Jhon&#39;, age: 18, address: &#39;sz&#39;}, null, 4);/*{    &quot;name&quot;: &quot;Jhon&quot;,    &quot;age&quot;: 18,    &quot;address&quot;: &quot;sz&quot;}*/// 该字符串化命令有三个参数。第一个是Javascript对象。第二个是可选函数，可用于在JSON进行字符串化时对其执行操作。最后一个参数指示要添加多少空格作为缩进以格式化JSON。省略最后一个参数，JSON将返回一个长行。如果myObj中存在循环引用，则会格式失败。</code></pre><h3 id="5-随机生成六位数字验证码"><a href="#5-随机生成六位数字验证码" class="headerlink" title="5.随机生成六位数字验证码"></a>5.随机生成六位数字验证码</h3><pre><code class="javaScript">const code = Math.floor(Math.random() * 1000000).toString().padStart(6, &quot;0&quot;) // 942377</code></pre><h3 id="6-RGB-颜色转-16进制颜色"><a href="#6-RGB-颜色转-16进制颜色" class="headerlink" title="6.RGB 颜色转 16进制颜色"></a>6.RGB 颜色转 16进制颜色</h3><pre><code class="javaScript">const RGBToHex = (r, g, b) =&gt; ((r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).padStart(6, &#39;0&#39;);RGBToHex(255, 165, 1); // &#39;ffa501&#39;</code></pre><h3 id="7-生成随机整数"><a href="#7-生成随机整数" class="headerlink" title="7.生成随机整数"></a>7.生成随机整数</h3><pre><code class="javaScript">function randomNum(min, max) {  switch (arguments.length) {    case 1:      return parseInt(Math.random() * min + 1, 10)    case 2:      return parseInt(Math.random() * (max - min + 1) + min, 10)    default:      return 0  }}randomNum(1,10) // 随机 [1,10]的整数</code></pre><h3 id="8-去除空格（1-所有空格-2-前后空格-3-前空格-4-后空格-默认为1）"><a href="#8-去除空格（1-所有空格-2-前后空格-3-前空格-4-后空格-默认为1）" class="headerlink" title="8.去除空格（1-所有空格 2-前后空格 3-前空格 4-后空格 默认为1）"></a>8.去除空格（1-所有空格 2-前后空格 3-前空格 4-后空格 默认为1）</h3><pre><code class="javaScript">/** * trim 去除空格 * param1  string str 待处理字符串 * param2  number type 去除空格类型 1-所有空格  2-前后空格  3-前空格 4-后空格 默认为1 * return  string str 处理后的字符串 */function trim(str, type = 1) {    if (type &amp;&amp; type !== 1 &amp;&amp; type !== 2 &amp;&amp; type !== 3 &amp;&amp; type !== 4) return;    switch (type) {        case 1:            return str.replace(/\s/g, &quot;&quot;);        case 2:            return str.replace(/(^\s)|(\s*$)/g, &quot;&quot;);        case 3:            return str.replace(/(^\s)/g, &quot;&quot;);        case 4:            return str.replace(/(\s$)/g, &quot;&quot;);        default:            return str;    }}</code></pre><h3 id="9-大小写转换"><a href="#9-大小写转换" class="headerlink" title="9.大小写转换"></a>9.大小写转换</h3><pre><code class="javaScript">/** * 大小写转换 * param1 string str 待转换的字符串 * param2 number type 1-全大写 2-全小写 3-首字母大写  * return  string str 处理后的字符串 */function turnCase(str, type) {    switch (type) {        case 1:            return str.toUpperCase()        case 2:            return str.toLowerCase();        case 3:            return str[0].toUpperCase() + str.substr(1).toLowerCase()        default:            return str;    }}</code></pre><h3 id="10-随机16进制颜色-hexColor"><a href="#10-随机16进制颜色-hexColor" class="headerlink" title="10.随机16进制颜色 hexColor"></a>10.随机16进制颜色 hexColor</h3><pre><code class="javaScript">/** * 随机16进制颜色 hexColor * return  string str 带#号的随机16进制颜色 */function hexColor() {    let str = &#39;#&#39;;    let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;];    for (let i = 0; i &lt; 6; i++) {        let index = Number.parseInt(Math.random() * 16);        str += arr[index]    }    return str;}</code></pre><h3 id="11-统计一段文字中指定文字出现次数-keywordsCount（骚操作）"><a href="#11-统计一段文字中指定文字出现次数-keywordsCount（骚操作）" class="headerlink" title="11.统计一段文字中指定文字出现次数 keywordsCount（骚操作）"></a>11.统计一段文字中指定文字出现次数 keywordsCount（骚操作）</h3><pre><code class="javaScript">/** * 关键词统计：统计一段文字中指定文字出现次数 keywordsCount * param1 string text 进行统计的文本 * param2 string keywords 进行统计的关键词 * return number count 关键词出现次数 * tip:param1 document.body.innerText--全文统计 */function keywordsCount(text, keywords) {    return text.split(keywords).length - 1}</code></pre><h2 id="12-好的笔记文章"><a href="#12-好的笔记文章" class="headerlink" title="12.好的笔记文章"></a>12.好的笔记文章</h2><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" target="_blank" rel="noopener">JS原生事件</a></p></li><li><p><a href="https://blog.csdn.net/major_zhang/article/details/78118823" target="_blank" rel="noopener">JS选择器 new</a></p><h3 id="13-轮询等待函数"><a href="#13-轮询等待函数" class="headerlink" title="13. 轮询等待函数"></a>13. 轮询等待函数</h3><pre><code class="javaScript">/*** 轮询等待函数* * @param {Function} 轮询结束的条件* @param {Function} 成功之后的回调函数* @param {Number} 轮询时间（默认100ms）* @param {Number} 轮询最长的时间（默认1000ms）*/function pollingWaiting (callBack, resCallBack, time = 100, lastTime = 1000) {let startTime = Date.now()let t = null;let fn =  function () {    t = setTimeout(() =&gt; {        if (!callBack()) {            // 此处可以采用尾递归优化，来防止占用过多内存            console.log(&#39;startTime&#39;, Date.now() - startTime &gt; lastTime)            (Date.now() - startTime &gt; lastTime) ? window.clearInterval(t) : fn()        } else {            resCallBack()        }    }, time);}fn()}</code></pre></li></ul><p>// 示例<br>let a = 1;<br>setTimeout( () =&gt; {<br>  a = 2<br>}, 500)</p><p>pollingWaiting( () =&gt; {<br>  return a === 2<br>}, () =&gt; {<br>  console.log(‘触发了’, a)<br>}, 100, 800)</p><p>// 4 startTime false<br>// 触发了 2</p><pre><code>### 14.大数值转换为万，亿````javaScript/** * 大数值转换为万，亿函数 *  * @param {Number} 大数 * @param {Number} 保留几位小数 */function numConversion (num, point = 2) {  let numStr = num.toString().split(&#39;.&#39;)[0] // 去掉小数点后的数值字符串  let numLen = numStr.length  if (numLen &lt; 6) {    return numStr  } else if (numLen &gt;= 6 &amp;&amp; numLen &lt;= 8) {    let decimal = numStr.substring(numLen - 4, numLen - 4 + point)    let res = parseInt(num / 10000) + &#39;.&#39; + decimal + &#39;万&#39;    return res  } else if (numLen &gt; 8) {    let decimal = numStr.substring(numLen - 8, numLen - 8 + point)    let res = parseInt(num / 100000000) + &#39;.&#39; + decimal + &#39;亿&#39;    return res  }}numConversion(12345) // 12345numConversion(1234567) // 123.45万numConversion(123456789) // 1.23亿</code></pre><h3 id="15-常见的XSS转义场景"><a href="#15-常见的XSS转义场景" class="headerlink" title="15.常见的XSS转义场景"></a>15.常见的XSS转义场景</h3><pre><code class="javaScript">// 转义HTML特殊字符function HtmlEncode(str) {    var hex = new Array(&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;);    var preescape = str;    var escaped = &quot;&quot;;    for(var i = 0; i &lt; preescape.length; i++){        var p = preescape.charAt(i);        escaped = escaped + escapeCharx(p);    }    return escaped;    function escapeCharx(original){        var found=true;        var thechar=original.charCodeAt(0);        switch(thechar) {            case 10: return &quot;&lt;br/&gt;&quot;; break; //newline            case 32: return &quot;&amp;nbsp;&quot;; break; //space            case 34:return &quot;&amp;quot;&quot;; break; //&quot;            case 38:return &quot;&amp;amp;&quot;; break; //&amp;            case 39:return &quot;&amp;#x27;&quot;; break; //&#39;            case 47:return &quot;&amp;#x2F;&quot;; break; // /            case 60:return &quot;&amp;lt;&quot;; break; //&lt;            case 62:return &quot;&amp;gt;&quot;; break; //&gt;            case 198:return &quot;&amp;AElig;&quot;; break;            case 193:return &quot;&amp;Aacute;&quot;; break;            case 194:return &quot;&amp;Acirc;&quot;; break;             case 192:return &quot;&amp;Agrave;&quot;; break;             case 197:return &quot;&amp;Aring;&quot;; break;             case 195:return &quot;&amp;Atilde;&quot;; break;             case 196:return &quot;&amp;Auml;&quot;; break;             case 199:return &quot;&amp;Ccedil;&quot;; break;             case 208:return &quot;&amp;ETH;&quot;; break;            case 201:return &quot;&amp;Eacute;&quot;; break;             case 202:return &quot;&amp;Ecirc;&quot;; break;             case 200:return &quot;&amp;Egrave;&quot;; break;             case 203:return &quot;&amp;Euml;&quot;; break;            case 205:return &quot;&amp;Iacute;&quot;; break;            case 206:return &quot;&amp;Icirc;&quot;; break;             case 204:return &quot;&amp;Igrave;&quot;; break;             case 207:return &quot;&amp;Iuml;&quot;; break;            case 209:return &quot;&amp;Ntilde;&quot;; break;             case 211:return &quot;&amp;Oacute;&quot;; break;            case 212:return &quot;&amp;Ocirc;&quot;; break;             case 210:return &quot;&amp;Ograve;&quot;; break;             case 216:return &quot;&amp;Oslash;&quot;; break;             case 213:return &quot;&amp;Otilde;&quot;; break;             case 214:return &quot;&amp;Ouml;&quot;; break;            case 222:return &quot;&amp;THORN;&quot;; break;             case 218:return &quot;&amp;Uacute;&quot;; break;             case 219:return &quot;&amp;Ucirc;&quot;; break;             case 217:return &quot;&amp;Ugrave;&quot;; break;             case 220:return &quot;&amp;Uuml;&quot;; break;             case 221:return &quot;&amp;Yacute;&quot;; break;            case 225:return &quot;&amp;aacute;&quot;; break;             case 226:return &quot;&amp;acirc;&quot;; break;             case 230:return &quot;&amp;aelig;&quot;; break;             case 224:return &quot;&amp;agrave;&quot;; break;             case 229:return &quot;&amp;aring;&quot;; break;             case 227:return &quot;&amp;atilde;&quot;; break;             case 228:return &quot;&amp;auml;&quot;; break;             case 231:return &quot;&amp;ccedil;&quot;; break;             case 233:return &quot;&amp;eacute;&quot;; break;            case 234:return &quot;&amp;ecirc;&quot;; break;             case 232:return &quot;&amp;egrave;&quot;; break;             case 240:return &quot;&amp;eth;&quot;; break;             case 235:return &quot;&amp;euml;&quot;; break;             case 237:return &quot;&amp;iacute;&quot;; break;             case 238:return &quot;&amp;icirc;&quot;; break;             case 236:return &quot;&amp;igrave;&quot;; break;             case 239:return &quot;&amp;iuml;&quot;; break;             case 241:return &quot;&amp;ntilde;&quot;; break;             case 243:return &quot;&amp;oacute;&quot;; break;            case 244:return &quot;&amp;ocirc;&quot;; break;             case 242:return &quot;&amp;ograve;&quot;; break;             case 248:return &quot;&amp;oslash;&quot;; break;             case 245:return &quot;&amp;otilde;&quot;; break;            case 246:return &quot;&amp;ouml;&quot;; break;             case 223:return &quot;&amp;szlig;&quot;; break;             case 254:return &quot;&amp;thorn;&quot;; break;             case 250:return &quot;&amp;uacute;&quot;; break;             case 251:return &quot;&amp;ucirc;&quot;; break;             case 249:return &quot;&amp;ugrave;&quot;; break;             case 252:return &quot;&amp;uuml;&quot;; break;             case 253:return &quot;&amp;yacute;&quot;; break;             case 255:return &quot;&amp;yuml;&quot;; break;            case 162:return &quot;&amp;cent;&quot;; break;             case &#39;\r&#39;: break;            default:                found=false;                break;        }        if(!found){            if(thechar&gt;127) {                var c=thechar;                var a4=c%16;                c=Math.floor(c/16);                 var a3=c%16;                c=Math.floor(c/16);                var a2=c%16;                c=Math.floor(c/16);                var a1=c%16;                return &quot;&amp;#x&quot;+hex[a1]+hex[a2]+hex[a3]+hex[a4]+&quot;;&quot;;                    }            else{                return original;            }        }        }}// 转义JS特殊字符function JavaScriptEncode(str)     var hex=new Array(&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;);    function changeTo16Hex(charCode){        return &quot;\\x&quot; + charCode.charCodeAt(0).toString(16);    }    function encodeCharx(original) {        var found = true;        var thecharchar = original.charAt(0);        var thechar = original.charCodeAt(0);        switch(thecharchar) {            case &#39;\n&#39;: return &quot;\\n&quot;; break; //newline            case &#39;\r&#39;: return &quot;\\r&quot;; break; //Carriage return            case &#39;\&#39;&#39;: return &quot;\\&#39;&quot;; break;            case &#39;&quot;&#39;: return &quot;\\\&quot;&quot;; break;            case &#39;\&amp;&#39;: return &quot;\\&amp;&quot;; break;            case &#39;\\&#39;: return &quot;\\\\&quot;; break;            case &#39;\t&#39;: return &quot;\\t&quot;; break;            case &#39;\b&#39;: return &quot;\\b&quot;; break;            case &#39;\f&#39;: return &quot;\\f&quot;; break;            case &#39;/&#39;: return &quot;\\x2F&quot;; break;            case &#39;&lt;&#39;: return &quot;\\x3C&quot;; break;            case &#39;&gt;&#39;: return &quot;\\x3E&quot;; break;            default:                found=false;                break;        }        if(!found){            if(thechar &gt; 47 &amp;&amp; thechar &lt; 58){ //数字                return original;            }            if(thechar &gt; 64 &amp;&amp; thechar &lt; 91){ //大写字母                return original;            }            if(thechar &gt; 96 &amp;&amp; thechar &lt; 123){ //小写字母                return original;            }                    if(thechar&gt;127) { //大于127用unicode                var c = thechar;                var a4 = c%16;                c = Math.floor(c/16);                 var a3 = c%16;                c = Math.floor(c/16);                var a2 = c%16;                c = Math.floor(c/16);                var a1 = c%16;                return &quot;\\u&quot;+hex[a1]+hex[a2]+hex[a3]+hex[a4]+&quot;&quot;;                    }            else {                return changeTo16Hex(original);            }        }    }         var preescape = str;    var escaped = &quot;&quot;;    var i=0;    for(i=0; i &lt; preescape.length; i++){        escaped = escaped + encodeCharx(preescape.charAt(i));    }    return escaped;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30Second</title>
      <link href="/2019/12/02/30Second/"/>
      <url>/2019/12/02/30Second/</url>
      
        <content type="html"><![CDATA[<h1 id="30-seconds-of-code"><a href="#30-seconds-of-code" class="headerlink" title="30 seconds of code"></a>30 seconds of code</h1><h2 id="javaScript"><a href="#javaScript" class="headerlink" title="javaScript"></a>javaScript</h2><h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><h3 id="JavaScript-Array"><a href="#JavaScript-Array" class="headerlink" title="JavaScript Array"></a>JavaScript Array</h3><h4 id="remove-移除数组中的元素"><a href="#remove-移除数组中的元素" class="headerlink" title="remove 移除数组中的元素"></a>remove 移除数组中的元素</h4><p>Removes elements from an array for which the given function returns false.<br>通过返回false 将元素从数组中移除掉</p><pre><code class="javaScript">const remove = (arr, func) =&gt;  Array.isArray(arr)    ? arr.filter(func).reduce((acc, val) =&gt; {        arr.splice(arr.indexOf(val), 1);        return acc.concat(val);      }, [])    : [];remove([1, 2, 3, 4], n =&gt; n % 2 === 0); // [2, 4]    </code></pre><h4 id="join-字符串拼接"><a href="#join-字符串拼接" class="headerlink" title="join 字符串拼接"></a>join 字符串拼接</h4><p>Joins all elements of an array into a string and returns this string. Uses a separator and an end separator.</p><pre><code class="javaScript">const join = (arr, separator = &#39;,&#39;, end = separator) =&gt;  arr.reduce(    (acc, val, i) =&gt;      i === arr.length - 2        ? acc + val + end        : i === arr.length - 1          ? acc + val          : acc + val + separator,    &#39;&#39;  );join([&#39;pen&#39;, &#39;pineapple&#39;, &#39;apple&#39;, &#39;pen&#39;], &#39;,&#39;, &#39;&amp;&#39;); // &quot;pen,pineapple,apple&amp;pen&quot;join([&#39;pen&#39;, &#39;pineapple&#39;, &#39;apple&#39;, &#39;pen&#39;], &#39;,&#39;); // &quot;pen,pineapple,apple,pen&quot;join([&#39;pen&#39;, &#39;pineapple&#39;, &#39;apple&#39;, &#39;pen&#39;]); // &quot;pen,pineapple,apple,pen&quot;  </code></pre><h4 id="pull-过滤指定的值"><a href="#pull-过滤指定的值" class="headerlink" title="pull 过滤指定的值"></a>pull 过滤指定的值</h4><p>Mutates the original array to filter out the values specified.<br>改变原始数组以过滤掉指定的值。</p><pre><code class="javaScript">const pull = (arr, ...args) =&gt; {  let argState = Array.isArray(args[0]) ? args[0] : args;  let pulled = arr.filter(v =&gt; !argState.includes(v));  arr.length = 0;  pulled.forEach(v =&gt; arr.push(v));};EXAMPLESlet myArray = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;];pull(myArray, &#39;a&#39;, &#39;c&#39;); // myArray = [ &#39;b&#39;, &#39;b&#39; ]</code></pre><h4 id="shuffle-数组顺序随机化"><a href="#shuffle-数组顺序随机化" class="headerlink" title="shuffle 数组顺序随机化"></a>shuffle 数组顺序随机化</h4><p>Randomizes the order of the values of an array, returning a new array.<br>将数组值的顺序随机化，返回一个新数组。</p><pre><code class="javaScript">const shuffle = ([...arr]) =&gt; {  let m = arr.length;  while (m) {    const i = Math.floor(Math.random() * m--);    [arr[m], arr[i]] = [arr[i], arr[m]];  }  return arr;};EXAMPLESconst foo = [1, 2, 3];shuffle(foo); // [2, 3, 1], foo = [1, 2, 3]</code></pre><h4 id="arrayToCSV-将2d数组转化成字符串"><a href="#arrayToCSV-将2d数组转化成字符串" class="headerlink" title="arrayToCSV 将2d数组转化成字符串"></a>arrayToCSV 将2d数组转化成字符串</h4><p>Converts a 2D array to a comma-separated values (CSV) string.<br>将2D数组转换为逗号分隔值(CSV)字符串</p><pre><code class="javaScript">const arrayToCSV = (arr, delimiter = &#39;,&#39;) =&gt;  arr    .map(v =&gt; v.map(x =&gt; (isNaN(x) ? `&quot;${x.replace(/&quot;/g, &#39;&quot;&quot;&#39;)}&quot;` : x)).join(delimiter))    .join(&#39;\n&#39;);EXAMPLESarrayToCSV([[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]); // &#39;&quot;a&quot;,&quot;b&quot;\n&quot;c&quot;,&quot;d&quot;&#39;arrayToCSV([[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]], &#39;;&#39;); // &#39;&quot;a&quot;;&quot;b&quot;\n&quot;c&quot;;&quot;d&quot;&#39;arrayToCSV([[&#39;a&#39;, &#39;&quot;b&quot; great&#39;], [&#39;c&#39;, 3.1415]]); // &#39;&quot;a&quot;,&quot;&quot;&quot;b&quot;&quot; great&quot;\n&quot;c&quot;,3.1415&#39;</code></pre><h4 id="countBy-对数组元素进行计数"><a href="#countBy-对数组元素进行计数" class="headerlink" title="countBy 对数组元素进行计数"></a>countBy 对数组元素进行计数</h4><p>Groups the elements of an array based on the given function and returns the count of elements in each group.<br>根据给定的函数对数组中的元素进行分组，并返回每个组中元素的计数。</p><pre><code class="javaScript">const countBy = (arr, fn) =&gt;  arr.map(typeof fn === &#39;function&#39; ? fn : val =&gt; val[fn]).reduce((acc, val) =&gt; {    acc[val] = (acc[val] || 0) + 1;    return acc;  }, {});EXAMPLEScountBy([6.1, 4.2, 6.3], Math.floor); // {4: 1, 6: 2}countBy([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], &#39;length&#39;); // {3: 2, 5: 1}</code></pre><h4 id="differenceBy-获取两个数组中不同元素"><a href="#differenceBy-获取两个数组中不同元素" class="headerlink" title="differenceBy 获取两个数组中不同元素"></a>differenceBy 获取两个数组中不同元素</h4><p>Returns the difference between two arrays, after applying the provided function to each array element of both.<br>将提供的函数应用于两个数组的每个数组元素后，返回两个数组之间的差异。</p><pre><code class="javaScript">const differenceBy = (a, b, fn) =&gt; {  const s = new Set(b.map(fn));  console.log(s,a.map(fn))  return a.map(fn).filter(el =&gt; !s.has(el));};differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor); // [1]differenceBy([{ x: 2 }, { x: 1 }], [{ x: 1 }], v =&gt; v.x); // [2]</code></pre><h4 id="findLastIndex"><a href="#findLastIndex" class="headerlink" title="findLastIndex"></a>findLastIndex</h4><p>Returns the index of the last element for which the provided function returns a truthy value.</p><pre><code class="javaScript">const findLastIndex = (arr, fn) =&gt;  (arr    .map((val, i) =&gt; [i, val])    .filter(([i, val]) =&gt; fn(val, i, arr))    .pop() || [-1])[0];EXAMPLESfindLastIndex([1, 2, 3, 4], n =&gt; n % 2 === 1); // 2 (index of the value 3)findLastIndex([1, 2, 3, 4], n =&gt; n === 5); // -1 (default value when not found)</code></pre><h4 id="groupBy-对数组进行分组"><a href="#groupBy-对数组进行分组" class="headerlink" title="groupBy 对数组进行分组"></a>groupBy 对数组进行分组</h4><p>根据给定的函数对数组的元素进行分组</p><pre><code class="javaScript">const groupBy = (arr, fn) =&gt;  arr.map(typeof fn === &#39;function&#39; ? fn : val =&gt; val[fn]).reduce((acc, val, i) =&gt; {    acc[val] = (acc[val] || []).concat(arr[i]);    return acc;  }, {});EXAMPLESgroupBy([6.1, 4.2, 6.3], Math.floor); // {4: [4.2], 6: [6.1, 6.3]}groupBy([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], &#39;length&#39;); // {3: [&#39;one&#39;, &#39;two&#39;], 5: [&#39;three&#39;]}</code></pre><h4 id="intersectionBy"><a href="#intersectionBy" class="headerlink" title="intersectionBy"></a>intersectionBy</h4><p>Returns a list of elements that exist in both arrays, after applying the provided function to each array element of both.<br>将提供的函数应用于两个数组的每个数组元素后，返回两个数组中存在的元素列表。</p><pre><code class="javaScript">const intersectionBy = (a, b, fn) =&gt; {  const s = new Set(b.map(fn));  return a.filter(x =&gt; s.has(fn(x)));};EXAMPLESintersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor); // [2.1]</code></pre><h4 id="symmetricDifferenceBy"><a href="#symmetricDifferenceBy" class="headerlink" title="symmetricDifferenceBy"></a>symmetricDifferenceBy</h4><p>Returns the symmetric difference between two arrays, after applying the provided function to each array element of both.<br>将提供的函数应用于两个数组的每个数组元素后，返回两个数组之间的对称差异。</p><pre><code class="javaScript">const symmetricDifferenceBy = (a, b, fn) =&gt; {  const sA = new Set(a.map(v =&gt; fn(v))),    sB = new Set(b.map(v =&gt; fn(v)));  return [...a.filter(x =&gt; !sB.has(fn(x))), ...b.filter(x =&gt; !sA.has(fn(x)))];};EXAMPLESsymmetricDifferenceBy([2.1, 1.2], [2.3, 3.4], Math.floor); // [ 1.2, 3.4 ]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 30 Second </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js常用单行代码</title>
      <link href="/2019/12/02/js%E5%B8%B8%E7%94%A8%E5%8D%95%E8%A1%8C%E4%BB%A3%E7%A0%81/"/>
      <url>/2019/12/02/js%E5%B8%B8%E7%94%A8%E5%8D%95%E8%A1%8C%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="开发中常用的JavaScript单行代码"><a href="#开发中常用的JavaScript单行代码" class="headerlink" title="开发中常用的JavaScript单行代码"></a>开发中常用的JavaScript单行代码</h1><p><a href="https://www.30secondsofcode.org/" target="_blank" rel="noopener">30Second</a></p><h2 id="1-强制布尔值"><a href="#1-强制布尔值" class="headerlink" title="1.强制布尔值"></a>1.强制布尔值</h2><p>要将变量强制转换为布尔值而不更改其值：</p><pre><code class="javaScript">const myBoolean = !! myVariable;!!null // false!!undefined // false!!false // false!!ture // ture!!&quot;&quot; // false!!&quot;string&quot; // true!!0 // false!!1 // true!!{} // true!![] // true</code></pre><h2 id="2-基于某个条件为对象设置属性"><a href="#2-基于某个条件为对象设置属性" class="headerlink" title="2.基于某个条件为对象设置属性"></a>2.基于某个条件为对象设置属性</h2><p>要使用spread运算符有条件地在对象上设置属性：</p><pre><code class="javaScript">const myObject = {... myProperty &amp;&amp; {propName：myPoperty}};let myProperty = &#39;Jhon&#39;const myObject = {...myProperty &amp;&amp; {propName: myProperty}}; // {propName: &quot;Jhon&quot;}let myProperty = &#39;&#39;const myObject = {...myProperty &amp;&amp; {propName: myProperty}}; // {}</code></pre><p>如果myProperty结果为false，则 &amp;&amp; 失败并且不设置新属性; 否则，如果不为空，&amp;&amp; 将设置新属性并覆盖原来的值。</p><h2 id="3-合并对象"><a href="#3-合并对象" class="headerlink" title="3.合并对象"></a>3.合并对象</h2><pre><code class="javaScript">const mergedObject = { ...objectOne, ...objectTwo };const mergedObject = { ...{name: &#39;Jhon&#39;, age: &#39;18&#39;}, ...{name1: &#39;jhon1&#39;, age1: &#39;12&#39;}};// {name: &quot;Jhon&quot;, age: &quot;18&quot;, name1: &quot;jhon1&quot;, age1: &quot;12&quot;}const mergedObject = { ...{name: &#39;Jhon&#39;, age: &#39;18&#39;}, ...{name: &#39;jhon1&#39;, age:&#39;12&#39;}};// {name: &quot;jhon1&quot;, age: &quot;12&quot;}</code></pre><p>支持无限制合并，但如果对象之间存在相同属性，则后面属性会覆盖前面属性。*请注意，这仅适用于浅层合并。</p><h2 id="4-交换变量"><a href="#4-交换变量" class="headerlink" title="4.交换变量"></a>4.交换变量</h2><p>要在不使用中间变量的情况下交换两个变量的值：</p><pre><code class="javaScript">[varA，varB] = [varB，varA];let a = 1;let b = 2;[a, b] = [b, a] // a = 2 b = 1</code></pre><h2 id="5-删除Boolean-为-false-值"><a href="#5-删除Boolean-为-false-值" class="headerlink" title="5.删除Boolean 为 false 值"></a>5.删除Boolean 为 false 值</h2><pre><code class="javaScript">const clean = dirty.filter(Boolean);const clean = [0, false, true, undefined, null, &#39;&#39;, 12, 15].filter(Boolean);// [true, 12, 15]</code></pre><p>这将删除值等于：null，undefined，false，0 和空字符串(‘’)</p><h2 id="6-转换元素类型"><a href="#6-转换元素类型" class="headerlink" title="6.转换元素类型"></a>6.转换元素类型</h2><p>要将Number元素转换为String元素：</p><pre><code class="javaScript">const stringArray = numberArray.map(String);const stringArray = [1, 2, 3].map(String);[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</code></pre><p>如果数组包含字符串，字符串原样保留。 这也可以用于将String元素转换为Number类型：</p><pre><code class="javaScript">const numberArray = stringArray.map(Number);const stringArray = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(String);// [1, 2, 3]</code></pre><h2 id="7-格式化对象为JSON代码"><a href="#7-格式化对象为JSON代码" class="headerlink" title="7.格式化对象为JSON代码"></a>7.格式化对象为JSON代码</h2><p>要以可读的格式显示JSON代码：</p><pre><code class="javaScript">const formatted = JSON.stringify(myObj, null, 4);const formatted = JSON.stringify({name: &#39;Jhon&#39;, age: 18, address: &#39;sz&#39;}, null, 4);/*{    &quot;name&quot;: &quot;Jhon&quot;,    &quot;age&quot;: 18,    &quot;address&quot;: &quot;sz&quot;}*/</code></pre><p>该字符串化命令有三个参数。第一个是Javascript对象。第二个是可选函数，可用于在JSON进行字符串化时对其执行操作。最后一个参数指示要添加多少空格作为缩进以格式化JSON。省略最后一个参数，JSON将返回一个长行。如果myObj中存在循环引用，则会格式失败。</p><h2 id="8-快速创建数字数组"><a href="#8-快速创建数字数组" class="headerlink" title="8.快速创建数字数组"></a>8.快速创建数字数组</h2><p>要创建一个数组并用数字填充它，索引为零：</p><pre><code class="javaScript">const numArray = Array.from(new Array(10), (x, i)=&gt; i);// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><h2 id="9-随机生成六位数字验证码"><a href="#9-随机生成六位数字验证码" class="headerlink" title="9.随机生成六位数字验证码"></a>9.随机生成六位数字验证码</h2><pre><code class="javaScript">const code = Math.floor(Math.random() * 1000000).toString().padStart(6, &quot;0&quot;);// 942377</code></pre><h2 id="10-身份证正则"><a href="#10-身份证正则" class="headerlink" title="10.身份证正则"></a>10.身份证正则</h2><pre><code class="javaScript">const IDReg= /(^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$)|(^[1-9]\d{5}\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{2}[0-9Xx]$)/;</code></pre><h2 id="11-window-location-search-转-JS-对象"><a href="#11-window-location-search-转-JS-对象" class="headerlink" title="11.window.location.search 转 JS 对象"></a>11.window.location.search 转 JS 对象</h2><p>有时候我们会对url的查询参数即从问号 (?)后 开始的 URL（查询部分）进行转换</p><pre><code class="javaScript">const searchObj = search =&gt; JSON.parse(`{&quot;${decodeURIComponent(search.substring(1)).replace(/&quot;/g, &#39;\\&quot;&#39;).replace(/&amp;/g, &#39;&quot;,&quot;&#39;).replace(/=/g, &#39;&quot;:&quot;&#39;)}&quot;}`);// 假如请求url为// &#39;https://www.baidu.com?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=js&amp;rsv_pq=a86b5e5f0007bceb&amp;rsv_t=1e1fAVan%2BVlnkhJHFB0BIGLdLM2slszYMJBTTfFkmyyBUzBpw0ggeuVDE50&amp;rqlang=cn&amp;rsv_enter=0&amp;inputT=1287&amp;rsv_sug3=5&amp;rsv_sug1=3&amp;rsv_sug7=101&amp;rsv_sug2=0&amp;rsv_sug4=1907&#39;// 那么 window.location.search 就为：let search = &#39;?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=js&amp;rsv_pq=a86b5e5f0007bceb&amp;rsv_t=1e1fAVan%2BVlnkhJHFB0BIGLdLM2slszYMJBTTfFkmyyBUzBpw0ggeuVDE50&amp;rqlang=cn&amp;rsv_enter=0&amp;inputT=1287&amp;rsv_sug3=5&amp;rsv_sug1=3&amp;rsv_sug7=101&amp;rsv_sug2=0&amp;rsv_sug4=1907&#39;searchObj(search)</code></pre><p>格式化查询字符串得到如下对象：<br><img src="/images/16b4f62a2520fc6c.jpg" alt="tp1"></p><h2 id="12-JS-对象转-url-查询字符串"><a href="#12-JS-对象转-url-查询字符串" class="headerlink" title="12 JS 对象转 url 查询字符串"></a>12 JS 对象转 url 查询字符串</h2><pre><code class="javaScript">const objectToQueryString = (obj) =&gt; Object.keys(obj).map((key) =&gt; `${encodeURIComponent(key)}=${encodeURIComponent(obj[key])}`).join(&#39;&amp;&#39;);objectToQueryString({name: &#39;Jhon&#39;, age: 18, address: &#39;beijing&#39;})// name=Jhon&amp;age=18&amp;address=beijing</code></pre><h2 id="13-获取数组交集"><a href="#13-获取数组交集" class="headerlink" title="13.获取数组交集"></a>13.获取数组交集</h2><pre><code class="javaScript">const similarity = (arr, values) =&gt; arr.filter(v =&gt; values.includes(v));similarity([1, 2, 3], [1, 2, 4]); // [1,2]</code></pre><h2 id="14-检测设备类型"><a href="#14-检测设备类型" class="headerlink" title="14.检测设备类型"></a>14.检测设备类型</h2><p>使用正则表达式来检测 navigator.userAgent 属性判断设备是在移动设备还是在台式机/笔记本电脑打开。</p><pre><code class="javaScript">const detectDeviceType = () =&gt;/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|OperaMini/i.test(navigator.userAgent) ? &#39;Mobile&#39; : &#39;Desktop&#39;;</code></pre><h2 id="15-将数字转化为千分位格式"><a href="#15-将数字转化为千分位格式" class="headerlink" title="15. 将数字转化为千分位格式"></a>15. 将数字转化为千分位格式</h2><pre><code class="javaScript">const toDecimalMark = num =&gt; num.toLocaleString(&#39;en-US&#39;);toDecimalMark(12305030388.9087); // &quot;12,305,030,388.909&quot;</code></pre><h2 id="16-多维数组转一维数组"><a href="#16-多维数组转一维数组" class="headerlink" title="16 多维数组转一维数组"></a>16 多维数组转一维数组</h2><pre><code class="javaScript">const deepFlatten = arr =&gt; [].concat(...arr.map(v =&gt; (Array.isArray(v) ? deepFlatten(v) : v)));deepFlatten([1, [2], [[3], 4], 5]); // [1,2,3,4,5]</code></pre><h2 id="17-过滤对象数组"><a href="#17-过滤对象数组" class="headerlink" title="17.过滤对象数组"></a>17.过滤对象数组</h2><pre><code class="javaScript">const reducedFilter = (data, keys, fn) =&gt;data.filter(fn).map(el =&gt;keys.reduce((acc, key) =&gt; {acc[key] =el[key];return acc;}, {}));const data = [  {    id: 1,    name: &#39;john&#39;,    age: 24  },  {    id: 2,    name: &#39;mike&#39;,    age: 50  }];let a = reducedFilter(data, [&#39;id&#39;, &#39;name&#39;], item =&gt; item.age &gt; 24); // [{ id: 2, name: &#39;mike&#39;}]</code></pre><h2 id="18-驼峰字字符串格式化"><a href="#18-驼峰字字符串格式化" class="headerlink" title="18.驼峰字字符串格式化"></a>18.驼峰字字符串格式化</h2><p>转换驼峰拼写的字符串为特定格式。<br>使用 String.replace() 去除下划线，连字符和空格，并将驼峰拼写格式的单词转换为全小写。省略第二个参数 separator ，默认使用 _ 分隔符。</p><pre><code class="javaScript">const fromCamelCase = (str, separator = &#39;_&#39;) =&gt;str.replace(/([a-z\d])([A-Z])/g, &#39;$1&#39; + separator + &#39;$2&#39;).replace(/([A-Z]+)([A-Z][a-z\d]+)/g, &#39;$1&#39; + separator + &#39;$2&#39;).toLowerCase();fromCamelCase(&#39;someDatabaseFieldName&#39;, &#39; &#39;); // &#39;some database field name&#39;fromCamelCase(&#39;someLabelThatNeedsToBeCamelized&#39;, &#39;-&#39;); // &#39;some-label-that-needs-to-be-camelized&#39;fromCamelCase(&#39;someJavascriptProperty&#39;, &#39;_&#39;); // &#39;some_javascript_property&#39;</code></pre><h2 id="19-是否为绝对地址"><a href="#19-是否为绝对地址" class="headerlink" title="19.是否为绝对地址"></a>19.是否为绝对地址</h2><pre><code class="javaScript">const isAbsoluteURL = str =&gt; /^[a-z][a-z0-9+.-]*:/.test(str);isAbsoluteURL(&#39;https://google.com&#39;); // trueisAbsoluteURL(&#39;ftp://www.myserver.net&#39;); // trueisAbsoluteURL(&#39;/foo/bar&#39;); // false</code></pre><h2 id="20-获取两个日期相差天数"><a href="#20-获取两个日期相差天数" class="headerlink" title="20.获取两个日期相差天数"></a>20.获取两个日期相差天数</h2><pre><code class="javaScript">const getDaysDiffBetweenDates = (dateInitial, dateFinal) =&gt; (dateFinal - dateInitial) / (1000 * 3600 * 24);getDaysDiffBetweenDates(new Date(&#39;2017-12-13&#39;), new Date(&#39;2017-12-22&#39;)); // 9</code></pre><h2 id="21-数组去重"><a href="#21-数组去重" class="headerlink" title="21.数组去重"></a>21.数组去重</h2><pre><code class="javaScript">const deDupe = (myArray) =&gt; [... new Set(myArray)];deDupe([1, 1, 2, 1, 3, 3, 4])// [1, 2, 3, 4]</code></pre><h2 id="22-数组对象去重"><a href="#22-数组对象去重" class="headerlink" title="22.数组对象去重"></a>22.数组对象去重</h2><pre><code class="javaScript">const uniqueElementsBy = (arr, fn) =&gt;arr.reduce((acc, v) =&gt; {if (!acc.some(x =&gt; fn(v, x))) acc.push(v);return acc;}, []);uniqueElementsBy([{id: 1, name: &#39;Jhon&#39;}, {id: 2, name: &#39;sss&#39;}, {id: 1, name: &#39;Jhon&#39;}], (a, b) =&gt; a.id == b.id)// [{id: 1, name: &#39;Jhon&#39;}, {id: 2, name: &#39;sss&#39;}]</code></pre><h2 id="23-RGB-颜色转-16进制颜色"><a href="#23-RGB-颜色转-16进制颜色" class="headerlink" title="23. RGB 颜色转 16进制颜色"></a>23. RGB 颜色转 16进制颜色</h2><pre><code class="javaScript">const RGBToHex = (r, g, b) =&gt; ((r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).padStart(6, &#39;0&#39;);RGBToHex(255, 165, 1); // &#39;ffa501&#39;</code></pre><h2 id="24-常用密码组合正则"><a href="#24-常用密码组合正则" class="headerlink" title="24. 常用密码组合正则"></a>24. 常用密码组合正则</h2><pre><code class="javaScript">const passwordReg = /(?!^(\d+|[a-zA-Z]+|[~!@#$%^&amp;*?]+)$)^[\w~!@#$%^&amp;*?]{8,20}$/;// -长度8~20位字符，支持大小写字母、数字、符号三种字符中任意两种字符的组合</code></pre><h2 id="25-判断dom元素是否具有某个className"><a href="#25-判断dom元素是否具有某个className" class="headerlink" title="25. 判断dom元素是否具有某个className"></a>25. 判断dom元素是否具有某个className</h2><pre><code class="javaScript">const  hasClass = (el, className) =&gt; new RegExp(`(^|\\s)${className}(\\s|$)`).test(el.className);</code></pre><h2 id="26-多为数组去重"><a href="#26-多为数组去重" class="headerlink" title="26.多为数组去重"></a>26.多为数组去重</h2><pre><code class="javaScript">let arr = [1, [2, 3, [4, 5, 6]]]function flattern (arr) { return arr.reduce((prev, cur) =&gt; prev.concat(Array.isArray(cur) ? flattern(cur) : cur), [])}console.log(flattern(arr))</code></pre><pre><code class="javaScript"> [].flat(Infinity) </code></pre>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js方法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
